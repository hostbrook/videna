/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var uikit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uikit */ \"./node_modules/uikit/dist/js/uikit.js\");\n/* harmony import */ var uikit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uikit__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var uikit_dist_js_uikit_icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uikit/dist/js/uikit-icons */ \"./node_modules/uikit/dist/js/uikit-icons.js\");\n/* harmony import */ var uikit_dist_js_uikit_icons__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uikit_dist_js_uikit_icons__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n// loads the Icon plugin\nuikit__WEBPACK_IMPORTED_MODULE_0___default().use((uikit_dist_js_uikit_icons__WEBPACK_IMPORTED_MODULE_1___default()));\nwindow.UIkit = (uikit__WEBPACK_IMPORTED_MODULE_0___default());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBCO0FBQ29COztBQUU5QztBQUNBQSxnREFBUyxDQUFDQyxrRUFBSyxDQUFDO0FBRWhCRSxNQUFNLENBQUNILEtBQUssR0FBR0EsOENBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlbmEvLi9zcmMvanMvYXBwLmpzP2NkMTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFVJa2l0IGZyb20gJ3Vpa2l0JztcclxuaW1wb3J0IEljb25zIGZyb20gJ3Vpa2l0L2Rpc3QvanMvdWlraXQtaWNvbnMnO1xyXG5cclxuLy8gbG9hZHMgdGhlIEljb24gcGx1Z2luXHJcblVJa2l0LnVzZShJY29ucyk7XHJcblxyXG53aW5kb3cuVUlraXQgPSBVSWtpdDsiXSwibmFtZXMiOlsiVUlraXQiLCJJY29ucyIsInVzZSIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/app.js\n");

/***/ }),

/***/ "./src/less/app.less":
/*!***************************!*\
  !*** ./src/less/app.less ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGVzcy9hcHAubGVzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlbmEvLi9zcmMvbGVzcy9hcHAubGVzcz8yY2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/less/app.less\n");

/***/ }),

/***/ "./node_modules/uikit/dist/js/uikit-icons.js":
/*!***************************************************!*\
  !*** ./node_modules/uikit/dist/js/uikit-icons.js ***!
  \***************************************************/
/***/ (function(module) {

eval("/*! UIkit 3.15.18 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    function plugin(UIkit) {\n      if (plugin.installed) {\n        return;\n      }\n\n      UIkit.icon.add({\n        \"500px\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z\\\"/><path d=\\\"M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z\\\"/><path d=\\\"M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z\\\"/><path d=\\\"M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z\\\"/></svg>\",\n        \"album\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"5\\\" y=\\\"2\\\" width=\\\"10\\\" height=\\\"1\\\"/><rect x=\\\"3\\\" y=\\\"4\\\" width=\\\"14\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"6.5\\\" width=\\\"17\\\" height=\\\"11\\\"/></svg>\",\n        \"arrow-down\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"10.5\\\" y1=\\\"4\\\" x2=\\\"10.5\\\" y2=\\\"15\\\"/></svg>\",\n        \"arrow-left\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"10 14 5 9.5 10 5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"16\\\" y1=\\\"9.5\\\" x2=\\\"5\\\" y2=\\\"9.52\\\"/></svg>\",\n        \"arrow-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"10 5 15 9.5 10 14\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"4\\\" y1=\\\"9.5\\\" x2=\\\"15\\\" y2=\\\"9.5\\\"/></svg>\",\n        \"arrow-up\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"10.5\\\" y1=\\\"16\\\" x2=\\\"10.5\\\" y2=\\\"5\\\"/></svg>\",\n        \"bag\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M7.5,7.5V4A2.48,2.48,0,0,1,10,1.5,2.54,2.54,0,0,1,12.5,4V7.5\\\"/><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"16.5 7.5 3.5 7.5 2.5 18.5 17.5 18.5 16.5 7.5\\\"/></svg>\",\n        \"ban\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"4\\\" y1=\\\"3.5\\\" x2=\\\"16\\\" y2=\\\"16.5\\\"/></svg>\",\n        \"behance\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z\\\"/><path d=\\\"M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z\\\"/><rect x=\\\"13\\\" y=\\\"4\\\" width=\\\"5\\\" height=\\\"1.4\\\"/></svg>\",\n        \"bell\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16\\\"/></svg>\",\n        \"bold\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z\\\"/></svg>\",\n        \"bolt\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z\\\"/></svg>\",\n        \"bookmark\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5\\\"/></svg>\",\n        \"calendar\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z\\\"/><rect width=\\\"1\\\" height=\\\"3\\\" x=\\\"6\\\" y=\\\"2\\\"/><rect width=\\\"1\\\" height=\\\"3\\\" x=\\\"13\\\" y=\\\"2\\\"/></svg>\",\n        \"camera\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10.8\\\" r=\\\"3.8\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z\\\"/></svg>\",\n        \"cart\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"7.3\\\" cy=\\\"17.3\\\" r=\\\"1.4\\\"/><circle cx=\\\"13.3\\\" cy=\\\"17.3\\\" r=\\\"1.4\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5\\\"/></svg>\",\n        \"check\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"4,10 8,15 17,4\\\"/></svg>\",\n        \"chevron-double-left\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"10 14 6 10 10 6\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"14 14 10 10 14 6\\\"/></svg>\",\n        \"chevron-double-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"10 6 14 10 10 14\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"6 6 10 10 6 14\\\"/></svg>\",\n        \"chevron-down\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"16 7 10 13 4 7\\\"/></svg>\",\n        \"chevron-left\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"13 16 7 10 13 4\\\"/></svg>\",\n        \"chevron-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"7 4 13 10 7 16\\\"/></svg>\",\n        \"chevron-up\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"4 13 10 7 16 13\\\"/></svg>\",\n        \"clock\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M13.018,14.197 L9.445,10.625\\\"/></svg>\",\n        \"close\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.06\\\" d=\\\"M16,16 L4,4\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.06\\\" d=\\\"M16,4 L4,16\\\"/></svg>\",\n        \"cloud-download\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"11.75 16 9.5 18.25 7.25 16\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M9.5,18 L9.5,9.5\\\"/></svg>\",\n        \"cloud-upload\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"7.25 11.75 9.5 9.5 11.75 11.75\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M9.5,18 L9.5,9.5\\\"/></svg>\",\n        \"code\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"13,4 19,10 13,16\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"7,4 1,10 7,16\\\"/></svg>\",\n        \"cog\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"9.997\\\" cy=\\\"10\\\" r=\\\"3.31\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z\\\"/></svg>\",\n        \"comment\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z\\\"/></svg>\",\n        \"commenting\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5\\\"/><circle cx=\\\"10\\\" cy=\\\"8\\\" r=\\\"1\\\"/><circle cx=\\\"6\\\" cy=\\\"8\\\" r=\\\"1\\\"/><circle cx=\\\"14\\\" cy=\\\"8\\\" r=\\\"1\\\"/></svg>\",\n        \"comments\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"2 0.5 19.5 0.5 19.5 13\\\"/><path d=\\\"M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z\\\"/></svg>\",\n        \"copy\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"2.5\\\" width=\\\"12\\\" height=\\\"16\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"5 0.5 17.5 0.5 17.5 17\\\"/></svg>\",\n        \"credit-card\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"4.5\\\" width=\\\"17\\\" height=\\\"12\\\"/><rect x=\\\"1\\\" y=\\\"7\\\" width=\\\"18\\\" height=\\\"3\\\"/></svg>\",\n        \"crosshairs\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"7.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"10\\\" x2=\\\"10\\\" y2=\\\"8\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"10\\\" y1=\\\"12\\\" x2=\\\"10\\\" y2=\\\"20\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" y1=\\\"10\\\" x2=\\\"8\\\" y2=\\\"10\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"12\\\" y1=\\\"10\\\" x2=\\\"20\\\" y2=\\\"10\\\"/></svg>\",\n        \"database\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><ellipse fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"4.64\\\" rx=\\\"7.5\\\" ry=\\\"3.14\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64\\\"/></svg>\",\n        \"desktop\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"8\\\" y=\\\"15\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"11\\\" y=\\\"15\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"5\\\" y=\\\"16\\\" width=\\\"10\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"3.5\\\" width=\\\"17\\\" height=\\\"11\\\"/></svg>\",\n        \"discord\": \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\"><path d=\\\"M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z\\\"/></svg>\",\n        \"download\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"14,10 9.5,14.5 5,10\\\"/><rect x=\\\"3\\\" y=\\\"17\\\" width=\\\"13\\\" height=\\\"1\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"13.91\\\" x2=\\\"9.5\\\" y2=\\\"3\\\"/></svg>\",\n        \"dribbble\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" d=\\\"M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" d=\\\"M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" d=\\\"M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/></svg>\",\n        \"etsy\": \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\"><path d=\\\"M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z\\\"/></svg>\",\n        \"expand\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"13 2 18 2 18 7 17 7 17 3 13 3\\\"/><polygon points=\\\"2 13 3 13 3 17 7 17 7 18 2 18\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M11,9 L17,3\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M3,17 L9,11\\\"/></svg>\",\n        \"facebook\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z\\\"/></svg>\",\n        \"file-edit\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5\\\"/></svg>\",\n        \"file-pdf\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" width=\\\"13\\\" height=\\\"17\\\" x=\\\"3.5\\\" y=\\\"1.5\\\"/><path d=\\\"M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z\\\"/></svg>\",\n        \"file-text\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" width=\\\"13\\\" height=\\\"17\\\" x=\\\"3.5\\\" y=\\\"1.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"6\\\" x2=\\\"12\\\" y1=\\\"12.5\\\" y2=\\\"12.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"6\\\" x2=\\\"14\\\" y1=\\\"8.5\\\" y2=\\\"8.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"6\\\" x2=\\\"14\\\" y1=\\\"6.5\\\" y2=\\\"6.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"6\\\" x2=\\\"14\\\" y1=\\\"10.5\\\" y2=\\\"10.5\\\"/></svg>\",\n        \"file\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"1.5\\\" width=\\\"13\\\" height=\\\"17\\\"/></svg>\",\n        \"flickr\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"5.5\\\" cy=\\\"9.5\\\" r=\\\"3.5\\\"/><circle cx=\\\"14.5\\\" cy=\\\"9.5\\\" r=\\\"3.5\\\"/></svg>\",\n        \"folder\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5\\\"/></svg>\",\n        \"forward\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z\\\"/></svg>\",\n        \"foursquare\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z\\\"/></svg>\",\n        \"future\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline points=\\\"19 2 18 2 18 6 14 6 14 7 19 7 19 2\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10\\\"/><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"7\\\"/><path d=\\\"M13.018,14.197 L9.445,10.625\\\" fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\"/></svg>\",\n        \"git-branch\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"7\\\" cy=\\\"3\\\" r=\\\"2\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"14\\\" cy=\\\"6\\\" r=\\\"2\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"7\\\" cy=\\\"17\\\" r=\\\"2\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" d=\\\"M14,8 C14,10.41 12.43,10.87 10.56,11.25 C9.09,11.54 7,12.06 7,15 L7,5\\\"/></svg>\",\n        \"git-fork\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"5.79\\\" cy=\\\"2.79\\\" r=\\\"1.79\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"14.19\\\" cy=\\\"2.79\\\" r=\\\"1.79\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"10.03\\\" cy=\\\"16.79\\\" r=\\\"1.79\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" d=\\\"M5.79,4.57 L5.79,6.56 C5.79,9.19 10.03,10.22 10.03,13.31 C10.03,14.86 10.04,14.55 10.04,14.55 C10.04,14.37 10.04,14.86 10.04,13.31 C10.04,10.22 14.2,9.19 14.2,6.56 L14.2,4.57\\\"/></svg>\",\n        \"github-alt\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z\\\"/></svg>\",\n        \"github\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z\\\"/></svg>\",\n        \"gitter\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"3.5\\\" y=\\\"1\\\" width=\\\"1.531\\\" height=\\\"11.471\\\"/><rect x=\\\"7.324\\\" y=\\\"4.059\\\" width=\\\"1.529\\\" height=\\\"15.294\\\"/><rect x=\\\"11.148\\\" y=\\\"4.059\\\" width=\\\"1.527\\\" height=\\\"15.294\\\"/><rect x=\\\"14.971\\\" y=\\\"4.059\\\" width=\\\"1.529\\\" height=\\\"8.412\\\"/></svg>\",\n        \"google\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z\\\"/></svg>\",\n        \"grid\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"2\\\" y=\\\"2\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"8\\\" y=\\\"2\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"14\\\" y=\\\"2\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"2\\\" y=\\\"8\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"8\\\" y=\\\"8\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"14\\\" y=\\\"8\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"2\\\" y=\\\"14\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"8\\\" y=\\\"14\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"14\\\" y=\\\"14\\\" width=\\\"3\\\" height=\\\"3\\\"/></svg>\",\n        \"happy\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"13\\\" cy=\\\"7\\\" r=\\\"1\\\"/><circle cx=\\\"7\\\" cy=\\\"7\\\" r=\\\"1\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"8.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4\\\"/></svg>\",\n        \"hashtag\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z\\\"/></svg>\",\n        \"heart\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" d=\\\"M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z\\\"/></svg>\",\n        \"history\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"#000\\\" points=\\\"1 2 2 2 2 6 6 6 6 7 1 7 1 2\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10\\\"/><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M13.018,14.197 L9.445,10.625\\\"/></svg>\",\n        \"home\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65\\\"/><polygon points=\\\"15 4 18 4 18 7 17 7 17 5 15 5\\\"/><polygon points=\\\"3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19\\\"/></svg>\",\n        \"image\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"16.1\\\" cy=\\\"6.1\\\" r=\\\"1.1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\".5\\\" y=\\\"2.5\\\" width=\\\"19\\\" height=\\\"15\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"4,13 8,9 13,14\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"11,12 12.5,10.5 16,14\\\"/></svg>\",\n        \"info\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/></svg>\",\n        \"instagram\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z\\\"/><circle cx=\\\"14.87\\\" cy=\\\"5.26\\\" r=\\\"1.09\\\"/><path d=\\\"M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z\\\"/></svg>\",\n        \"italic\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z\\\"/></svg>\",\n        \"joomla\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z\\\"/><path d=\\\"M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8\\\"/><path d=\\\"M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8\\\"/><path d=\\\"M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7\\\"/></svg>\",\n        \"laptop\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect y=\\\"16\\\" width=\\\"20\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"2.5\\\" y=\\\"4.5\\\" width=\\\"15\\\" height=\\\"10\\\"/></svg>\",\n        \"lifesaver\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10,0.5 C4.76,0.5 0.5,4.76 0.5,10 C0.5,15.24 4.76,19.5 10,19.5 C15.24,19.5 19.5,15.24 19.5,10 C19.5,4.76 15.24,0.5 10,0.5 L10,0.5 Z M10,1.5 C11.49,1.5 12.89,1.88 14.11,2.56 L11.85,4.82 C11.27,4.61 10.65,4.5 10,4.5 C9.21,4.5 8.47,4.67 7.79,4.96 L5.58,2.75 C6.87,1.95 8.38,1.5 10,1.5 L10,1.5 Z M4.96,7.8 C4.67,8.48 4.5,9.21 4.5,10 C4.5,10.65 4.61,11.27 4.83,11.85 L2.56,14.11 C1.88,12.89 1.5,11.49 1.5,10 C1.5,8.38 1.95,6.87 2.75,5.58 L4.96,7.79 L4.96,7.8 L4.96,7.8 Z M10,18.5 C8.25,18.5 6.62,17.97 5.27,17.06 L7.46,14.87 C8.22,15.27 9.08,15.5 10,15.5 C10.79,15.5 11.53,15.33 12.21,15.04 L14.42,17.25 C13.13,18.05 11.62,18.5 10,18.5 L10,18.5 Z M10,14.5 C7.52,14.5 5.5,12.48 5.5,10 C5.5,7.52 7.52,5.5 10,5.5 C12.48,5.5 14.5,7.52 14.5,10 C14.5,12.48 12.48,14.5 10,14.5 L10,14.5 Z M15.04,12.21 C15.33,11.53 15.5,10.79 15.5,10 C15.5,9.08 15.27,8.22 14.87,7.46 L17.06,5.27 C17.97,6.62 18.5,8.25 18.5,10 C18.5,11.62 18.05,13.13 17.25,14.42 L15.04,12.21 L15.04,12.21 Z\\\"/></svg>\",\n        \"link\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M7.925,11.875 L11.925,7.975\\\"/></svg>\",\n        \"linkedin\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z\\\"/><path d=\\\"M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z\\\"/></svg>\",\n        \"list\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"6\\\" y=\\\"4\\\" width=\\\"12\\\" height=\\\"1\\\"/><rect x=\\\"6\\\" y=\\\"9\\\" width=\\\"12\\\" height=\\\"1\\\"/><rect x=\\\"6\\\" y=\\\"14\\\" width=\\\"12\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"4\\\" width=\\\"2\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"9\\\" width=\\\"2\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"14\\\" width=\\\"2\\\" height=\\\"1\\\"/></svg>\",\n        \"location\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" d=\\\"M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"6.8\\\" r=\\\"2.3\\\"/></svg>\",\n        \"lock\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" height=\\\"10\\\" width=\\\"13\\\" y=\\\"8.5\\\" x=\\\"3.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8\\\"/></svg>\",\n        \"mail\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"1.4,6.5 10,11 18.6,6.5\\\"/><path d=\\\"M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z\\\"/></svg>\",\n        \"menu\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"2\\\" y=\\\"4\\\" width=\\\"16\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"9\\\" width=\\\"16\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"14\\\" width=\\\"16\\\" height=\\\"1\\\"/></svg>\",\n        \"microphone\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"10\\\" x2=\\\"10\\\" y1=\\\"16.44\\\" y2=\\\"18.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"7\\\" x2=\\\"13\\\" y1=\\\"18.5\\\" y2=\\\"18.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6\\\"/></svg>\",\n        \"minus-circle\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9.5\\\" cy=\\\"9.5\\\" r=\\\"9\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"5\\\" y1=\\\"9.5\\\" x2=\\\"14\\\" y2=\\\"9.5\\\"/></svg>\",\n        \"minus\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect height=\\\"1\\\" width=\\\"18\\\" y=\\\"9\\\" x=\\\"1\\\"/></svg>\",\n        \"more-vertical\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"10\\\" cy=\\\"3\\\" r=\\\"2\\\"/><circle cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"2\\\"/><circle cx=\\\"10\\\" cy=\\\"17\\\" r=\\\"2\\\"/></svg>\",\n        \"more\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"3\\\" cy=\\\"10\\\" r=\\\"2\\\"/><circle cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"2\\\"/><circle cx=\\\"17\\\" cy=\\\"10\\\" r=\\\"2\\\"/></svg>\",\n        \"move\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"4,5 1,5 1,9 2,9 2,6 4,6\\\"/><polygon points=\\\"1,16 2,16 2,18 4,18 4,19 1,19\\\"/><polygon points=\\\"14,16 14,19 11,19 11,18 13,18 13,16\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"5.5\\\" y=\\\"1.5\\\" width=\\\"13\\\" height=\\\"13\\\"/><rect x=\\\"1\\\" y=\\\"11\\\" width=\\\"1\\\" height=\\\"3\\\"/><rect x=\\\"6\\\" y=\\\"18\\\" width=\\\"3\\\" height=\\\"1\\\"/></svg>\",\n        \"nut\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"3.5\\\"/></svg>\",\n        \"pagekit\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"3,1 17,1 17,16 10,16 10,13 14,13 14,4 6,4 6,16 10,16 10,19 3,19\\\"/></svg>\",\n        \"paint-bucket\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10.21,1 L0,11.21 L8.1,19.31 L18.31,9.1 L10.21,1 L10.21,1 Z M16.89,9.1 L15,11 L1.7,11 L10.21,2.42 L16.89,9.1 Z\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M6.42,2.33 L11.7,7.61\\\"/><path d=\\\"M18.49,12 C18.49,12 20,14.06 20,15.36 C20,16.28 19.24,17 18.49,17 L18.49,17 C17.74,17 17,16.28 17,15.36 C17,14.06 18.49,12 18.49,12 L18.49,12 Z\\\"/></svg>\",\n        \"pencil\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M15.98,7.268 L13.851,5.148\\\"/></svg>\",\n        \"phone-landscape\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z\\\"/><circle cx=\\\"3.8\\\" cy=\\\"10.5\\\" r=\\\".8\\\"/></svg>\",\n        \"phone\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z\\\"/><circle cx=\\\"10.5\\\" cy=\\\"16.5\\\" r=\\\".8\\\"/></svg>\",\n        \"pinterest\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1\\\"/></svg>\",\n        \"play-circle\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"8.5 7 13.5 10 8.5 13\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/></svg>\",\n        \"play\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"6.5,5 14.5,10 6.5,15\\\"/></svg>\",\n        \"plus-circle\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9.5\\\" cy=\\\"9.5\\\" r=\\\"9\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"5\\\" x2=\\\"9.5\\\" y2=\\\"14\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"5\\\" y1=\\\"9.5\\\" x2=\\\"14\\\" y2=\\\"9.5\\\"/></svg>\",\n        \"plus\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"9\\\" y=\\\"1\\\" width=\\\"1\\\" height=\\\"17\\\"/><rect x=\\\"1\\\" y=\\\"9\\\" width=\\\"17\\\" height=\\\"1\\\"/></svg>\",\n        \"print\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" width=\\\"11\\\" height=\\\"6\\\" x=\\\"4.5\\\" y=\\\"11.5\\\"/><rect width=\\\"8\\\" height=\\\"1\\\" x=\\\"6\\\" y=\\\"13\\\"/><rect width=\\\"8\\\" height=\\\"1\\\" x=\\\"6\\\" y=\\\"15\\\"/></svg>\",\n        \"pull\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"11\\\" x2=\\\"9.5\\\" y2=\\\"2\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5\\\"/></svg>\",\n        \"push\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"10\\\" x2=\\\"9.5\\\" y2=\\\"1\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5\\\"/></svg>\",\n        \"question\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/><circle cx=\\\"10.44\\\" cy=\\\"14.42\\\" r=\\\"1.05\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" d=\\\"M8.17,7.79 C8.17,4.75 12.72,4.73 12.72,7.72 C12.72,8.67 11.81,9.15 11.23,9.75 C10.75,10.24 10.51,10.73 10.45,11.4 C10.44,11.53 10.43,11.64 10.43,11.75\\\"/></svg>\",\n        \"quote-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z\\\"/><path d=\\\"M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z\\\"/></svg>\",\n        \"receiver\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" d=\\\"M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611\\\"/></svg>\",\n        \"reddit\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z\\\"/><path d=\\\"M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z\\\"/><path d=\\\"M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z\\\"/><path d=\\\"M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z\\\"/></svg>\",\n        \"refresh\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"9.9 2 12.79 4.89 9.79 7.9\\\"/></svg>\",\n        \"reply\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z\\\"/></svg>\",\n        \"rss\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"3.12\\\" cy=\\\"16.8\\\" r=\\\"1.85\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5\\\"/></svg>\",\n        \"search\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9\\\" cy=\\\"9\\\" r=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M14,14 L18,18 L14,14 Z\\\"/></svg>\",\n        \"server\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"3\\\" y=\\\"3\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"5\\\" y=\\\"3\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"7\\\" y=\\\"3\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"16\\\" y=\\\"3\\\" width=\\\"1\\\" height=\\\"1\\\"/><rect x=\\\"16\\\" y=\\\"10\\\" width=\\\"1\\\" height=\\\"1\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"9.9\\\" cy=\\\"17.4\\\" r=\\\"1.4\\\"/><rect x=\\\"3\\\" y=\\\"10\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"5\\\" y=\\\"10\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"9.5\\\" y=\\\"14\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"3\\\" y=\\\"17\\\" width=\\\"6\\\" height=\\\"1\\\"/><rect x=\\\"11\\\" y=\\\"17\\\" width=\\\"6\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"1.5\\\" width=\\\"17\\\" height=\\\"5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"8.5\\\" width=\\\"17\\\" height=\\\"5\\\"/></svg>\",\n        \"settings\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><ellipse fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"6.11\\\" cy=\\\"3.55\\\" rx=\\\"2.11\\\" ry=\\\"2.15\\\"/><ellipse fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"6.11\\\" cy=\\\"15.55\\\" rx=\\\"2.11\\\" ry=\\\"2.15\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"13.15\\\" cy=\\\"9.55\\\" r=\\\"2.15\\\"/><rect x=\\\"1\\\" y=\\\"3\\\" width=\\\"3\\\" height=\\\"1\\\"/><rect x=\\\"10\\\" y=\\\"3\\\" width=\\\"8\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"9\\\" width=\\\"8\\\" height=\\\"1\\\"/><rect x=\\\"15\\\" y=\\\"9\\\" width=\\\"3\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"15\\\" width=\\\"3\\\" height=\\\"1\\\"/><rect x=\\\"10\\\" y=\\\"15\\\" width=\\\"8\\\" height=\\\"1\\\"/></svg>\",\n        \"shrink\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"11 4 12 4 12 8 16 8 16 9 11 9\\\"/><polygon points=\\\"4 11 9 11 9 16 8 16 8 12 4 12\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M12,8 L18,2\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M2,18 L8,12\\\"/></svg>\",\n        \"sign-in\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3\\\"/><polygon points=\\\"9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5\\\"/></svg>\",\n        \"sign-out\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5\\\"/><polygon points=\\\"13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3\\\"/></svg>\",\n        \"social\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"13.4\\\" y1=\\\"14\\\" x2=\\\"6.3\\\" y2=\\\"10.7\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"13.5\\\" y1=\\\"5.5\\\" x2=\\\"6.5\\\" y2=\\\"8.8\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"15.5\\\" cy=\\\"4.6\\\" r=\\\"2.3\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"15.5\\\" cy=\\\"14.8\\\" r=\\\"2.3\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"4.5\\\" cy=\\\"9.8\\\" r=\\\"2.3\\\"/></svg>\",\n        \"soundcloud\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z\\\"/><rect x=\\\"6\\\" y=\\\"6.5\\\" width=\\\"1.5\\\" height=\\\"8.5\\\"/><rect x=\\\"3\\\" y=\\\"8\\\" width=\\\"1.5\\\" height=\\\"7\\\"/><rect y=\\\"10\\\" width=\\\"1.5\\\" height=\\\"5\\\"/></svg>\",\n        \"star\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27\\\"/></svg>\",\n        \"strikethrough\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z\\\"/><rect x=\\\"3\\\" y=\\\"10\\\" width=\\\"15\\\" height=\\\"1\\\"/></svg>\",\n        \"table\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"1\\\" y=\\\"3\\\" width=\\\"18\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"7\\\" width=\\\"18\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"11\\\" width=\\\"18\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"15\\\" width=\\\"18\\\" height=\\\"1\\\"/></svg>\",\n        \"tablet-landscape\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z\\\"/><circle cx=\\\"3.7\\\" cy=\\\"10.5\\\" r=\\\".8\\\"/></svg>\",\n        \"tablet\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z\\\"/><circle cx=\\\"10.5\\\" cy=\\\"16.3\\\" r=\\\".8\\\"/></svg>\",\n        \"tag\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z\\\"/><circle cx=\\\"14\\\" cy=\\\"6\\\" r=\\\"1\\\"/></svg>\",\n        \"thumbnails\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"3.5\\\" width=\\\"5\\\" height=\\\"5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"11.5\\\" y=\\\"3.5\\\" width=\\\"5\\\" height=\\\"5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"11.5\\\" y=\\\"11.5\\\" width=\\\"5\\\" height=\\\"5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"11.5\\\" width=\\\"5\\\" height=\\\"5\\\"/></svg>\",\n        \"tiktok\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.24,6V8.82a6.79,6.79,0,0,1-4-1.28v5.81A5.26,5.26,0,1,1,8,8.1a4.36,4.36,0,0,1,.72.05v2.9A2.57,2.57,0,0,0,7.64,11a2.4,2.4,0,1,0,2.77,2.38V2h2.86a4,4,0,0,0,1.84,3.38A4,4,0,0,0,17.24,6Z\\\"/></svg>\",\n        \"trash\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"6.5 3 6.5 1.5 13.5 1.5 13.5 3\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"4.5 4 4.5 18.5 15.5 18.5 15.5 4\\\"/><rect x=\\\"8\\\" y=\\\"7\\\" width=\\\"1\\\" height=\\\"9\\\"/><rect x=\\\"11\\\" y=\\\"7\\\" width=\\\"1\\\" height=\\\"9\\\"/><rect x=\\\"2\\\" y=\\\"3\\\" width=\\\"16\\\" height=\\\"1\\\"/></svg>\",\n        \"triangle-down\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"5 7 15 7 10 12\\\"/></svg>\",\n        \"triangle-left\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"12 5 7 10 12 15\\\"/></svg>\",\n        \"triangle-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"8 5 13 10 8 15\\\"/></svg>\",\n        \"triangle-up\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"5 13 10 8 15 13\\\"/></svg>\",\n        \"tripadvisor\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0\\tc0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009\\tc1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15\\tc2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594\\tc-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811\\tc-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079\\tc2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066\\tc-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002\\tc2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775\\tc0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468\\tC3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479\\tc1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775\\tc0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627\\tc-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618\\tc0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968\\tc-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72\\tC9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z\\\"/></svg>\",\n        \"tumblr\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z\\\"/></svg>\",\n        \"tv\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"7\\\" y=\\\"16\\\" width=\\\"6\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\".5\\\" y=\\\"3.5\\\" width=\\\"19\\\" height=\\\"11\\\"/></svg>\",\n        \"twitch\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M5.23,1,2,4.23V15.85H5.88v3.23L9.1,15.85h2.59L17.5,10V1Zm11,8.4L13.62,12H11L8.78,14.24V12H5.88V2.29H16.21Z\\\"/><rect x=\\\"12.98\\\" y=\\\"4.55\\\" width=\\\"1.29\\\" height=\\\"3.88\\\"/><rect x=\\\"9.43\\\" y=\\\"4.55\\\" width=\\\"1.29\\\" height=\\\"3.88\\\"/></svg>\",\n        \"twitter\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74\\\"/></svg>\",\n        \"uikit\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3\\\"/><polygon points=\\\"9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3\\\"/></svg>\",\n        \"unlock\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"8.5\\\" width=\\\"13\\\" height=\\\"10\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9\\\"/></svg>\",\n        \"upload\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"5 8 9.5 3.5 14 8\\\"/><rect x=\\\"3\\\" y=\\\"17\\\" width=\\\"13\\\" height=\\\"1\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"15\\\" x2=\\\"9.5\\\" y2=\\\"4\\\"/></svg>\",\n        \"user\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9.9\\\" cy=\\\"6.4\\\" r=\\\"4.4\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2\\\"/></svg>\",\n        \"users\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"7.7\\\" cy=\\\"8.6\\\" r=\\\"3.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1\\\"/></svg>\",\n        \"video-camera\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"17.5 6.9 17.5 13.1 13.5 10.4 13.5 14.5 2.5 14.5 2.5 5.5 13.5 5.5 13.5 9.6 17.5 6.9\\\"/></svg>\",\n        \"vimeo\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z\\\"/></svg>\",\n        \"warning\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"10\\\" cy=\\\"14\\\" r=\\\"1\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/><path d=\\\"M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z\\\"/></svg>\",\n        \"whatsapp\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9\\\"/></svg>\",\n        \"wordpress\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z\\\"/></svg>\",\n        \"world\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M1,10.5 L19,10.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M2.35,15.5 L17.65,15.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M2.35,5.5 L17.523,5.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"10.5\\\" r=\\\"9\\\"/></svg>\",\n        \"xing\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z\\\"/><path d=\\\"M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z\\\"/></svg>\",\n        \"yelp\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069\\tc-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276\\tc0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789\\tc-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025\\tc0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155\\tc-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351\\tc-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479\\tc0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421\\tc-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272\\tc0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749\\tC10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794\\tC2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667\\tc0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z\\\"/></svg>\",\n        \"youtube\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z\\\"/></svg>\"\n      });\n    }\n\n    if (typeof window !== 'undefined' && window.UIkit) {\n      window.UIkit.use(plugin);\n    }\n\n    return plugin;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvZGlzdC9qcy91aWtpdC1pY29ucy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUN5RztBQUM3RyxDQUFDLHVCQUF1Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVuYS8uL25vZGVfbW9kdWxlcy91aWtpdC9kaXN0L2pzL3Vpa2l0LWljb25zLmpzP2VlNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIFVJa2l0IDMuMTUuMTggfCBodHRwczovL3d3dy5nZXR1aWtpdC5jb20gfCAoYykgMjAxNCAtIDIwMjIgWU9PdGhlbWUgfCBNSVQgTGljZW5zZSAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ3Vpa2l0aWNvbnMnLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlVJa2l0SWNvbnMgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gcGx1Z2luKFVJa2l0KSB7XG4gICAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIFVJa2l0Lmljb24uYWRkKHtcbiAgICAgICAgXCI1MDBweFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTkuNjI0LDExLjg2NmMtMC4xNDEsMC4xMzIsMC40NzksMC42NTgsMC42NjIsMC40MThjMC4wNTEtMC4wNDYsMC42MDctMC42MSwwLjY2Mi0wLjY2NGMwLDAsMC43MzgsMC43MTksMC44MTQsMC43MTkgYzAuMSwwLDAuMjA3LTAuMDU1LDAuMzIyLTAuMTdjMC4yNy0wLjI2OSwwLjEzNS0wLjQxNiwwLjA2Ni0wLjQ5NWwtMC42MzEtMC42MTZsMC42NTgtMC42NjhjMC4xNDYtMC4xNTYsMC4wMjEtMC4zMTQtMC4xLTAuNDQ5IGMtMC4xODItMC4xOC0wLjM1OS0wLjIyNi0wLjQ3MS0wLjEyNWwtMC42NTYsMC42NTRsLTAuNjU0LTAuNjU0Yy0wLjAzMy0wLjAzNC0wLjA4LTAuMDQ1LTAuMTI0LTAuMDQ1IGMtMC4wNzksMC0wLjE5MSwwLjA2OC0wLjMwNywwLjE4MWMtMC4yMDIsMC4yMDItMC4yNDcsMC4zNTEtMC4xMzMsMC40NjJsMC42NjUsMC42NjVMOS42MjQsMTEuODY2elxcXCIvPjxwYXRoIGQ9XFxcIk0xMS4wNjYsMi44ODRjLTEuMDYxLDAtMi4xODUsMC4yNDgtMy4wMTEsMC42MDRjLTAuMDg3LDAuMDM0LTAuMTQxLDAuMTA2LTAuMTUsMC4yMDVDNy44OTMsMy43ODQsNy45MTksMy45MDksNy45ODIsNC4wNjYgYzAuMDUsMC4xMzYsMC4xODcsMC40NzQsMC40NTIsMC4zNzJjMC44NDQtMC4zMjYsMS43NzktMC41MDcsMi42MzMtMC41MDdjMC45NjMsMCwxLjksMC4xOTEsMi43ODEsMC41NjQgYzAuNjk1LDAuMjkyLDEuMzU3LDAuNzE5LDIuMDc4LDEuMzRjMC4wNTEsMC4wNDQsMC4xMDUsMC4wNjgsMC4xNjQsMC4wNjhjMC4xNDMsMCwwLjI3My0wLjEzNywwLjM4OS0wLjI3MSBjMC4xOTEtMC4yMTQsMC4zMjQtMC4zOTUsMC4xMzUtMC41NzVjLTAuNjg2LTAuNjU0LTEuNDM2LTEuMTM4LTIuMzYzLTEuNTMzQzEzLjI0LDMuMDk3LDEyLjE2OCwyLjg4NCwxMS4wNjYsMi44ODR6XFxcIi8+PHBhdGggZD1cXFwiTTE2LjQzLDE1Ljc0N2MtMC4wOTItMC4wMjgtMC4yNDIsMC4wNS0wLjMwOSwwLjExOWwwLDBjLTAuNjUyLDAuNjUyLTEuNDIsMS4xNjktMi4yNjgsMS41MjEgYy0wLjg3NywwLjM3MS0xLjgxNCwwLjU1MS0yLjc3OSwwLjU1MWMtMC45NjEsMC0xLjg5Ni0wLjE4OS0yLjc3NS0wLjU2NGMtMC44NDgtMC4zNi0xLjYxMi0wLjg3OS0yLjI2OC0xLjUzIGMtMC42ODItMC42ODgtMS4xOTYtMS40NTUtMS41MjktMi4yNjhjLTAuMzI1LTAuNzk5LTAuNDcxLTEuNjQzLTAuNDcxLTEuNjQzYy0wLjA0NS0wLjI0LTAuMjU4LTAuMjQ5LTAuNTY3LTAuMjAzIGMtMC4xMjgsMC4wMjEtMC41MTksMC4wNzktMC40ODMsMC4zNnYwLjAxYzAuMTA1LDAuNjQ0LDAuMjg5LDEuMjg0LDAuNTQ1LDEuODk1YzAuNDE3LDAuOTY5LDEuMDAyLDEuODQ5LDEuNzU2LDIuNjA0IGMwLjc1NywwLjc1NCwxLjYzNiwxLjM0LDIuNjA0LDEuNzU3QzguOTAxLDE4Ljc4NSw5Ljk3LDE5LDExLjA4OCwxOWMxLjEwNCwwLDIuMTg2LTAuMjE1LDMuMTg4LTAuNjQ1IGMxLjgzOC0wLjg5NiwyLjYwNC0xLjc1NywyLjYwNC0xLjc1N2MwLjE4Mi0wLjIwNCwwLjIyNy0wLjMxNy0wLjEtMC42NDNDMTYuNzc5LDE1Ljk1NiwxNi41MjUsMTUuNzc0LDE2LjQzLDE1Ljc0N3pcXFwiLz48cGF0aCBkPVxcXCJNNS42MzMsMTMuMjg3YzAuMjkzLDAuNzEsMC43MjMsMS4zNDEsMS4yNjIsMS44ODJjMC41NCwwLjU0LDEuMTcyLDAuOTcxLDEuODgyLDEuMjY0YzAuNzMxLDAuMzAzLDEuNTA5LDAuNDYxLDIuMjk4LDAuNDYxIGMwLjgwMSwwLDEuNTc4LTAuMTU4LDIuMjk3LTAuNDYxYzAuNzExLTAuMjkzLDEuMzQ0LTAuNzI0LDEuODgzLTEuMjY0YzAuNTQzLTAuNTQxLDAuOTcxLTEuMTcyLDEuMjY0LTEuODgyIGMwLjMxNC0wLjcyMSwwLjQ2My0xLjUsMC40NjMtMi4yOThjMC0wLjc5LTAuMTQ4LTEuNTY5LTAuNDYzLTIuMjg5Yy0wLjI5My0wLjY5OS0wLjcyMS0xLjMyOS0xLjI2NC0xLjg4MSBjLTAuNTM5LTAuNTQxLTEuMTcyLTAuOTU5LTEuODY3LTEuMjYzYy0wLjcyMS0wLjMwMy0xLjUtMC40NjEtMi4yOTktMC40NjFjLTAuODAyLDAtMS42MTMsMC4xNTktMi4zMjIsMC40NjEgYy0wLjU3NywwLjI1LTEuNTQ0LDAuODY3LTIuMTE5LDEuNDU0djAuMDEyVjIuMTA4aDguMTZDMTUuMSwyLjEwNCwxNS4xLDEuNjksMTUuMSwxLjU1MkMxNS4xLDEuNDE3LDE1LjEsMSwxNC44MDksMUg1LjkxNSBDNS42NzYsMSw1LjUyNywxLjE5Miw1LjUyNywxLjM4NHY2Ljg0YzAsMC4yMTQsMC4yNzMsMC4zNzIsMC41MjksMC40MjhjMC41LDAuMTA1LDAuNjE0LTAuMDU2LDAuNzM3LTAuMjI0bDAsMCBjMC4xOC0wLjI3MywwLjc3Ni0wLjg4NCwwLjc4Ny0wLjg5NGMwLjkwMS0wLjkwNSwyLjExNy0xLjQwOCwzLjQxNi0xLjQwOGMxLjI4NSwwLDIuNSwwLjUwMSwzLjQxMiwxLjQwOCBjMC45MTQsMC45MTQsMS40MDgsMi4xMjIsMS40MDgsMy40MDVjMCwxLjI4OC0wLjUwOCwyLjQ5Ni0xLjQwOCwzLjQwNWMtMC45LDAuODk2LTIuMTUyLDEuNDA2LTMuNDM4LDEuNDA2IGMtMC44NzcsMC0xLjcxMS0wLjIyOS0yLjQzMy0wLjY3MXYtNC4xNThjMC0wLjU1MywwLjIzNy0xLjE1MSwwLjY0My0xLjYxNGMwLjQ2Mi0wLjUxOSwxLjA5NC0wLjc5OSwxLjc4Mi0wLjc5OSBjMC42NjQsMCwxLjI5MywwLjI1MywxLjc1OCwwLjcxNWMwLjQ1OSwwLjQ1OSwwLjcwOSwxLjA3MSwwLjcwOSwxLjcyM2MwLDEuMzg1LTEuMDk0LDIuNDY4LTIuNDg4LDIuNDY4IGMtMC4yNzMsMC0wLjc2OS0wLjEyMS0wLjc4MS0wLjEyNWMtMC4yODEtMC4wODctMC40MDUsMC4zMDYtMC40MzgsMC40MzZjLTAuMTU5LDAuNDk2LDAuMDc5LDAuNTg1LDAuMTIzLDAuNjA3IGMwLjQ1MiwwLjEzNywwLjc0MywwLjE1NywxLjEyOSwwLjE1N2MxLjk3MywwLDMuNTcyLTEuNiwzLjU3Mi0zLjU3YzAtMS45NjQtMS42LTMuNTUyLTMuNTcyLTMuNTUyYy0wLjk3LDAtMS44NzIsMC4zNi0yLjU0NiwxLjAzOCBjLTAuNjU2LDAuNjMxLTEuMDI3LDEuNDg3LTEuMDI3LDIuMzIydjMuNDM4di0wLjAxMWMtMC4zNzItMC40Mi0wLjczMi0xLjA0MS0wLjk4MS0xLjY4MmMtMC4xMDItMC4yNDgtMC4zMTUtMC4yMDItMC42MDctMC4xMTMgYy0wLjEzNSwwLjAzNS0wLjUxOSwwLjE1Ny0wLjQ0LDAuNDM5QzUuMzcyLDEyLjc5OSw1LjU3NywxMy4xNjQsNS42MzMsMTMuMjg3elxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImFsYnVtXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCI1XFxcIiB5PVxcXCIyXFxcIiB3aWR0aD1cXFwiMTBcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIxNFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxLjVcXFwiIHk9XFxcIjYuNVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjExXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYXJyb3ctZG93blwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMC41LDE2LjA4IDUuNjMsMTAuNjYgNi4zNywxMCAxMC41LDE0LjU4IDE0LjYzLDEwIDE1LjM3LDEwLjY2XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiMTAuNVxcXCIgeTE9XFxcIjRcXFwiIHgyPVxcXCIxMC41XFxcIiB5Mj1cXFwiMTVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJhcnJvdy1sZWZ0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjEwIDE0IDUgOS41IDEwIDVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCIxNlxcXCIgeTE9XFxcIjkuNVxcXCIgeDI9XFxcIjVcXFwiIHkyPVxcXCI5LjUyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYXJyb3ctcmlnaHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTAgNSAxNSA5LjUgMTAgMTRcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI0XFxcIiB5MT1cXFwiOS41XFxcIiB4Mj1cXFwiMTVcXFwiIHkyPVxcXCI5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJhcnJvdy11cFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMC41LDQgMTUuMzcsOS40IDE0LjYzLDEwLjA4IDEwLjUsNS40OSA2LjM3LDEwLjA4IDUuNjMsOS40XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiMTAuNVxcXCIgeTE9XFxcIjE2XFxcIiB4Mj1cXFwiMTAuNVxcXCIgeTI9XFxcIjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJiYWdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTcuNSw3LjVWNEEyLjQ4LDIuNDgsMCwwLDEsMTAsMS41LDIuNTQsMi41NCwwLDAsMSwxMi41LDRWNy41XFxcIi8+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjE2LjUgNy41IDMuNSA3LjUgMi41IDE4LjUgMTcuNSAxOC41IDE2LjUgNy41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYmFuXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjRcXFwiIHkxPVxcXCIzLjVcXFwiIHgyPVxcXCIxNlxcXCIgeTI9XFxcIjE2LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJiZWhhbmNlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNOS41LDEwLjZjLTAuNC0wLjUtMC45LTAuOS0xLjYtMS4xYzEuNy0xLDIuMi0zLjIsMC43LTQuN0M3LjgsNCw2LjMsNCw1LjIsNEMzLjUsNCwxLjcsNCwwLDR2MTJjMS43LDAsMy40LDAsNS4yLDAgYzEsMCwyLjEsMCwzLjEtMC41QzEwLjIsMTQuNiwxMC41LDEyLjMsOS41LDEwLjZMOS41LDEwLjZ6IE01LjYsNi4xYzEuOCwwLDEuOCwyLjctMC4xLDIuN2MtMSwwLTIsMC0yLjksMFY2LjFINS42eiBNMi42LDEzLjh2LTMuMSBjMS4xLDAsMi4xLDAsMy4yLDBjMi4xLDAsMi4xLDMuMiwwLjEsMy4yTDIuNiwxMy44elxcXCIvPjxwYXRoIGQ9XFxcIk0xOS45LDEwLjlDMTkuNyw5LjIsMTguNyw3LjYsMTcsN2MtNC4yLTEuMy03LjMsMy40LTUuMyw3LjFjMC45LDEuNywyLjgsMi4zLDQuNywyLjFjMS43LTAuMiwyLjktMS4zLDMuNC0yLjloLTIuMiBjLTAuNCwxLjMtMi40LDEuNS0zLjUsMC42Yy0wLjQtMC40LTAuNi0xLjEtMC42LTEuN0gyMEMyMCwxMS43LDE5LjksMTAuOSwxOS45LDEwLjl6IE0xMy41LDEwLjZjMC0xLjYsMi4zLTIuNywzLjUtMS40IGMwLjQsMC40LDAuNSwwLjksMC42LDEuNEgxMy41TDEzLjUsMTAuNnpcXFwiLz48cmVjdCB4PVxcXCIxM1xcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjVcXFwiIGhlaWdodD1cXFwiMS40XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYmVsbFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE3LDE1LjUgTDMsMTUuNSBDMi45OSwxNC42MSAzLjc5LDEzLjM0IDQuMSwxMi41MSBDNC41OCwxMS4zIDQuNzIsMTAuMzUgNS4xOSw3LjAxIEM1LjU0LDQuNTMgNS44OSwzLjIgNy4yOCwyLjE2IEM4LjEzLDEuNTYgOS4zNywxLjUgOS44MSwxLjUgTDkuOTYsMS41IEM5Ljk2LDEuNSAxMS42MiwxLjQxIDEyLjY3LDIuMTcgQzE0LjA4LDMuMiAxNC40Miw0LjU0IDE0Ljc3LDcuMDIgQzE1LjI2LDEwLjM1IDE1LjQsMTEuMzEgMTUuODcsMTIuNTIgQzE2LjIsMTMuMzQgMTcuMDEsMTQuNjEgMTcsMTUuNSBMMTcsMTUuNSBaXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTIuMzksMTYgQzEyLjM5LDE3LjM3IDExLjM1LDE4LjQzIDkuOTEsMTguNDMgQzguNDgsMTguNDMgNy40MiwxNy4zNyA3LjQyLDE2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYm9sZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTUsMTUuMyBDNS42NiwxNS4zIDUuOSwxNSA1LjksMTQuNTMgTDUuOSw1LjUgQzUuOSw0LjkyIDUuNTYsNC43IDUsNC43IEw1LDQgTDguOTUsNCBDMTIuNiw0IDEzLjcsNS4zNyAxMy43LDYuOSBDMTMuNyw3Ljg3IDEzLjE0LDkuMTcgMTAuODYsOS41OSBMMTAuODYsOS43IEMxMy4yNSw5Ljg2IDE0LjI5LDExLjI4IDE0LjMsMTIuNTQgQzE0LjMsMTQuNDcgMTIuOTQsMTYgOSwxNiBMNSwxNiBMNSwxNS4zIFogTTksOS4zIEMxMS4xOSw5LjMgMTEuOCw4LjUgMTEuODUsNyBDMTEuODUsNS42NSAxMS4zLDQuOCA5LDQuOCBMNy42Nyw0LjggTDcuNjcsOS4zIEw5LDkuMyBaIE05LjE4NSwxNS4yMiBDMTEuOTcsMTUgMTIuMzksMTQgMTIuNCwxMi41OCBDMTIuNCwxMS4xNSAxMS4zOSwxMCA5LDEwIEw3LjY3LDEwIEw3LjY3LDE1IEw5LjE4LDE1IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJib2x0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNC43NCwyMCBMNy43MywxMiBMMywxMiBMMTUuNDMsMSBMMTIuMzIsOSBMMTcuMDIsOSBMNC43NCwyMCBMNC43NCwyMCBMNC43NCwyMCBaIE05LjE4LDExIEw3LjEsMTYuMzkgTDE0LjQ3LDEwIEwxMC44NiwxMCBMMTIuOTksNC42NyBMNS42MSwxMSBMOS4xOCwxMSBMOS4xOCwxMSBMOS4xOCwxMSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYm9va21hcmtcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI1LjUgMS41IDE1LjUgMS41IDE1LjUgMTcuNSAxMC41IDEyLjUgNS41IDE3LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjYWxlbmRhclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTSAyLDMgMiwxNyAxOCwxNyAxOCwzIDIsMyBaIE0gMTcsMTYgMywxNiAzLDggMTcsOCAxNywxNiBaIE0gMTcsNyAzLDcgMyw0IDE3LDQgMTcsNyBaXFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiM1xcXCIgeD1cXFwiNlxcXCIgeT1cXFwiMlxcXCIvPjxyZWN0IHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjNcXFwiIHg9XFxcIjEzXFxcIiB5PVxcXCIyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2FtZXJhXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwLjhcXFwiIHI9XFxcIjMuOFxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTEsNC41IEMwLjcsNC41IDAuNSw0LjcgMC41LDUgTDAuNSwxNyBDMC41LDE3LjMgMC43LDE3LjUgMSwxNy41IEwxOSwxNy41IEMxOS4zLDE3LjUgMTkuNSwxNy4zIDE5LjUsMTcgTDE5LjUsNSBDMTkuNSw0LjcgMTkuMyw0LjUgMTksNC41IEwxMy41LDQuNSBMMTMuNSwyLjkgQzEzLjUsMi42IDEzLjMsMi41IDEzLDIuNSBMNywyLjUgQzYuNywyLjUgNi41LDIuNiA2LjUsMi45IEw2LjUsNC41IEwxLDQuNSBMMSw0LjUgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNhcnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjcuM1xcXCIgY3k9XFxcIjE3LjNcXFwiIHI9XFxcIjEuNFxcXCIvPjxjaXJjbGUgY3g9XFxcIjEzLjNcXFwiIGN5PVxcXCIxNy4zXFxcIiByPVxcXCIxLjRcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjAgMiAzLjIgNCA1LjMgMTIuNSAxNiAxMi41IDE4IDYuNSA4IDYuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNoZWNrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgcG9pbnRzPVxcXCI0LDEwIDgsMTUgMTcsNFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNoZXZyb24tZG91YmxlLWxlZnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCIxMCAxNCA2IDEwIDEwIDZcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiMTQgMTQgMTAgMTAgMTQgNlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNoZXZyb24tZG91YmxlLXJpZ2h0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiMTAgNiAxNCAxMCAxMCAxNFxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCI2IDYgMTAgMTAgNiAxNFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNoZXZyb24tZG93blwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjE2IDcgMTAgMTMgNCA3XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1sZWZ0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiMTMgMTYgNyAxMCAxMyA0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1yaWdodFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjcgNCAxMyAxMCA3IDE2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi11cFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjQgMTMgMTAgNyAxNiAxM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNsb2NrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiN1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMy4wMTgsMTQuMTk3IEw5LjQ0NSwxMC42MjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjbG9zZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDZcXFwiIGQ9XFxcIk0xNiwxNiBMNCw0XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDZcXFwiIGQ9XFxcIk0xNiw0IEw0LDE2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2xvdWQtZG93bmxvYWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk02LjUsMTQuNjEgTDMuNzUsMTQuNjEgQzEuOTYsMTQuNjEgMC41LDEzLjE3IDAuNSwxMS4zOSBDMC41LDkuNzYgMS43Miw4LjQxIDMuMyw4LjIgQzMuMzgsNS4zMSA1Ljc1LDMgOC42OCwzIEMxMS4xOSwzIDEzLjMxLDQuNzEgMTMuODksNy4wMiBDMTQuMzksNi44IDE0LjkzLDYuNjggMTUuNSw2LjY4IEMxNy43MSw2LjY4IDE5LjUsOC40NSAxOS41LDEwLjY0IEMxOS41LDEyLjgzIDE3LjcxLDE0LjYgMTUuNSwxNC42IEwxMi41LDE0LjZcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjExLjc1IDE2IDkuNSAxOC4yNSA3LjI1IDE2XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNOS41LDE4IEw5LjUsOS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2xvdWQtdXBsb2FkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNNi41LDE0LjYxIEwzLjc1LDE0LjYxIEMxLjk2LDE0LjYxIDAuNSwxMy4xNyAwLjUsMTEuMzkgQzAuNSw5Ljc2IDEuNzIsOC40MSAzLjMxLDguMiBDMy4zOCw1LjMxIDUuNzUsMyA4LjY4LDMgQzExLjE5LDMgMTMuMzEsNC43MSAxMy44OSw3LjAyIEMxNC4zOSw2LjggMTQuOTMsNi42OCAxNS41LDYuNjggQzE3LjcxLDYuNjggMTkuNSw4LjQ1IDE5LjUsMTAuNjQgQzE5LjUsMTIuODMgMTcuNzEsMTQuNiAxNS41LDE0LjYgTDEyLjUsMTQuNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNy4yNSAxMS43NSA5LjUgOS41IDExLjc1IDExLjc1XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNOS41LDE4IEw5LjUsOS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY29kZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAxXFxcIiBwb2ludHM9XFxcIjEzLDQgMTksMTAgMTMsMTZcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIHBvaW50cz1cXFwiNyw0IDEsMTAgNywxNlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCI5Ljk5N1xcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIzLjMxXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTguNDg4LDEyLjI4NSBMMTYuMjA1LDE2LjIzNyBDMTUuMzIyLDE1LjQ5NiAxNC4xODUsMTUuMjgxIDEzLjMwMywxNS43OTEgQzEyLjQyOCwxNi4yODkgMTIuMDQ3LDE3LjM3MyAxMi4yNDYsMTguNSBMNy43MzUsMTguNSBDNy45MzgsMTcuMzc0IDcuNTUzLDE2LjI5OSA2LjY4NCwxNS43OTEgQzUuODAxLDE1LjI3IDQuNjU1LDE1LjQ5MiAzLjc3MywxNi4yMzcgTDEuNSwxMi4yODUgQzIuNTczLDExLjg3MSAzLjMxNywxMC45OTkgMy4zMTcsOS45OTEgQzMuMzA1LDguOTggMi41NzMsOC4xMjEgMS41LDcuNzE2IEwzLjc2NSwzLjc4NCBDNC42NDUsNC41MTYgNS43OTQsNC43MzggNi42ODcsNC4yMzIgQzcuNTU1LDMuNzIyIDcuOTM5LDIuNjM3IDcuNzM1LDEuNSBMMTIuMjYzLDEuNSBDMTIuMDcyLDIuNjM3IDEyLjQ0MSwzLjcxIDEzLjMxNCw0LjIyIEMxNC4yMDYsNC43MyAxNS4zNDMsNC41MTYgMTYuMjI1LDMuNzk0IEwxOC40ODcsNy43MTQgQzE3LjQwNCw4LjExNyAxNi42NjEsOC45ODggMTYuNjcsMTAuMDA5IEMxNi42NzIsMTEuMDE4IDE3LjQxNSwxMS44OCAxOC40ODgsMTIuMjg1IEwxOC40ODgsMTIuMjg1IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjb21tZW50XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNiwxOC43MSBMNiwxNCBMMSwxNCBMMSwxIEwxOSwxIEwxOSwxNCBMMTAuNzEsMTQgTDYsMTguNzEgTDYsMTguNzEgWiBNMiwxMyBMNywxMyBMNywxNi4yOSBMMTAuMjksMTMgTDE4LDEzIEwxOCwyIEwyLDIgTDIsMTMgTDIsMTMgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvbW1lbnRpbmdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxLjUsMS41IDE4LjUsMS41IDE4LjUsMTMuNSAxMC41LDEzLjUgNi41LDE3LjUgNi41LDEzLjUgMS41LDEzLjVcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjhcXFwiIHI9XFxcIjFcXFwiLz48Y2lyY2xlIGN4PVxcXCI2XFxcIiBjeT1cXFwiOFxcXCIgcj1cXFwiMVxcXCIvPjxjaXJjbGUgY3g9XFxcIjE0XFxcIiBjeT1cXFwiOFxcXCIgcj1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvbW1lbnRzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjIgMC41IDE5LjUgMC41IDE5LjUgMTNcXFwiLz48cGF0aCBkPVxcXCJNNSwxOS43MSBMNSwxNSBMMCwxNSBMMCwyIEwxOCwyIEwxOCwxNSBMOS43MSwxNSBMNSwxOS43MSBMNSwxOS43MSBMNSwxOS43MSBaIE0xLDE0IEw2LDE0IEw2LDE3LjI5IEw5LjI5LDE0IEwxNywxNCBMMTcsMyBMMSwzIEwxLDE0IEwxLDE0IEwxLDE0IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjb3B5XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMi41XFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMTZcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjUgMC41IDE3LjUgMC41IDE3LjUgMTdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjcmVkaXQtY2FyZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxLjVcXFwiIHk9XFxcIjQuNVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiN1xcXCIgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjcm9zc2hhaXJzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjcuNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjEwXFxcIiB4Mj1cXFwiMTBcXFwiIHkyPVxcXCI4XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiMTBcXFwiIHkxPVxcXCIxMlxcXCIgeDI9XFxcIjEwXFxcIiB5Mj1cXFwiMjBcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHkxPVxcXCIxMFxcXCIgeDI9XFxcIjhcXFwiIHkyPVxcXCIxMFxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjEyXFxcIiB5MT1cXFwiMTBcXFwiIHgyPVxcXCIyMFxcXCIgeTI9XFxcIjEwXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZGF0YWJhc2VcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxlbGxpcHNlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiNC42NFxcXCIgcng9XFxcIjcuNVxcXCIgcnk9XFxcIjMuMTRcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNy41LDguMTEgQzE3LjUsOS44NSAxNC4xNCwxMS4yNSAxMCwxMS4yNSBDNS44NiwxMS4yNSAyLjUsOS44NCAyLjUsOC4xMVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE3LjUsMTEuMjUgQzE3LjUsMTIuOTkgMTQuMTQsMTQuMzkgMTAsMTQuMzkgQzUuODYsMTQuMzkgMi41LDEyLjk4IDIuNSwxMS4yNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE3LjQ5LDQuNjQgTDE3LjUsMTQuMzYgQzE3LjUsMTYuMSAxNC4xNCwxNy41IDEwLDE3LjUgQzUuODYsMTcuNSAyLjUsMTYuMDkgMi41LDE0LjM2IEwyLjUsNC42NFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImRlc2t0b3BcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjhcXFwiIHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiMTFcXFwiIHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiNVxcXCIgeT1cXFwiMTZcXFwiIHdpZHRoPVxcXCIxMFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxLjVcXFwiIHk9XFxcIjMuNVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjExXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZGlzY29yZFwiOiBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCI+PHBhdGggZD1cXFwiTTE2LjA3NCw0LjM2MWExNC4yNDMsMTQuMjQzLDAsMCwwLTMuNjEtMS4xMzQsMTAuNjEsMTAuNjEsMCwwLDAtLjQ2My45NiwxMy4yMTksMTMuMjE5LDAsMCwwLTQsMCwxMC4xMzgsMTAuMTM4LDAsMCwwLS40NjgtLjk2QTE0LjIwNiwxNC4yMDYsMCwwLDAsMy45MTksNC4zNjQsMTUuMTQ2LDE1LjE0NiwwLDAsMCwxLjMyNCwxNC41YTE0LjQzNSwxNC40MzUsMCwwLDAsNC40MjgsMi4yNjlBMTAuOTgyLDEwLjk4MiwwLDAsMCw2LjcsMTUuMjFhOS4yOTQsOS4yOTQsMCwwLDEtMS40OTQtLjcyN2MuMTI1LS4wOTMuMjQ4LS4xOS4zNjYtLjI4OWExMC4yMTIsMTAuMjEyLDAsMCwwLDguODU0LDBjLjExOS4xLjI0Mi4yLjM2Ni4yODlhOS4yNzQsOS4yNzQsMCwwLDEtMS41LjcyOCwxMC44LDEwLjgsMCwwLDAsLjk0OCwxLjU2MiwxNC40MTksMTQuNDE5LDAsMCwwLDQuNDMxLTIuMjdBMTUuMTI4LDE1LjEyOCwwLDAsMCwxNi4wNzQsNC4zNjFabS04Ljk4MSw4LjFhMS43LDEuNywwLDAsMS0xLjU3My0xLjc5QTEuNjg5LDEuNjg5LDAsMCwxLDcuMDkzLDguODgxYTEuNjc5LDEuNjc5LDAsMCwxLDEuNTczLDEuNzkxQTEuNjg3LDEuNjg3LDAsMCwxLDcuMDkzLDEyLjQ2MlptNS44MTQsMGExLjcsMS43LDAsMCwxLTEuNTczLTEuNzksMS42ODksMS42ODksMCwwLDEsMS41NzMtMS43OTEsMS42NzksMS42NzksMCwwLDEsMS41NzMsMS43OTFBMS42ODgsMS42ODgsMCwwLDEsMTIuOTA3LDEyLjQ2MlpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJkb3dubG9hZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxNCwxMCA5LjUsMTQuNSA1LDEwXFxcIi8+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiMTdcXFwiIHdpZHRoPVxcXCIxM1xcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiOS41XFxcIiB5MT1cXFwiMTMuOTFcXFwiIHgyPVxcXCI5LjVcXFwiIHkyPVxcXCIzXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZHJpYmJibGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIGQ9XFxcIk0xLjMsOC45YzAsMCw1LDAuMSw4LjYtMWMxLjQtMC40LDIuNi0wLjksNC0xLjkgYzEuNC0xLjEsMi41LTIuNSwyLjUtMi41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgZD1cXFwiTTMuOSwxNi42YzAsMCwxLjctMi44LDMuNS00LjIgYzEuOC0xLjMsNC0yLDUuNy0yLjJDMTYsMTAsMTksMTAuNiwxOSwxMC42XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgZD1cXFwiTTYuOSwxLjZjMCwwLDMuMyw0LjYsNC4yLDYuOCBjMC40LDAuOSwxLjMsMy4xLDEuOSw1LjJjMC42LDIsMC45LDQuNCwwLjksNC40XFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImV0c3lcIjogXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiPjxwYXRoIGQ9XFxcIk04LDQuMjZDOCw0LjA3LDgsNCw4LjMxLDRoNC40NmMuNzksMCwxLjIyLjY3LDEuNTMsMS45MWwuMjUsMWguNzZjLjE0LTIuODIuMjYtNCwuMjYtNFMxMy42NSwzLDEyLjUyLDNINi44MUwzLjc1LDIuOTJ2Ljg0bDEsLjJjLjczLjExLjkuMjcsMSwxLDAsMCwuMDYsMiwuMDYsNS4xN3MtLjA2LDUuMTQtLjA2LDUuMTRjMCwuNTktLjIzLjgxLTEsLjk0bC0xLC4ydi44NGwzLjA2LS4xaDUuMTFjMS4xNSwwLDMuODIuMSwzLjgyLjEsMC0uNy40NS0zLjg4LjUxLTQuMjJoLS43M2wtLjc2LDEuNjlhMi4yNSwyLjI1LDAsMCwxLTIuNDUsMS40N0g5LjRjLTEsMC0xLjQ0LS40LTEuNDQtMS4yNFYxMC40NHMyLjE2LDAsMi44Ni4wNmMuNTUsMCwuODUuMTksMS4wNiwxbC4yMywxSDEzTDEyLjksOS45NCwxMyw3LjQxaC0uODVsLS4yOCwxLjEzYy0uMTYuNzQtLjI4Ljg0LTEsMS0xLC4xLTIuODkuMDktMi44OS4wOVpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJleHBhbmRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMTMgMiAxOCAyIDE4IDcgMTcgNyAxNyAzIDEzIDNcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjIgMTMgMyAxMyAzIDE3IDcgMTcgNyAxOCAyIDE4XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTExLDkgTDE3LDNcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMywxNyBMOSwxMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZhY2Vib29rXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTEsMTBoMi42bDAuNC0zSDExVjUuM2MwLTAuOSwwLjItMS41LDEuNS0xLjVIMTRWMS4xYy0wLjMsMC0xLTAuMS0yLjEtMC4xQzkuNiwxLDgsMi40LDgsNXYySDUuNXYzSDh2OGgzVjEwelxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZpbGUtZWRpdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTguNjUsMS42OCBDMTguNDEsMS40NSAxOC4xMDksMS4zMyAxNy44MSwxLjMzIEMxNy40OTksMS4zMyAxNy4yMDksMS40NSAxNi45OCwxLjY4IEw4LjkyLDkuNzYgTDgsMTIuMzMgTDEwLjU1LDExLjQxIEwxOC42NTEsMy4zNCBDMTkuMTIsMi44NyAxOS4xMiwyLjE1IDE4LjY1LDEuNjggTDE4LjY1LDEuNjggTDE4LjY1LDEuNjggWlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTYuNSA4LjQ4MiAxNi41IDE4LjUgMy41IDE4LjUgMy41IDEuNSAxNC4yMTEgMS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZmlsZS1wZGZcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjE3XFxcIiB4PVxcXCIzLjVcXFwiIHk9XFxcIjEuNVxcXCIvPjxwYXRoIGQ9XFxcIk0xNC42NSAxMS42N2MtLjQ4LjMtMS4zNy0uMTktMS43OS0uMzdhNC42NSA0LjY1IDAgMCAxIDEuNDkuMDZjLjM1LjEuMzYuMjguMy4zMXptLTYuMy4wNmwuNDMtLjc5YTE0LjcgMTQuNyAwIDAgMCAuNzUtMS42NCA1LjQ4IDUuNDggMCAwIDAgMS4yNSAxLjU1bC4yLjE1YTE2LjM2IDE2LjM2IDAgMCAwLTIuNjMuNzN6TTkuNSA1LjMyYy4yIDAgLjMyLjUuMzIuOTdhMS45OSAxLjk5IDAgMCAxLS4yMyAxLjA0IDUuMDUgNS4wNSAwIDAgMS0uMTctMS4zczAtLjcxLjA4LS43MXptLTMuOSA5YTQuMzUgNC4zNSAwIDAgMSAxLjIxLTEuNDZsLjI0LS4yMmE0LjM1IDQuMzUgMCAwIDEtMS40NiAxLjY4em05LjIzLTMuM2EyLjA1IDIuMDUgMCAwIDAtMS4zMi0uMyAxMS4wNyAxMS4wNyAwIDAgMC0xLjU4LjExIDQuMDkgNC4wOSAwIDAgMS0uNzQtLjUgNS4zOSA1LjM5IDAgMCAxLTEuMzItMi4wNiAxMC4zNyAxMC4zNyAwIDAgMCAuMjgtMi42MiAxLjgzIDEuODMgMCAwIDAtLjA3LS4yNS41Ny41NyAwIDAgMC0uNTItLjRIOS40YS41OS41OSAwIDAgMC0uNi4zOCA2Ljk1IDYuOTUgMCAwIDAgLjM3IDMuMTRjLS4yNi42My0xIDIuMTItMSAyLjEyLS4zLjU4LS41NyAxLjA4LS44MiAxLjVsLS44LjQ0QTMuMTEgMy4xMSAwIDAgMCA1IDE0LjE2YS4zOS4zOSAwIDAgMCAuMTUuNDJsLjI0LjEzYzEuMTUuNTYgMi4yOC0xLjc0IDIuNjYtMi40MmEyMy4xIDIzLjEgMCAwIDEgMy41OS0uODUgNC41NiA0LjU2IDAgMCAwIDIuOTEuOC41LjUgMCAwIDAgLjMtLjIxIDEuMSAxLjEgMCAwIDAgLjEyLS43NS44NC44NCAwIDAgMC0uMTQtLjI1elxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZpbGUtdGV4dFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMTdcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMS41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNlxcXCIgeDI9XFxcIjEyXFxcIiB5MT1cXFwiMTIuNVxcXCIgeTI9XFxcIjEyLjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI2XFxcIiB4Mj1cXFwiMTRcXFwiIHkxPVxcXCI4LjVcXFwiIHkyPVxcXCI4LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI2XFxcIiB4Mj1cXFwiMTRcXFwiIHkxPVxcXCI2LjVcXFwiIHkyPVxcXCI2LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI2XFxcIiB4Mj1cXFwiMTRcXFwiIHkxPVxcXCIxMC41XFxcIiB5Mj1cXFwiMTAuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZpbGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCIxLjVcXFwiIHdpZHRoPVxcXCIxM1xcXCIgaGVpZ2h0PVxcXCIxN1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZsaWNrclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiNS41XFxcIiBjeT1cXFwiOS41XFxcIiByPVxcXCIzLjVcXFwiLz48Y2lyY2xlIGN4PVxcXCIxNC41XFxcIiBjeT1cXFwiOS41XFxcIiByPVxcXCIzLjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmb2xkZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI5LjUgNS41IDguNSAzLjUgMS41IDMuNSAxLjUgMTYuNSAxOC41IDE2LjUgMTguNSA1LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmb3J3YXJkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMi40NywxMy4xMSBDNC4wMiwxMC4wMiA2LjI3LDcuODUgOS4wNCw2LjYxIEM5LjQ4LDYuNDEgMTAuMjcsNi4xMyAxMSw1LjkxIEwxMSwyIEwxOC44OSw5IEwxMSwxNiBMMTEsMTIuMTMgQzkuMjUsMTIuNDcgNy41OCwxMy4xOSA2LjAyLDE0LjI1IEMzLjAzLDE2LjI4IDEuNjMsMTguNTQgMS42MywxOC41NCBDMS42MywxOC41NCAxLjM4LDE1LjI4IDIuNDcsMTMuMTEgTDIuNDcsMTMuMTEgWiBNNS4zLDEzLjUzIEM2LjkyLDEyLjQgOS4wNCwxMS40IDEyLDEwLjkyIEwxMiwxMy42MyBMMTcuMzYsOSBMMTIsNC4yNSBMMTIsNi44IEMxMS43MSw2Ljg2IDEwLjg2LDcuMDIgOS42Nyw3LjQ5IEM2Ljc5LDguNjUgNC41OCwxMC45NiAzLjQ5LDEzLjA4IEMzLjE4LDEzLjcgMi42OCwxNC44NyAyLjQ5LDE2IEMzLjI4LDE1LjA1IDQuNCwxNC4xNSA1LjMsMTMuNTMgTDUuMywxMy41MyBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZm91cnNxdWFyZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE1LjIzLDIgQzE1Ljk2LDIgMTYuNCwyLjQxIDE2LjUsMi44NiBDMTYuNTcsMy4xNSAxNi41NiwzLjQ0IDE2LjUxLDMuNzMgQzE2LjQ2LDQuMDQgMTQuODYsMTEuNzIgMTQuNzUsMTIuMDMgQzE0LjU2LDEyLjU2IDE0LjE2LDEyLjgyIDEzLjYxLDEyLjgzIEMxMy4wMywxMi44NCAxMS4wOSwxMi41MSAxMC42OSwxMyBDMTAuMzgsMTMuMzggNy43OSwxNi4zOSA2LjgxLDE3LjUzIEM2LjYxLDE3Ljc2IDYuNCwxNy45NiA2LjA4LDE3Ljk5IEM1LjY4LDE4LjA0IDUuMjksMTcuODcgNS4xNywxNy40NSBDNS4xMiwxNy4yOCA1LjEsMTcuMDkgNS4xLDE2LjkxIEM1LjEsMTIuNCA0Ljg2LDcuODEgNS4xMSwzLjMxIEM1LjE3LDIuNSA1LjgxLDIuMTIgNi41MywyIEwxNS4yMywyIEwxNS4yMywyIFogTTkuNzYsMTEuNDIgQzkuOTQsMTEuMTkgMTAuMTcsMTEuMSAxMC40NSwxMS4xIEwxMi44NiwxMS4xIEMxMy4xMiwxMS4xIDEzLjMxLDEwLjk0IDEzLjM2LDEwLjY5IEMxMy4zNywxMC42NCAxMy42Miw5LjQxIDEzLjc0LDguODMgQzEzLjgxLDguNTIgMTMuNTMsOC4yOCAxMy4yNyw4LjI4IEMxMi4zNSw4LjI5IDExLjQyLDguMjggMTAuNSw4LjI4IEM5Ljg0LDguMjggOS44Myw3LjY5IDkuODIsNy4yMSBDOS44LDYuODUgMTAuMTMsNi41NSAxMC41LDYuNTUgQzExLjU5LDYuNTYgMTIuNjcsNi41NSAxMy43Niw2LjU1IEMxNC4wMyw2LjU1IDE0LjIzLDYuNCAxNC4yOCw2LjE0IEMxNC4zNCw1Ljg3IDE0LjY3LDQuMjkgMTQuNjcsNC4yOSBDMTQuNjcsNC4yOSAxNC44MiwzLjc0IDE0LjE5LDMuNzQgTDcuMzQsMy43NCBDNywzLjc1IDYuODQsNC4wMiA2Ljg0LDQuMzMgQzYuODQsNy41OCA2Ljg1LDE0Ljk1IDYuODUsMTQuOTkgQzYuODcsMTUgOC44OSwxMi41MSA5Ljc2LDExLjQyIEw5Ljc2LDExLjQyIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmdXR1cmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBwb2ludHM9XFxcIjE5IDIgMTggMiAxOCA2IDE0IDYgMTQgNyAxOSA3IDE5IDJcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTgsNi41NDggQzE2LjcwOSwzLjI5IDEzLjM1NCwxIDkuNiwxIEM0LjYsMSAwLjYsNSAwLjYsMTAgQzAuNiwxNSA0LjYsMTkgOS42LDE5IEMxNC42LDE5IDE4LjYsMTUgMTguNiwxMFxcXCIvPjxyZWN0IHg9XFxcIjlcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjdcXFwiLz48cGF0aCBkPVxcXCJNMTMuMDE4LDE0LjE5NyBMOS40NDUsMTAuNjI1XFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ2l0LWJyYW5jaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBjeD1cXFwiN1xcXCIgY3k9XFxcIjNcXFwiIHI9XFxcIjJcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGN4PVxcXCIxNFxcXCIgY3k9XFxcIjZcXFwiIHI9XFxcIjJcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGN4PVxcXCI3XFxcIiBjeT1cXFwiMTdcXFwiIHI9XFxcIjJcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMlxcXCIgZD1cXFwiTTE0LDggQzE0LDEwLjQxIDEyLjQzLDEwLjg3IDEwLjU2LDExLjI1IEM5LjA5LDExLjU0IDcsMTIuMDYgNywxNSBMNyw1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ2l0LWZvcmtcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjUuNzlcXFwiIGN5PVxcXCIyLjc5XFxcIiByPVxcXCIxLjc5XFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBjeD1cXFwiMTQuMTlcXFwiIGN5PVxcXCIyLjc5XFxcIiByPVxcXCIxLjc5XFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBjeD1cXFwiMTAuMDNcXFwiIGN5PVxcXCIxNi43OVxcXCIgcj1cXFwiMS43OVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBkPVxcXCJNNS43OSw0LjU3IEw1Ljc5LDYuNTYgQzUuNzksOS4xOSAxMC4wMywxMC4yMiAxMC4wMywxMy4zMSBDMTAuMDMsMTQuODYgMTAuMDQsMTQuNTUgMTAuMDQsMTQuNTUgQzEwLjA0LDE0LjM3IDEwLjA0LDE0Ljg2IDEwLjA0LDEzLjMxIEMxMC4wNCwxMC4yMiAxNC4yLDkuMTkgMTQuMiw2LjU2IEwxNC4yLDQuNTdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJnaXRodWItYWx0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAsMC41IEM0Ljc1LDAuNSAwLjUsNC43NiAwLjUsMTAuMDEgQzAuNSwxNS4yNiA0Ljc1LDE5LjUxIDEwLDE5LjUxIEMxNS4yNCwxOS41MSAxOS41LDE1LjI2IDE5LjUsMTAuMDEgQzE5LjUsNC43NiAxNS4yNSwwLjUgMTAsMC41IEwxMCwwLjUgWiBNMTIuODEsMTcuNjkgQzEyLjgxLDE3LjY5IDEyLjgxLDE3LjcgMTIuNzksMTcuNjkgQzEyLjQ3LDE3Ljc1IDEyLjM1LDE3LjU5IDEyLjM1LDE3LjM2IEwxMi4zNSwxNi4xNyBDMTIuMzUsMTUuNDUgMTIuMDksMTQuOTIgMTEuNTgsMTQuNTYgQzEyLjIsMTQuNTEgMTIuNzcsMTQuMzkgMTMuMjYsMTQuMjEgQzEzLjg3LDEzLjk4IDE0LjM2LDEzLjY5IDE0Ljc0LDEzLjI5IEMxNS40MiwxMi41OSAxNS43NiwxMS41NSAxNS43NiwxMC4xNyBDMTUuNzYsOS4yNSAxNS40NSw4LjQ2IDE0LjgzLDcuOCBDMTUuMSw3LjA4IDE1LjA3LDYuMjkgMTQuNzUsNS40NCBMMTQuNTEsNS40MiBDMTQuMzQsNS40IDE0LjA2LDUuNDYgMTMuNjcsNS42MSBDMTMuMjUsNS43OCAxMi43OSw2LjAzIDEyLjMxLDYuMzUgQzExLjU1LDYuMTYgMTAuODEsNi4wNSAxMC4wOSw2LjA1IEM5LjM2LDYuMDUgOC42MSw2LjE1IDcuODgsNi4zNSBDNy4yOCw1Ljk2IDYuNzUsNS42OCA2LjI2LDUuNTQgQzYuMDcsNS40NyA1LjksNS40NCA1Ljc4LDUuNDQgTDUuNDIsNS40NCBDNS4wNiw2LjI5IDUuMDQsNy4wOCA1LjMyLDcuOCBDNC43LDguNDYgNC40LDkuMjUgNC40LDEwLjE3IEM0LjQsMTEuOTQgNC45NiwxMy4xNiA2LjA4LDEzLjg0IEM2LjUzLDE0LjEzIDcuMDUsMTQuMzIgNy42OSwxNC40MyBDOC4wMywxNC41IDguMzIsMTQuNTQgOC41NSwxNC41NSBDOC4wNywxNC44OSA3LjgyLDE1LjQyIDcuODIsMTYuMTYgTDcuODIsMTcuNTEgQzcuOCwxNy42OSA3LjcsMTcuOCA3LjUxLDE3LjggQzQuMjEsMTYuNzQgMS44MiwxMy42NSAxLjgyLDEwLjAxIEMxLjgyLDUuNSA1LjQ5LDEuODMgMTAsMS44MyBDMTQuNSwxLjgzIDE4LjE3LDUuNSAxOC4xNywxMC4wMSBDMTguMTgsMTMuNTMgMTUuOTQsMTYuNTQgMTIuODEsMTcuNjkgTDEyLjgxLDE3LjY5IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJnaXRodWJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMCwxIEM1LjAzLDEgMSw1LjAzIDEsMTAgQzEsMTMuOTggMy41OCwxNy4zNSA3LjE2LDE4LjU0IEM3LjYxLDE4LjYyIDcuNzcsMTguMzQgNy43NywxOC4xMSBDNy43NywxNy45IDcuNzYsMTcuMzMgNy43NiwxNi41OCBDNS4yNiwxNy4xMiA0LjczLDE1LjM3IDQuNzMsMTUuMzcgQzQuMzIsMTQuMzMgMy43MywxNC4wNSAzLjczLDE0LjA1IEMyLjkxLDEzLjUgMy43OSwxMy41IDMuNzksMTMuNSBDNC42OSwxMy41NiA1LjE3LDE0LjQzIDUuMTcsMTQuNDMgQzUuOTcsMTUuOCA3LjI4LDE1LjQxIDcuNzksMTUuMTggQzcuODcsMTQuNiA4LjEsMTQuMiA4LjM2LDEzLjk4IEM2LjM2LDEzLjc1IDQuMjYsMTIuOTggNC4yNiw5LjUzIEM0LjI2LDguNTUgNC42MSw3Ljc0IDUuMTksNy4xMSBDNS4xLDYuODggNC43OSw1Ljk3IDUuMjgsNC43MyBDNS4yOCw0LjczIDYuMDQsNC40OSA3Ljc1LDUuNjUgQzguNDcsNS40NSA5LjI0LDUuMzUgMTAsNS4zNSBDMTAuNzYsNS4zNSAxMS41Myw1LjQ1IDEyLjI1LDUuNjUgQzEzLjk3LDQuNDggMTQuNzIsNC43MyAxNC43Miw0LjczIEMxNS4yMSw1Ljk3IDE0LjksNi44OCAxNC44MSw3LjExIEMxNS4zOSw3Ljc0IDE1LjczLDguNTQgMTUuNzMsOS41MyBDMTUuNzMsMTIuOTkgMTMuNjMsMTMuNzUgMTEuNjIsMTMuOTcgQzExLjk0LDE0LjI1IDEyLjIzLDE0LjggMTIuMjMsMTUuNjQgQzEyLjIzLDE2Ljg0IDEyLjIyLDE3LjgxIDEyLjIyLDE4LjExIEMxMi4yMiwxOC4zNSAxMi4zOCwxOC42MyAxMi44NCwxOC41NCBDMTYuNDIsMTcuMzUgMTksMTMuOTggMTksMTAgQzE5LDUuMDMgMTQuOTcsMSAxMCwxIEwxMCwxIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJnaXR0ZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjMuNVxcXCIgeT1cXFwiMVxcXCIgd2lkdGg9XFxcIjEuNTMxXFxcIiBoZWlnaHQ9XFxcIjExLjQ3MVxcXCIvPjxyZWN0IHg9XFxcIjcuMzI0XFxcIiB5PVxcXCI0LjA1OVxcXCIgd2lkdGg9XFxcIjEuNTI5XFxcIiBoZWlnaHQ9XFxcIjE1LjI5NFxcXCIvPjxyZWN0IHg9XFxcIjExLjE0OFxcXCIgeT1cXFwiNC4wNTlcXFwiIHdpZHRoPVxcXCIxLjUyN1xcXCIgaGVpZ2h0PVxcXCIxNS4yOTRcXFwiLz48cmVjdCB4PVxcXCIxNC45NzFcXFwiIHk9XFxcIjQuMDU5XFxcIiB3aWR0aD1cXFwiMS41MjlcXFwiIGhlaWdodD1cXFwiOC40MTJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJnb29nbGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNy44Niw5LjA5IEMxOC40NiwxMi4xMiAxNy4xNCwxNi4wNSAxMy44MSwxNy41NiBDOS40NSwxOS41MyA0LjEzLDE3LjY4IDIuNDcsMTIuODcgQzAuNjgsNy42OCA0LjIyLDIuNDIgOS41LDIuMDMgQzExLjU3LDEuODggMTMuNDIsMi4zNyAxNS4wNSwzLjY1IEMxNS4yMiwzLjc4IDE1LjM3LDMuOTMgMTUuNjEsNC4xNCBDMTQuOSw0LjgxIDE0LjIzLDUuNDUgMTMuNSw2LjE0IEMxMi4yNyw1LjA4IDEwLjg0LDQuNzIgOS4yOCw0Ljk4IEM4LjEyLDUuMTcgNy4xNiw1Ljc2IDYuMzcsNi42MyBDNC44OCw4LjI3IDQuNjIsMTAuODYgNS43NiwxMi44MiBDNi45NSwxNC44NyA5LjE3LDE1LjggMTEuNTcsMTUuMjUgQzEzLjI3LDE0Ljg3IDE0Ljc2LDEzLjMzIDE0Ljg5LDExLjc1IEwxMC41MSwxMS43NSBMMTAuNTEsOS4wOSBMMTcuODYsOS4wOSBMMTcuODYsOS4wOSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ3JpZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiMlxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjhcXFwiIHk9XFxcIjJcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCIxNFxcXCIgeT1cXFwiMlxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjhcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCI4XFxcIiB5PVxcXCI4XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiMTRcXFwiIHk9XFxcIjhcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjhcXFwiIHk9XFxcIjE0XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiMTRcXFwiIHk9XFxcIjE0XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaGFwcHlcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjEzXFxcIiBjeT1cXFwiN1xcXCIgcj1cXFwiMVxcXCIvPjxjaXJjbGUgY3g9XFxcIjdcXFwiIGN5PVxcXCI3XFxcIiByPVxcXCIxXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI4LjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNC42LDExLjQgQzEzLjksMTMuMyAxMi4xLDE0LjUgMTAsMTQuNSBDNy45LDE0LjUgNi4xLDEzLjMgNS40LDExLjRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJoYXNodGFnXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTUuNDMxLDggTDE1LjY2MSw3IEwxMi45MTEsNyBMMTMuODMxLDMgTDEyLjkwMSwzIEwxMS45OCw3IEw5LjI5LDcgTDEwLjIxLDMgTDkuMjgxLDMgTDguMzYxLDcgTDUuMjMsNyBMNSw4IEw4LjEzLDggTDcuMjEsMTIgTDQuMjMsMTIgTDQsMTMgTDYuOTgsMTMgTDYuMDYxLDE3IEw2Ljk5MSwxNyBMNy45MTEsMTMgTDEwLjYwMSwxMyBMOS42ODEsMTcgTDEwLjYxMSwxNyBMMTEuNTMxLDEzIEwxNC40MzEsMTMgTDE0LjY2MSwxMiBMMTEuNzYsMTIgTDEyLjY4MSw4IEwxNS40MzEsOCBaIE0xMC44MzEsMTIgTDguMTQxLDEyIEw5LjA2MSw4IEwxMS43NSw4IEwxMC44MzEsMTIgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImhlYXJ0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgZD1cXFwiTTEwLDQgQzEwLDQgOC4xLDIgNS43NCwyIEMzLjM4LDIgMSwzLjU1IDEsNi43MyBDMSw4Ljg0IDIuNjcsMTAuNDQgMi42NywxMC40NCBMMTAsMTggTDE3LjMzLDEwLjQ0IEMxNy4zMywxMC40NCAxOSw4Ljg0IDE5LDYuNzMgQzE5LDMuNTUgMTYuNjIsMiAxNC4yNiwyIEMxMS45LDIgMTAsNCAxMCw0IEwxMCw0IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJoaXN0b3J5XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxIDIgMiAyIDIgNiA2IDYgNiA3IDEgNyAxIDJcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMi4xLDYuNTQ4IEMzLjM5MSwzLjI5IDYuNzQ2LDEgMTAuNSwxIEMxNS41LDEgMTkuNSw1IDE5LjUsMTAgQzE5LjUsMTUgMTUuNSwxOSAxMC41LDE5IEM1LjUsMTkgMS41LDE1IDEuNSwxMFxcXCIvPjxyZWN0IHg9XFxcIjlcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjdcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTMuMDE4LDE0LjE5NyBMOS40NDUsMTAuNjI1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaG9tZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxOC42NSAxMS4zNSAxMCAyLjcxIDEuMzUgMTEuMzUgMC42NSAxMC42NSAxMCAxLjI5IDE5LjM1IDEwLjY1XFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCIxNSA0IDE4IDQgMTggNyAxNyA3IDE3IDUgMTUgNVxcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiMyAxMSA0IDExIDQgMTggNyAxOCA3IDEyIDEyIDEyIDEyIDE4IDE2IDE4IDE2IDExIDE3IDExIDE3IDE5IDExIDE5IDExIDEzIDggMTMgOCAxOSAzIDE5XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaW1hZ2VcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjE2LjFcXFwiIGN5PVxcXCI2LjFcXFwiIHI9XFxcIjEuMVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiLjVcXFwiIHk9XFxcIjIuNVxcXCIgd2lkdGg9XFxcIjE5XFxcIiBoZWlnaHQ9XFxcIjE1XFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAxXFxcIiBwb2ludHM9XFxcIjQsMTMgOCw5IDEzLDE0XFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAxXFxcIiBwb2ludHM9XFxcIjExLDEyIDEyLjUsMTAuNSAxNiwxNFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImluZm9cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMi4xMywxMS41OSBDMTEuOTcsMTIuODQgMTAuMzUsMTQuMTIgOS4xLDE0LjE2IEM2LjE3LDE0LjIgOS44OSw5LjQ2IDguNzQsOC4zNyBDOS4zLDguMTYgMTAuNjIsNy44MyAxMC42Miw4LjgxIEMxMC42Miw5LjYzIDEwLjEyLDEwLjU1IDkuODgsMTEuMzIgQzguNjYsMTUuMTYgMTIuMTMsMTEuMTUgMTIuMTQsMTEuMTggQzEyLjE2LDExLjIxIDEyLjE2LDExLjM1IDEyLjEzLDExLjU5IEMxMi4wOCwxMS45NSAxMi4xNiwxMS4zNSAxMi4xMywxMS41OSBMMTIuMTMsMTEuNTkgWiBNMTEuNTYsNS42NyBDMTEuNTYsNi42NyA5LjM2LDcuMTUgOS4zNiw2LjAzIEM5LjM2LDUgMTEuNTYsNC41NCAxMS41Niw1LjY3IEwxMS41Niw1LjY3IFpcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaW5zdGFncmFtXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTMuNTUsMUg2LjQ2QzMuNDUsMSwxLDMuNDQsMSw2LjQ0djcuMTJjMCwzLDIuNDUsNS40NCw1LjQ2LDUuNDRoNy4wOGMzLjAyLDAsNS40Ni0yLjQ0LDUuNDYtNS40NFY2LjQ0IEMxOS4wMSwzLjQ0LDE2LjU2LDEsMTMuNTUsMXogTTE3LjUsMTRjMCwxLjkzLTEuNTcsMy41LTMuNSwzLjVINmMtMS45MywwLTMuNS0xLjU3LTMuNS0zLjVWNmMwLTEuOTMsMS41Ny0zLjUsMy41LTMuNWg4IGMxLjkzLDAsMy41LDEuNTcsMy41LDMuNVYxNHpcXFwiLz48Y2lyY2xlIGN4PVxcXCIxNC44N1xcXCIgY3k9XFxcIjUuMjZcXFwiIHI9XFxcIjEuMDlcXFwiLz48cGF0aCBkPVxcXCJNMTAuMDMsNS40NWMtMi41NSwwLTQuNjMsMi4wNi00LjYzLDQuNmMwLDIuNTUsMi4wNyw0LjYxLDQuNjMsNC42MWMyLjU2LDAsNC42My0yLjA2MSw0LjYzLTQuNjEgQzE0LjY1LDcuNTEsMTIuNTgsNS40NSwxMC4wMyw1LjQ1TDEwLjAzLDUuNDVMMTAuMDMsNS40NXogTTEwLjA4LDEzYy0xLjY2LDAtMy0xLjM0LTMtMi45OWMwLTEuNjUsMS4zNC0yLjk5LDMtMi45OXMzLDEuMzQsMywyLjk5IEMxMy4wOCwxMS42NiwxMS43NCwxMywxMC4wOCwxM0wxMC4wOCwxM0wxMC4wOCwxM3pcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJpdGFsaWNcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMi42Myw1LjQ4IEwxMC4xNSwxNC41MiBDMTAsMTUuMDggMTAuMzcsMTUuMjUgMTEuOTIsMTUuMyBMMTEuNzIsMTYgTDYsMTYgTDYuMiwxNS4zMSBDNy43OCwxNS4yNiA4LjE5LDE1LjA5IDguMzQsMTQuNTMgTDEwLjgyLDUuNDkgQzEwLjk3LDQuOTIgMTAuNjMsNC43NiA5LjA5LDQuNzEgTDkuMjgsNCBMMTUsNCBMMTQuODEsNC42OSBDMTMuMjMsNC43NSAxMi43OCw0LjkxIDEyLjYzLDUuNDggTDEyLjYzLDUuNDggWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImpvb21sYVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTcuOCwxMy40bDEuNy0xLjdMNS45LDhjLTAuNi0wLjUtMC42LTEuNSwwLTJjMC42LTAuNiwxLjQtMC42LDIsMGwxLjctMS43Yy0xLTEtMi4zLTEuMy0zLjYtMUM1LjgsMi4yLDQuOCwxLjQsMy43LDEuNCBjLTEuMywwLTIuMywxLTIuMywyLjNjMCwxLjEsMC44LDIsMS44LDIuM2MtMC40LDEuMy0wLjEsMi44LDEsMy44TDcuOCwxMy40TDcuOCwxMy40elxcXCIvPjxwYXRoIGQ9XFxcIk0xMC4yLDQuM2MxLTEsMi41LTEuNCwzLjgtMWMwLjItMS4xLDEuMS0yLDIuMy0yYzEuMywwLDIuMywxLDIuMywyLjNjMCwxLjItMC45LDIuMi0yLDIuM2MwLjQsMS4zLDAsMi44LTEsMy44TDEzLjksOCBjMC42LTAuNSwwLjYtMS41LDAtMmMtMC41LTAuNi0xLjUtMC42LTIsMEw4LjIsOS43TDYuNSw4XFxcIi8+PHBhdGggZD1cXFwiTTE0LjEsMTYuOGMtMS4zLDAuNC0yLjgsMC4xLTMuOC0xbDEuNy0xLjdjMC42LDAuNiwxLjUsMC42LDIsMGMwLjUtMC42LDAuNi0xLjUsMC0ybC0zLjctMy43TDEyLDYuN2wzLjcsMy43IGMxLDEsMS4zLDIuNCwxLDMuNmMxLjEsMC4yLDIsMS4xLDIsMi4zYzAsMS4zLTEsMi4zLTIuMywyLjNDMTUuMiwxOC42LDE0LjMsMTcuOCwxNC4xLDE2LjhcXFwiLz48cGF0aCBkPVxcXCJNMTMuMiwxMi4ybC0zLjcsMy43Yy0xLDEtMi40LDEuMy0zLjYsMWMtMC4yLDEtMS4yLDEuOC0yLjIsMS44Yy0xLjMsMC0yLjMtMS0yLjMtMi4zYzAtMS4xLDAuOC0yLDEuOC0yLjMgYy0wLjMtMS4zLDAtMi43LDEtMy43bDEuNywxLjdjLTAuNiwwLjYtMC42LDEuNSwwLDJjMC42LDAuNiwxLjQsMC42LDIsMGwzLjctMy43XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibGFwdG9wXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB5PVxcXCIxNlxcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjIuNVxcXCIgeT1cXFwiNC41XFxcIiB3aWR0aD1cXFwiMTVcXFwiIGhlaWdodD1cXFwiMTBcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsaWZlc2F2ZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMCwwLjUgQzQuNzYsMC41IDAuNSw0Ljc2IDAuNSwxMCBDMC41LDE1LjI0IDQuNzYsMTkuNSAxMCwxOS41IEMxNS4yNCwxOS41IDE5LjUsMTUuMjQgMTkuNSwxMCBDMTkuNSw0Ljc2IDE1LjI0LDAuNSAxMCwwLjUgTDEwLDAuNSBaIE0xMCwxLjUgQzExLjQ5LDEuNSAxMi44OSwxLjg4IDE0LjExLDIuNTYgTDExLjg1LDQuODIgQzExLjI3LDQuNjEgMTAuNjUsNC41IDEwLDQuNSBDOS4yMSw0LjUgOC40Nyw0LjY3IDcuNzksNC45NiBMNS41OCwyLjc1IEM2Ljg3LDEuOTUgOC4zOCwxLjUgMTAsMS41IEwxMCwxLjUgWiBNNC45Niw3LjggQzQuNjcsOC40OCA0LjUsOS4yMSA0LjUsMTAgQzQuNSwxMC42NSA0LjYxLDExLjI3IDQuODMsMTEuODUgTDIuNTYsMTQuMTEgQzEuODgsMTIuODkgMS41LDExLjQ5IDEuNSwxMCBDMS41LDguMzggMS45NSw2Ljg3IDIuNzUsNS41OCBMNC45Niw3Ljc5IEw0Ljk2LDcuOCBMNC45Niw3LjggWiBNMTAsMTguNSBDOC4yNSwxOC41IDYuNjIsMTcuOTcgNS4yNywxNy4wNiBMNy40NiwxNC44NyBDOC4yMiwxNS4yNyA5LjA4LDE1LjUgMTAsMTUuNSBDMTAuNzksMTUuNSAxMS41MywxNS4zMyAxMi4yMSwxNS4wNCBMMTQuNDIsMTcuMjUgQzEzLjEzLDE4LjA1IDExLjYyLDE4LjUgMTAsMTguNSBMMTAsMTguNSBaIE0xMCwxNC41IEM3LjUyLDE0LjUgNS41LDEyLjQ4IDUuNSwxMCBDNS41LDcuNTIgNy41Miw1LjUgMTAsNS41IEMxMi40OCw1LjUgMTQuNSw3LjUyIDE0LjUsMTAgQzE0LjUsMTIuNDggMTIuNDgsMTQuNSAxMCwxNC41IEwxMCwxNC41IFogTTE1LjA0LDEyLjIxIEMxNS4zMywxMS41MyAxNS41LDEwLjc5IDE1LjUsMTAgQzE1LjUsOS4wOCAxNS4yNyw4LjIyIDE0Ljg3LDcuNDYgTDE3LjA2LDUuMjcgQzE3Ljk3LDYuNjIgMTguNSw4LjI1IDE4LjUsMTAgQzE4LjUsMTEuNjIgMTguMDUsMTMuMTMgMTcuMjUsMTQuNDIgTDE1LjA0LDEyLjIxIEwxNS4wNCwxMi4yMSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibGlua1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEwLjYyNSwxMi4zNzUgTDcuNTI1LDE1LjQ3NSBDNi44MjUsMTYuMTc1IDUuOTI1LDE2LjE3NSA1LjIyNSwxNS40NzUgTDQuNTI1LDE0Ljc3NSBDMy44MjUsMTQuMDc0IDMuODI1LDEzLjE3NSA0LjUyNSwxMi40NzUgTDcuNjI1LDkuMzc1XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTkuMzI1LDcuMzc1IEwxMi40MjUsNC4yNzUgQzEzLjEyNSwzLjU3NSAxNC4wMjUsMy41NzUgMTQuNzI0LDQuMjc1IEwxNS40MjUsNC45NzUgQzE2LjEyNSw1LjY3NSAxNi4xMjUsNi41NzUgMTUuNDI1LDcuMjc1IEwxMi4zMjUsMTAuMzc1XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTcuOTI1LDExLjg3NSBMMTEuOTI1LDcuOTc1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibGlua2VkaW5cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk01Ljc3LDE3Ljg5IEw1Ljc3LDcuMTcgTDIuMjEsNy4xNyBMMi4yMSwxNy44OSBMNS43NywxNy44OSBMNS43NywxNy44OSBaIE0zLjk5LDUuNzEgQzUuMjMsNS43MSA2LjAxLDQuODkgNi4wMSwzLjg2IEM1Ljk5LDIuOCA1LjI0LDIgNC4wMiwyIEMyLjgsMiAyLDIuOCAyLDMuODUgQzIsNC44OCAyLjc3LDUuNyAzLjk3LDUuNyBMMy45OSw1LjcgTDMuOTksNS43MSBMMy45OSw1LjcxIFpcXFwiLz48cGF0aCBkPVxcXCJNNy43NSwxNy44OSBMMTEuMzEsMTcuODkgTDExLjMxLDExLjkgQzExLjMxLDExLjU4IDExLjMzLDExLjI2IDExLjQzLDExLjAzIEMxMS42OSwxMC4zOSAxMi4yNyw5LjczIDEzLjI2LDkuNzMgQzE0LjU1LDkuNzMgMTUuMDYsMTAuNzEgMTUuMDYsMTIuMTUgTDE1LjA2LDE3Ljg5IEwxOC42MiwxNy44OSBMMTguNjIsMTEuNzQgQzE4LjYyLDguNDUgMTYuODYsNi45MiAxNC41Miw2LjkyIEMxMi42LDYuOTIgMTEuNzUsNy45OSAxMS4yOCw4LjczIEwxMS4zLDguNzMgTDExLjMsNy4xNyBMNy43NSw3LjE3IEM3Ljc5LDguMTcgNy43NSwxNy44OSA3Ljc1LDE3Ljg5IEw3Ljc1LDE3Ljg5IEw3Ljc1LDE3Ljg5IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsaXN0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCI2XFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjZcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIxMlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiNlxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIxMlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjJcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjJcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxvY2F0aW9uXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgZD1cXFwiTTEwLDAuNSBDNi40MSwwLjUgMy41LDMuMzkgMy41LDYuOTggQzMuNSwxMS44MyAxMCwxOSAxMCwxOSBDMTAsMTkgMTYuNSwxMS44MyAxNi41LDYuOTggQzE2LjUsMy4zOSAxMy41OSwwLjUgMTAsMC41IEwxMCwwLjUgWlxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCI2LjhcXFwiIHI9XFxcIjIuM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxvY2tcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgaGVpZ2h0PVxcXCIxMFxcXCIgd2lkdGg9XFxcIjEzXFxcIiB5PVxcXCI4LjVcXFwiIHg9XFxcIjMuNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTYuNSw4IEw2LjUsNC44OCBDNi41LDMuMDEgOC4wNywxLjUgMTAsMS41IEMxMS45MywxLjUgMTMuNSwzLjAxIDEzLjUsNC44OCBMMTMuNSw4XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibWFpbFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxLjQsNi41IDEwLDExIDE4LjYsNi41XFxcIi8+PHBhdGggZD1cXFwiTSAxLDQgMSwxNiAxOSwxNiAxOSw0IDEsNCBaIE0gMTgsMTUgMiwxNSAyLDUgMTgsNSAxOCwxNSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibWVudVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjE2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjE0XFxcIiB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1pY3JvcGhvbmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjEwXFxcIiB4Mj1cXFwiMTBcXFwiIHkxPVxcXCIxNi40NFxcXCIgeTI9XFxcIjE4LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI3XFxcIiB4Mj1cXFwiMTNcXFwiIHkxPVxcXCIxOC41XFxcIiB5Mj1cXFwiMTguNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMy41IDQuODl2NS44N2EzLjUgMy41IDAgMCAxLTcgMFY0Ljg5YTMuNSAzLjUgMCAwIDEgNyAwelxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xNS41IDEwLjM2VjExYTUuNSA1LjUgMCAwIDEtMTEgMHYtLjZcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtaW51cy1jaXJjbGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjkuNVxcXCIgY3k9XFxcIjkuNVxcXCIgcj1cXFwiOVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjVcXFwiIHkxPVxcXCI5LjVcXFwiIHgyPVxcXCIxNFxcXCIgeTI9XFxcIjkuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1pbnVzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBoZWlnaHQ9XFxcIjFcXFwiIHdpZHRoPVxcXCIxOFxcXCIgeT1cXFwiOVxcXCIgeD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1vcmUtdmVydGljYWxcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjEwXFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMlxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjJcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjE3XFxcIiByPVxcXCIyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibW9yZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiM1xcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiMlxcXCIvPjxjaXJjbGUgY3g9XFxcIjE3XFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtb3ZlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjQsNSAxLDUgMSw5IDIsOSAyLDYgNCw2XFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCIxLDE2IDIsMTYgMiwxOCA0LDE4IDQsMTkgMSwxOVxcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiMTQsMTYgMTQsMTkgMTEsMTkgMTEsMTggMTMsMTggMTMsMTZcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjUuNVxcXCIgeT1cXFwiMS41XFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMTNcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCIxMVxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjZcXFwiIHk9XFxcIjE4XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibnV0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMi41LDUuNyAxMCwxLjMgMTcuNSw1LjcgMTcuNSwxNC4zIDEwLDE4LjcgMi41LDE0LjNcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjMuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBhZ2VraXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMywxIDE3LDEgMTcsMTYgMTAsMTYgMTAsMTMgMTQsMTMgMTQsNCA2LDQgNiwxNiAxMCwxNiAxMCwxOSAzLDE5XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGFpbnQtYnVja2V0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAuMjEsMSBMMCwxMS4yMSBMOC4xLDE5LjMxIEwxOC4zMSw5LjEgTDEwLjIxLDEgTDEwLjIxLDEgWiBNMTYuODksOS4xIEwxNSwxMSBMMS43LDExIEwxMC4yMSwyLjQyIEwxNi44OSw5LjEgWlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk02LjQyLDIuMzMgTDExLjcsNy42MVxcXCIvPjxwYXRoIGQ9XFxcIk0xOC40OSwxMiBDMTguNDksMTIgMjAsMTQuMDYgMjAsMTUuMzYgQzIwLDE2LjI4IDE5LjI0LDE3IDE4LjQ5LDE3IEwxOC40OSwxNyBDMTcuNzQsMTcgMTcsMTYuMjggMTcsMTUuMzYgQzE3LDE0LjA2IDE4LjQ5LDEyIDE4LjQ5LDEyIEwxOC40OSwxMiBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGVuY2lsXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNy4yNSw2LjAxIEw3LjEyLDE2LjEgTDMuODIsMTcuMiBMNS4wMiwxMy45IEwxNS4xMiwzLjg4IEMxNS43MSwzLjI5IDE2LjY2LDMuMjkgMTcuMjUsMy44OCBDMTcuODMsNC40NyAxNy44Myw1LjQyIDE3LjI1LDYuMDEgTDE3LjI1LDYuMDEgWlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE1Ljk4LDcuMjY4IEwxMy44NTEsNS4xNDhcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwaG9uZS1sYW5kc2NhcGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE3LDUuNSBDMTcuOCw1LjUgMTguNSw2LjIgMTguNSw3IEwxOC41LDE0IEMxOC41LDE0LjggMTcuOCwxNS41IDE3LDE1LjUgTDMsMTUuNSBDMi4yLDE1LjUgMS41LDE0LjggMS41LDE0IEwxLjUsNyBDMS41LDYuMiAyLjIsNS41IDMsNS41IEwxNyw1LjUgTDE3LDUuNSBMMTcsNS41IFpcXFwiLz48Y2lyY2xlIGN4PVxcXCIzLjhcXFwiIGN5PVxcXCIxMC41XFxcIiByPVxcXCIuOFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBob25lXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNS41LDE3IEMxNS41LDE3LjggMTQuOCwxOC41IDE0LDE4LjUgTDcsMTguNSBDNi4yLDE4LjUgNS41LDE3LjggNS41LDE3IEw1LjUsMyBDNS41LDIuMiA2LjIsMS41IDcsMS41IEwxNCwxLjUgQzE0LjgsMS41IDE1LjUsMi4yIDE1LjUsMyBMMTUuNSwxNyBMMTUuNSwxNyBMMTUuNSwxNyBaXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTAuNVxcXCIgY3k9XFxcIjE2LjVcXFwiIHI9XFxcIi44XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGludGVyZXN0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAuMjEsMSBDNS41LDEgMyw0LjE2IDMsNy42MSBDMyw5LjIxIDMuODUsMTEuMiA1LjIyLDExLjg0IEM1LjQzLDExLjk0IDUuNTQsMTEuODkgNS41OCwxMS42OSBDNS42MiwxMS41NCA1LjgsMTAuOCA1Ljg4LDEwLjQ1IEM1LjkxLDEwLjM0IDUuODksMTAuMjQgNS44LDEwLjE0IEM1LjM2LDkuNTkgNSw4LjU4IDUsNy42NSBDNSw1LjI0IDYuODIsMi45MSA5LjkzLDIuOTEgQzEyLjYxLDIuOTEgMTQuNDksNC43NCAxNC40OSw3LjM1IEMxNC40OSwxMC4zIDEzLDEyLjM1IDExLjA2LDEyLjM1IEM5Ljk5LDEyLjM1IDkuMTksMTEuNDcgOS40NCwxMC4zOCBDOS43NSw5LjA4IDEwLjM1LDcuNjggMTAuMzUsNi43NSBDMTAuMzUsNS45MSA5LjksNS4yMSA4Ljk3LDUuMjEgQzcuODcsNS4yMSA2Ljk5LDYuMzQgNi45OSw3Ljg2IEM2Ljk5LDguODMgNy4zMiw5LjQ4IDcuMzIsOS40OCBDNy4zMiw5LjQ4IDYuMjQsMTQuMDYgNi4wNCwxNC45MSBDNS43LDE2LjM1IDYuMDgsMTguNyA2LjEyLDE4LjkgQzYuMTQsMTkuMDEgNi4yNiwxOS4wNSA2LjMzLDE4Ljk1IEM2LjQ0LDE4LjgxIDcuNzQsMTYuODUgOC4xMSwxNS40NCBDOC4yNCwxNC45MyA4Ljc5LDEyLjg0IDguNzksMTIuODQgQzkuMTUsMTMuNTIgMTAuMTksMTQuMDkgMTEuMjksMTQuMDkgQzE0LjU4LDE0LjA5IDE2Ljk2LDExLjA2IDE2Ljk2LDcuMyBDMTYuOTQsMy43IDE0LDEgMTAuMjEsMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBsYXktY2lyY2xlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBwb2ludHM9XFxcIjguNSA3IDEzLjUgMTAgOC41IDEzXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBsYXlcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI2LjUsNSAxNC41LDEwIDYuNSwxNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBsdXMtY2lyY2xlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5LjVcXFwiIGN5PVxcXCI5LjVcXFwiIHI9XFxcIjlcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI5LjVcXFwiIHkxPVxcXCI1XFxcIiB4Mj1cXFwiOS41XFxcIiB5Mj1cXFwiMTRcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI1XFxcIiB5MT1cXFwiOS41XFxcIiB4Mj1cXFwiMTRcXFwiIHkyPVxcXCI5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwbHVzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCI5XFxcIiB5PVxcXCIxXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIxN1xcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIxN1xcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicHJpbnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNC41IDEzLjUgMS41IDEzLjUgMS41IDYuNSAxOC41IDYuNSAxOC41IDEzLjUgMTUuNSAxMy41XFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxNS41IDYuNSAxNS41IDIuNSA0LjUgMi41IDQuNSA2LjVcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHdpZHRoPVxcXCIxMVxcXCIgaGVpZ2h0PVxcXCI2XFxcIiB4PVxcXCI0LjVcXFwiIHk9XFxcIjExLjVcXFwiLz48cmVjdCB3aWR0aD1cXFwiOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIiB4PVxcXCI2XFxcIiB5PVxcXCIxM1xcXCIvPjxyZWN0IHdpZHRoPVxcXCI4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiIHg9XFxcIjZcXFwiIHk9XFxcIjE1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicHVsbFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCI2Ljg1LDggOS41LDEwLjYgMTIuMTUsOCAxMi44NSw4LjcgOS41LDEyIDYuMTUsOC43XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiOS41XFxcIiB5MT1cXFwiMTFcXFwiIHgyPVxcXCI5LjVcXFwiIHkyPVxcXCIyXFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI2LDUuNSAzLjUsNS41IDMuNSwxOC41IDE1LjUsMTguNSAxNS41LDUuNSAxMyw1LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwdXNoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEyLjE1LDQgOS41LDEuNCA2Ljg1LDQgNi4xNSwzLjMgOS41LDAgMTIuODUsMy4zXFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiOS41XFxcIiB5MT1cXFwiMTBcXFwiIHgyPVxcXCI5LjVcXFwiIHkyPVxcXCIxXFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI2IDUuNSAzLjUgNS41IDMuNSAxOC41IDE1LjUgMTguNSAxNS41IDUuNSAxMyA1LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJxdWVzdGlvblwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOVxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwLjQ0XFxcIiBjeT1cXFwiMTQuNDJcXFwiIHI9XFxcIjEuMDVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBkPVxcXCJNOC4xNyw3Ljc5IEM4LjE3LDQuNzUgMTIuNzIsNC43MyAxMi43Miw3LjcyIEMxMi43Miw4LjY3IDExLjgxLDkuMTUgMTEuMjMsOS43NSBDMTAuNzUsMTAuMjQgMTAuNTEsMTAuNzMgMTAuNDUsMTEuNCBDMTAuNDQsMTEuNTMgMTAuNDMsMTEuNjQgMTAuNDMsMTEuNzVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJxdW90ZS1yaWdodFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3LjI3LDcuNzkgQzE3LjI3LDkuNDUgMTYuOTcsMTAuNDMgMTUuOTksMTIuMDIgQzE0Ljk4LDEzLjY0IDEzLDE1LjIzIDExLjU2LDE1Ljk3IEwxMS4xLDE1LjA4IEMxMi4zNCwxNC4yIDEzLjE0LDEzLjUxIDE0LjAyLDExLjgyIEMxNC4yNywxMS4zNCAxNC40MSwxMC45MiAxNC40OSwxMC41NCBDMTQuMywxMC41OCAxNC4wOSwxMC42IDEzLjg4LDEwLjYgQzEyLjA2LDEwLjYgMTAuNTksOS4xMiAxMC41OSw3LjMgQzEwLjU5LDUuNDggMTIuMDYsNCAxMy44OCw0IEMxNS4zOSw0IDE2LjY3LDUuMDIgMTcuMDUsNi40MiBDMTcuMTksNi44MiAxNy4yNyw3LjI3IDE3LjI3LDcuNzkgTDE3LjI3LDcuNzkgWlxcXCIvPjxwYXRoIGQ9XFxcIk04LjY4LDcuNzkgQzguNjgsOS40NSA4LjM4LDEwLjQzIDcuNCwxMi4wMiBDNi4zOSwxMy42NCA0LjQxLDE1LjIzIDIuOTcsMTUuOTcgTDIuNTEsMTUuMDggQzMuNzUsMTQuMiA0LjU1LDEzLjUxIDUuNDMsMTEuODIgQzUuNjgsMTEuMzQgNS44MiwxMC45MiA1LjksMTAuNTQgQzUuNzEsMTAuNTggNS41LDEwLjYgNS4yOSwxMC42IEMzLjQ3LDEwLjYgMiw5LjEyIDIsNy4zIEMyLDUuNDggMy40Nyw0IDUuMjksNCBDNi44LDQgOC4wOCw1LjAyIDguNDYsNi40MiBDOC42LDYuODIgOC42OCw3LjI3IDguNjgsNy43OSBMOC42OCw3Ljc5IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJyZWNlaXZlclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIGQ9XFxcIk02LjE4OSwxMy42MTFDOC4xMzQsMTUuNTI1IDExLjA5NywxOC4yMzkgMTMuODY3LDE4LjI1N0MxNi40NywxOC4yNzUgMTguMiwxNi4yNDEgMTguMiwxNi4yNDFMMTQuNTA5LDEyLjU1MUwxMS41MzksMTMuNjM5TDYuMTg5LDguMjlMNy4zMTMsNS4zNTVMMy43NiwxLjhDMy43NiwxLjggMS43MzIsMy41MzcgMS43LDYuMDkyQzEuNjY3LDguODA5IDQuMzQ3LDExLjczOCA2LjE4OSwxMy42MTFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJyZWRkaXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xOSA5LjA1YTIuNTYgMi41NiAwIDAgMC0yLjU2LTIuNTYgMi41OSAyLjU5IDAgMCAwLTEuODguODIgMTAuNjMgMTAuNjMgMCAwIDAtNC4xNC0xdi0uMDhjLjU4LTEuNjIgMS41OC0zLjg5IDIuNy00LjEuMzgtLjA4Ljc3LjEyIDEuMTkuNTdhMS4xNSAxLjE1IDAgMCAwLS4wNi4zNyAxLjQ4IDEuNDggMCAxIDAgMS41MS0xLjQ1IDEuNDMgMS40MyAwIDAgMC0uNzYuMTlBMi4yOSAyLjI5IDAgMCAwIDEyLjkxIDFjLTIuMTEuNDMtMy4zOSA0LjM4LTMuNjMgNS4xOSAwIDAgMCAuMTEtLjA2LjExYTEwLjY1IDEwLjY1IDAgMCAwLTMuNzUgMUEyLjU2IDIuNTYgMCAwIDAgMSA5LjA1YTIuNDIgMi40MiAwIDAgMCAuNzIgMS43NkE1LjE4IDUuMTggMCAwIDAgMS4yNCAxM2MwIDMuNjYgMy45MiA2LjY0IDguNzMgNi42NHM4Ljc0LTMgOC43NC02LjY0YTUuMjMgNS4yMyAwIDAgMC0uNDYtMi4xM0EyLjU4IDIuNTggMCAwIDAgMTkgOS4wNXptLTE2Ljg4IDBhMS40NCAxLjQ0IDAgMCAxIDIuMjctMS4xOSA3LjY4IDcuNjggMCAwIDAtMi4wNyAxLjkxIDEuMzMgMS4zMyAwIDAgMS0uMi0uNzJ6TTEwIDE4LjRjLTQuMTcgMC03LjU1LTIuNC03LjU1LTUuNFM1LjgzIDcuNTMgMTAgNy41MyAxNy41IDEwIDE3LjUgMTNzLTMuMzggNS40LTcuNSA1LjR6bTcuNjktOC42MWE3LjYyIDcuNjIgMCAwIDAtMi4wOS0xLjkxIDEuNDEgMS40MSAwIDAgMSAuODQtLjI4IDEuNDcgMS40NyAwIDAgMSAxLjQ0IDEuNDUgMS4zNCAxLjM0IDAgMCAxLS4yMS43MnpcXFwiLz48cGF0aCBkPVxcXCJNNi42OSAxMi41OGExLjM5IDEuMzkgMCAxIDEgMS4zOS0xLjM5IDEuMzggMS4zOCAwIDAgMS0xLjM4IDEuMzl6XFxcIi8+PHBhdGggZD1cXFwiTTE0LjI2IDExLjJhMS4zOSAxLjM5IDAgMSAxLTEuMzktMS4zOSAxLjM5IDEuMzkgMCAwIDEgMS4zOSAxLjM5elxcXCIvPjxwYXRoIGQ9XFxcIk0xMy4wOSAxNC44OGEuNTQuNTQgMCAwIDEtLjA5Ljc3IDUuMyA1LjMgMCAwIDEtMy4yNiAxLjE5IDUuNjEgNS42MSAwIDAgMS0zLjQtMS4yMi41NS41NSAwIDEgMSAuNzMtLjgzIDQuMDkgNC4wOSAwIDAgMCA1LjI1IDAgLjU2LjU2IDAgMCAxIC43Ny4wOXpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJyZWZyZXNoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTcuMDgsMTEuMTUgQzE3LjA5LDExLjMxIDE3LjEsMTEuNDcgMTcuMSwxMS42NCBDMTcuMSwxNS41MyAxMy45NCwxOC42OSAxMC4wNSwxOC42OSBDNi4xNiwxOC42OCAzLDE1LjUzIDMsMTEuNjMgQzMsNy43NCA2LjE2LDQuNTggMTAuMDUsNC41OCBDMTAuOSw0LjU4IDExLjcxLDQuNzMgMTIuNDYsNVxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiOS45IDIgMTIuNzkgNC44OSA5Ljc5IDcuOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInJlcGx5XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTcuNywxMy4xMSBDMTYuMTIsMTAuMDIgMTMuODQsNy44NSAxMS4wMiw2LjYxIEMxMC41Nyw2LjQxIDkuNzUsNi4xMyA5LDUuOTEgTDksMiBMMSw5IEw5LDE2IEw5LDEyLjEzIEMxMC43OCwxMi40NyAxMi41LDEzLjE5IDE0LjA5LDE0LjI1IEMxNy4xMywxNi4yOCAxOC41NiwxOC41NCAxOC41NiwxOC41NCBDMTguNTYsMTguNTQgMTguODEsMTUuMjggMTcuNywxMy4xMSBMMTcuNywxMy4xMSBaIE0xNC44MiwxMy41MyBDMTMuMTcsMTIuNCAxMS4wMSwxMS40IDgsMTAuOTIgTDgsMTMuNjMgTDIuNTUsOSBMOCw0LjI1IEw4LDYuOCBDOC4zLDYuODYgOS4xNiw3LjAyIDEwLjM3LDcuNDkgQzEzLjMsOC42NSAxNS41NCwxMC45NiAxNi42NSwxMy4wOCBDMTYuOTcsMTMuNyAxNy40OCwxNC44NiAxNy42OCwxNiBDMTYuODcsMTUuMDUgMTUuNzMsMTQuMTUgMTQuODIsMTMuNTMgTDE0LjgyLDEzLjUzIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJyc3NcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjMuMTJcXFwiIGN5PVxcXCIxNi44XFxcIiByPVxcXCIxLjg1XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEuNSw4LjIgQzEuNzgsOC4xOCAyLjA2LDguMTYgMi4zNSw4LjE2IEM3LjU3LDguMTYgMTEuODEsMTIuMzcgMTEuODEsMTcuNTcgQzExLjgxLDE3Ljg5IDExLjc5LDE4LjE5IDExLjc2LDE4LjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMS41LDIuNTIgQzEuNzgsMi41MSAyLjA2LDIuNSAyLjM1LDIuNSBDMTAuNzIsMi41IDE3LjUsOS4yNCAxNy41LDE3LjU3IEMxNy41LDE3Ljg5IDE3LjQ5LDE4LjE5IDE3LjQ3LDE4LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzZWFyY2hcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjlcXFwiIGN5PVxcXCI5XFxcIiByPVxcXCI3XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE0LDE0IEwxOCwxOCBMMTQsMTQgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNlcnZlclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjVcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCI3XFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiMTZcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxNlxcXCIgeT1cXFwiMTBcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjkuOVxcXCIgY3k9XFxcIjE3LjRcXFwiIHI9XFxcIjEuNFxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiNVxcXCIgeT1cXFwiMTBcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCI5LjVcXFwiIHk9XFxcIjE0XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiMTdcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxMVxcXCIgeT1cXFwiMTdcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjEuNVxcXCIgeT1cXFwiMS41XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMS41XFxcIiB5PVxcXCI4LjVcXFwiIHdpZHRoPVxcXCIxN1xcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic2V0dGluZ3NcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxlbGxpcHNlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjYuMTFcXFwiIGN5PVxcXCIzLjU1XFxcIiByeD1cXFwiMi4xMVxcXCIgcnk9XFxcIjIuMTVcXFwiLz48ZWxsaXBzZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCI2LjExXFxcIiBjeT1cXFwiMTUuNTVcXFwiIHJ4PVxcXCIyLjExXFxcIiByeT1cXFwiMi4xNVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTMuMTVcXFwiIGN5PVxcXCI5LjU1XFxcIiByPVxcXCIyLjE1XFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjEwXFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjhcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjE1XFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiMTVcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxMFxcXCIgeT1cXFwiMTVcXFwiIHdpZHRoPVxcXCI4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzaHJpbmtcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMTEgNCAxMiA0IDEyIDggMTYgOCAxNiA5IDExIDlcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjQgMTEgOSAxMSA5IDE2IDggMTYgOCAxMiA0IDEyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEyLDggTDE4LDJcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMiwxOCBMOCwxMlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNpZ24taW5cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiNyAyIDE3IDIgMTcgMTcgNyAxNyA3IDE2IDE2IDE2IDE2IDMgNyAzXFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCI5LjEgMTMuNCA4LjUgMTIuOCAxMS4yOCAxMCA0IDEwIDQgOSAxMS4yOCA5IDguNSA2LjIgOS4xIDUuNjIgMTMgOS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic2lnbi1vdXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMTMuMSAxMy40IDEyLjUgMTIuOCAxNS4yOCAxMCA4IDEwIDggOSAxNS4yOCA5IDEyLjUgNi4yIDEzLjEgNS42MiAxNyA5LjVcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjEzIDIgMyAyIDMgMTcgMTMgMTcgMTMgMTYgNCAxNiA0IDMgMTMgM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNvY2lhbFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjEzLjRcXFwiIHkxPVxcXCIxNFxcXCIgeDI9XFxcIjYuM1xcXCIgeTI9XFxcIjEwLjdcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMTMuNVxcXCIgeTE9XFxcIjUuNVxcXCIgeDI9XFxcIjYuNVxcXCIgeTI9XFxcIjguOFxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjE1LjVcXFwiIGN5PVxcXCI0LjZcXFwiIHI9XFxcIjIuM1xcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjE1LjVcXFwiIGN5PVxcXCIxNC44XFxcIiByPVxcXCIyLjNcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI0LjVcXFwiIGN5PVxcXCI5LjhcXFwiIHI9XFxcIjIuM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNvdW5kY2xvdWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNy4yLDkuNGMtMC40LDAtMC44LDAuMS0xLjEwMSwwLjJjLTAuMTk5LTIuNS0yLjM5OS00LjUtNS00LjVjLTAuNiwwLTEuMiwwLjEtMS43LDAuM0M5LjIsNS41LDkuMSw1LjYsOS4xLDUuNlYxNWg4IGMxLjYwMSwwLDIuODAxLTEuMiwyLjgwMS0yLjhDMjAsMTAuNywxOC43LDkuNCwxNy4yLDkuNEwxNy4yLDkuNHpcXFwiLz48cmVjdCB4PVxcXCI2XFxcIiB5PVxcXCI2LjVcXFwiIHdpZHRoPVxcXCIxLjVcXFwiIGhlaWdodD1cXFwiOC41XFxcIi8+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiOFxcXCIgd2lkdGg9XFxcIjEuNVxcXCIgaGVpZ2h0PVxcXCI3XFxcIi8+PHJlY3QgeT1cXFwiMTBcXFwiIHdpZHRoPVxcXCIxLjVcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInN0YXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAxXFxcIiBwb2ludHM9XFxcIjEwIDIgMTIuNjMgNy4yNyAxOC41IDguMTIgMTQuMjUgMTIuMjIgMTUuMjUgMTggMTAgMTUuMjcgNC43NSAxOCA1Ljc1IDEyLjIyIDEuNSA4LjEyIDcuMzcgNy4yN1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2hcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk02LDEzLjAyIEw2LjY1LDEzLjAyIEM3LjY0LDE1LjE2IDguODYsMTYuMTIgMTAuNDEsMTYuMTIgQzEyLjIyLDE2LjEyIDEyLjkyLDE0LjkzIDEyLjkyLDEzLjg5IEMxMi45MiwxMi41NSAxMS45OSwxMi4wMyA5Ljc0LDExLjIzIEM4LjA1LDEwLjY0IDYuMjMsMTAuMTEgNi4yMyw3LjgzIEM2LjIzLDUuNSA4LjA5LDQuMDkgMTAuNCw0LjA5IEMxMS40NCw0LjA5IDEyLjEzLDQuMzEgMTIuNzIsNC41NCBMMTMuMzMsNCBMMTMuODEsNCBMMTMuODEsNy41OSBMMTMuMTYsNy41OSBDMTIuNTUsNS44OCAxMS41Miw0Ljg5IDEwLjA3LDQuODkgQzguODQsNC44OSA3Ljg5LDUuNjkgNy44OSw3LjAzIEM3Ljg5LDguMjkgOC44OSw4Ljc4IDEwLjg4LDkuNDUgQzEyLjU3LDEwLjAzIDE0LjM4LDEwLjYgMTQuMzgsMTIuOTEgQzE0LjM4LDE0Ljc1IDEzLjI3LDE2LjkzIDEwLjE4LDE2LjkzIEM5LjE4LDE2LjkzIDguMTcsMTYuNjkgNy40NiwxNi4zOSBMNi41MiwxNyBMNiwxNyBMNiwxMy4wMiBMNiwxMy4wMiBaXFxcIi8+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiMTBcXFwiIHdpZHRoPVxcXCIxNVxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGFibGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiN1xcXCIgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCIxMVxcXCIgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0YWJsZXQtbGFuZHNjYXBlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xLjUsNSBDMS41LDQuMiAyLjIsMy41IDMsMy41IEwxNywzLjUgQzE3LjgsMy41IDE4LjUsNC4yIDE4LjUsNSBMMTguNSwxNiBDMTguNSwxNi44IDE3LjgsMTcuNSAxNywxNy41IEwzLDE3LjUgQzIuMiwxNy41IDEuNSwxNi44IDEuNSwxNiBMMS41LDUgTDEuNSw1IEwxLjUsNSBaXFxcIi8+PGNpcmNsZSBjeD1cXFwiMy43XFxcIiBjeT1cXFwiMTAuNVxcXCIgcj1cXFwiLjhcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0YWJsZXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTUsMTguNSBDNC4yLDE4LjUgMy41LDE3LjggMy41LDE3IEwzLjUsMyBDMy41LDIuMiA0LjIsMS41IDUsMS41IEwxNiwxLjUgQzE2LjgsMS41IDE3LjUsMi4yIDE3LjUsMyBMMTcuNSwxNyBDMTcuNSwxNy44IDE2LjgsMTguNSAxNiwxOC41IEw1LDE4LjUgTDUsMTguNSBMNSwxOC41IFpcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMC41XFxcIiBjeT1cXFwiMTYuM1xcXCIgcj1cXFwiLjhcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0YWdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xNy41LDMuNzEgTDE3LjUsNy43MiBDMTcuNSw3Ljk2IDE3LjQsOC4yIDE3LjIxLDguMzkgTDguMzksMTcuMiBDNy45OSwxNy42IDcuMzMsMTcuNiA2LjkzLDE3LjIgTDIuOCwxMy4wNyBDMi40LDEyLjY3IDIuNCwxMi4wMSAyLjgsMTEuNjEgTDExLjYxLDIuOCBDMTEuODEsMi42IDEyLjA4LDIuNSAxMi4zNCwyLjUgTDE2LjE5LDIuNSBDMTYuNTIsMi41IDE2Ljg2LDIuNjMgMTcuMTEsMi44OCBDMTcuMzUsMy4xMSAxNy40OCwzLjQgMTcuNSwzLjcxIEwxNy41LDMuNzEgWlxcXCIvPjxjaXJjbGUgY3g9XFxcIjE0XFxcIiBjeT1cXFwiNlxcXCIgcj1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRodW1ibmFpbHNcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCIzLjVcXFwiIHdpZHRoPVxcXCI1XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjExLjVcXFwiIHk9XFxcIjMuNVxcXCIgd2lkdGg9XFxcIjVcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMTEuNVxcXCIgeT1cXFwiMTEuNVxcXCIgd2lkdGg9XFxcIjVcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCIxMS41XFxcIiB3aWR0aD1cXFwiNVxcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGlrdG9rXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTcuMjQsNlY4LjgyYTYuNzksNi43OSwwLDAsMS00LTEuMjh2NS44MUE1LjI2LDUuMjYsMCwxLDEsOCw4LjFhNC4zNiw0LjM2LDAsMCwxLC43Mi4wNXYyLjlBMi41NywyLjU3LDAsMCwwLDcuNjQsMTFhMi40LDIuNCwwLDEsMCwyLjc3LDIuMzhWMmgyLjg2YTQsNCwwLDAsMCwxLjg0LDMuMzhBNCw0LDAsMCwwLDE3LjI0LDZaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHJhc2hcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNi41IDMgNi41IDEuNSAxMy41IDEuNSAxMy41IDNcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjQuNSA0IDQuNSAxOC41IDE1LjUgMTguNSAxNS41IDRcXFwiLz48cmVjdCB4PVxcXCI4XFxcIiB5PVxcXCI3XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI5XFxcIi8+PHJlY3QgeD1cXFwiMTFcXFwiIHk9XFxcIjdcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjlcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyaWFuZ2xlLWRvd25cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiNSA3IDE1IDcgMTAgMTJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0cmlhbmdsZS1sZWZ0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEyIDUgNyAxMCAxMiAxNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyaWFuZ2xlLXJpZ2h0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjggNSAxMyAxMCA4IDE1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHJpYW5nbGUtdXBcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiNSAxMyAxMCA4IDE1IDEzXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHJpcGFkdmlzb3JcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xOS4wMjEsNy44NjZDMTkuMjU2LDYuODYyLDIwLDUuODU0LDIwLDUuODU0aC0zLjM0NkMxNC43ODEsNC42NDEsMTIuNTA0LDQsOS45OCw0QzcuMzYzLDQsNC45OTksNC42NTEsMy4xMzUsNS44NzZIMFxcdGMwLDAsMC43MzgsMC45ODcsMC45NzYsMS45ODhjLTAuNjExLDAuODM3LTAuOTczLDEuODUyLTAuOTczLDIuOTY0YzAsMi43NjMsMi4yNDksNS4wMDksNS4wMTEsNS4wMDlcXHRjMS41NzYsMCwyLjk3Ni0wLjczNywzLjkwMS0xLjg3OWwxLjA2MywxLjU5OWwxLjA3NS0xLjYxNWMwLjQ3NSwwLjYxMSwxLjEsMS4xMTEsMS44MzgsMS40NTFjMS4yMTMsMC41NDcsMi41NzQsMC42MTIsMy44MjUsMC4xNVxcdGMyLjU4OS0wLjk2MywzLjkxMy0zLjg1MiwyLjk2NC02LjQzOWMtMC4xNzUtMC40NjMtMC40LTAuODc2LTAuNjc1LTEuMjM4SDE5LjAyMXogTTE2LjM4LDE0LjU5NFxcdGMtMS4wMDIsMC4zNzEtMi4wODgsMC4zMjgtMy4wNi0wLjExOWMtMC42ODgtMC4zMTctMS4yNTItMC44MTctMS42NTctMS40MzhjLTAuMTY0LTAuMjUtMC4zMTMtMC41Mi0wLjQxNy0wLjgxMVxcdGMtMC4xMjQtMC4zMjgtMC4xODYtMC42NjgtMC4yMTctMS4wMTRjLTAuMDYzLTAuNjg5LDAuMDM3LTEuMzk2LDAuMzM5LTIuMDQzYzAuNDQ4LTAuOTcxLDEuMjUxLTEuNzEsMi4yNS0yLjA3OVxcdGMyLjA3NS0wLjc2NSw0LjM3NSwwLjMsNS4xNCwyLjM2NmMwLjc2MiwyLjA2Ni0wLjMwMSw0LjM3LTIuMzYzLDUuMTM0TDE2LjM4LDE0LjU5NEwxNi4zOCwxNC41OTR6IE04LjMyMiwxMy4wNjZcXHRjLTAuNzIsMS4wNTktMS45MzUsMS43Ni0zLjMwOSwxLjc2Yy0yLjIwNywwLTQuMDAxLTEuNzk3LTQuMDAxLTMuOTk2YzAtMi4yMDMsMS43OTUtNC4wMDIsNC4wMDEtNC4wMDJcXHRjMi4yMDQsMCwzLjk5OSwxLjgsMy45OTksNC4wMDJjMCwwLjEzNy0wLjAyNCwwLjI2MS0wLjA0LDAuMzk2Yy0wLjA2NywwLjY3OC0wLjI4NCwxLjMxMy0wLjY0OCwxLjg1M3YtMC4wMTNIOC4zMjJ6IE0yLjQ3MiwxMC43NzVcXHRjMCwxLjM2NywxLjExMiwyLjQ3OSwyLjQ3NiwyLjQ3OWMxLjM2MywwLDIuNDcyLTEuMTEsMi40NzItMi40NzljMC0xLjM1OS0xLjExLTIuNDY4LTIuNDcyLTIuNDY4XFx0QzMuNTg0LDguMzA2LDIuNDczLDkuNDE2LDIuNDcyLDEwLjc3NUwyLjQ3MiwxMC43NzV6IE0xMi41MTQsMTAuNzc1YzAsMS4zNjcsMS4xMDQsMi40NzksMi40NzEsMi40NzlcXHRjMS4zNjMsMCwyLjQ3NC0xLjEwOCwyLjQ3NC0yLjQ3OWMwLTEuMzU5LTEuMTEtMi40NjgtMi40NzQtMi40NjhjLTEuMzY0LDAtMi40NzcsMS4xMDktMi40NzcsMi40NjhIMTIuNTE0eiBNMy4zMjQsMTAuNzc1XFx0YzAtMC44OTMsMC43MjYtMS42MTgsMS42MTQtMS42MThjMC44ODksMCwxLjYyNSwwLjcyNywxLjYyNSwxLjYxOGMwLDAuODk4LTAuNzI1LDEuNjI3LTEuNjI1LDEuNjI3XFx0Yy0wLjkwMSwwLTEuNjI1LTAuNzI5LTEuNjI1LTEuNjI3SDMuMzI0eiBNMTMuMzU0LDEwLjc3NWMwLTAuODkzLDAuNzI2LTEuNjE4LDEuNjI3LTEuNjE4YzAuODg2LDAsMS42MSwwLjcyNywxLjYxLDEuNjE4XFx0YzAsMC44OTgtMC43MjYsMS42MjctMS42MjYsMS42MjdzLTEuNjI1LTAuNzI5LTEuNjI1LTEuNjI3SDEzLjM1NHogTTkuOTc3LDQuODc1YzEuNzk4LDAsMy40MjUsMC4zMjQsNC44NDksMC45NjhcXHRjLTAuNTM1LDAuMDE1LTEuMDYxLDAuMTA4LTEuNTg2LDAuM2MtMS4yNjQsMC40NjMtMi4yNjQsMS4zODgtMi44MTUsMi42MDRjLTAuMjYyLDAuNTUxLTAuMzk4LDEuMTMzLTAuNDQ4LDEuNzJcXHRDOS43OSw3LjkwNSw3LjY3Nyw1Ljg3Myw1LjA3Niw1LjgyQzYuNTAxLDUuMjA4LDguMTUzLDQuODc1LDkuOTQsNC44NzVIOS45Nzd6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHVtYmxyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNi44ODUsOC41OThjMCwwLDAsMy4zOTMsMCw0Ljk5NmMwLDAuMjgyLDAsMC42NiwwLjA5NCwwLjk0MmMwLjM3NywxLjUwOSwxLjEzMSwyLjU0NSwyLjU0NSwzLjExIGMxLjMxOSwwLjQ3MiwyLjM1NiwwLjQ3MiwzLjY3NiwwYzAuNTY1LTAuMTg4LDEuMTMyLTAuNjU5LDEuMTMyLTAuNjU5bC0wLjg0OS0yLjI2M2MwLDAtMS4wMzYsMC4zNzgtMS42MDMsMC4yODMgYy0wLjU2NS0wLjA5NC0xLjIyNi0wLjY2LTEuMjI2LTEuNTA4YzAtMS42MDMsMC00LjkwMiwwLTQuOTAyaDIuODI4VjUuNzcxaC0yLjgyOFYySDguMjA1YzAsMC0wLjA5NCwwLjY2LTAuMTg4LDAuOTQyIEM3LjgyOCwzLjc5MSw3LjI2Miw0LjczMyw2LjYwMyw1LjM5NEM1Ljg0OCw2LjE0Nyw1LDYuNDMsNSw2LjQzdjIuMTY4SDYuODg1elxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInR2XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCI3XFxcIiB5PVxcXCIxNlxcXCIgd2lkdGg9XFxcIjZcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiLjVcXFwiIHk9XFxcIjMuNVxcXCIgd2lkdGg9XFxcIjE5XFxcIiBoZWlnaHQ9XFxcIjExXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHdpdGNoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNS4yMywxLDIsNC4yM1YxNS44NUg1Ljg4djMuMjNMOS4xLDE1Ljg1aDIuNTlMMTcuNSwxMFYxWm0xMSw4LjRMMTMuNjIsMTJIMTFMOC43OCwxNC4yNFYxMkg1Ljg4VjIuMjlIMTYuMjFaXFxcIi8+PHJlY3QgeD1cXFwiMTIuOThcXFwiIHk9XFxcIjQuNTVcXFwiIHdpZHRoPVxcXCIxLjI5XFxcIiBoZWlnaHQ9XFxcIjMuODhcXFwiLz48cmVjdCB4PVxcXCI5LjQzXFxcIiB5PVxcXCI0LjU1XFxcIiB3aWR0aD1cXFwiMS4yOVxcXCIgaGVpZ2h0PVxcXCIzLjg4XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHdpdHRlclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE5LDQuNzQgQzE4LjMzOSw1LjAyOSAxNy42MjYsNS4yMjkgMTYuODgxLDUuMzIgQzE3LjY0NCw0Ljg2IDE4LjIyNyw0LjEzOSAxOC41MDMsMy4yOCBDMTcuNzksMy43IDE3LjAwMSw0LjAwOSAxNi4xNTksNC4xNyBDMTUuNDg1LDMuNDUgMTQuNTI2LDMgMTMuNDY0LDMgQzExLjQyMywzIDkuNzcxLDQuNjYgOS43NzEsNi43IEM5Ljc3MSw2Ljk5IDkuODA0LDcuMjY5IDkuODY4LDcuNTM5IEM2Ljc5NSw3LjM4IDQuMDc2LDUuOTE5IDIuMjU0LDMuNjc5IEMxLjkzNiw0LjIxOSAxLjc1NCw0Ljg2IDEuNzU0LDUuNTM5IEMxLjc1NCw2LjgyIDIuNDA1LDcuOTUgMy4zOTcsOC42MSBDMi43OSw4LjU4OSAyLjIyLDguNDI5IDEuNzIzLDguMTQ5IEwxLjcyMyw4LjE4OSBDMS43MjMsOS45NzggMi45OTcsMTEuNDc4IDQuNjg2LDExLjgyIEM0LjM3NiwxMS44OTkgNC4wNDksMTEuOTM5IDMuNzEzLDExLjkzOSBDMy40NzUsMTEuOTM5IDMuMjQ1LDExLjkxOSAzLjAxOCwxMS44OCBDMy40OSwxMy4zNDkgNC44NTIsMTQuNDE5IDYuNDY5LDE0LjQ0OSBDNS4yMDUsMTUuNDI5IDMuNjEyLDE2LjAxOSAxLjg4MiwxNi4wMTkgQzEuNTgzLDE2LjAxOSAxLjI5LDE2LjAwOSAxLDE1Ljk2OSBDMi42MzUsMTcuMDE5IDQuNTc2LDE3LjYyOSA2LjY2MiwxNy42MjkgQzEzLjQ1NCwxNy42MjkgMTcuMTcsMTIgMTcuMTcsNy4xMjkgQzE3LjE3LDYuOTY5IDE3LjE2Niw2LjgwOSAxNy4xNTcsNi42NDkgQzE3Ljg3OSw2LjEyOSAxOC41MDQsNS40NzggMTksNC43NFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInVpa2l0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjE0LjQsMy4xIDExLjMsNS4xIDE1LDcuMyAxNSwxMi45IDEwLDE1LjcgNSwxMi45IDUsOC41IDIsNi44IDIsMTQuOCA5LjksMTkuNSAxOCwxNC44IDE4LDUuM1xcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiOS44LDQuMiA2LjcsMi40IDkuOCwwLjQgMTIuOSwyLjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ1bmxvY2tcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCI4LjVcXFwiIHdpZHRoPVxcXCIxM1xcXCIgaGVpZ2h0PVxcXCIxMFxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTYuNSw4LjUgTDYuNSw0LjkgQzYuNSwzIDguMSwxLjUgMTAsMS41IEMxMS45LDEuNSAxMy41LDMgMTMuNSw0LjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ1cGxvYWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNSA4IDkuNSAzLjUgMTQgOFxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjE3XFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjkuNVxcXCIgeTE9XFxcIjE1XFxcIiB4Mj1cXFwiOS41XFxcIiB5Mj1cXFwiNFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInVzZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjkuOVxcXCIgY3k9XFxcIjYuNFxcXCIgcj1cXFwiNC40XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEuNSwxOSBDMi4zLDE0LjUgNS44LDExLjIgMTAsMTEuMiBDMTQuMiwxMS4yIDE3LjcsMTQuNiAxOC41LDE5LjJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ1c2Vyc1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiNy43XFxcIiBjeT1cXFwiOC42XFxcIiByPVxcXCIzLjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMSwxOC4xIEMxLjcsMTQuNiA0LjQsMTIuMSA3LjYsMTIuMSBDMTAuOSwxMi4xIDEzLjcsMTQuOCAxNC4zLDE4LjNcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTEuNCw0IEMxMi44LDIuNCAxNS40LDIuOCAxNi4zLDQuNyBDMTcuMiw2LjYgMTUuNyw4LjkgMTMuNiw4LjkgQzE2LjUsOC45IDE4LjgsMTEuMyAxOS4yLDE0LjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ2aWRlby1jYW1lcmFcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxNy41IDYuOSAxNy41IDEzLjEgMTMuNSAxMC40IDEzLjUgMTQuNSAyLjUgMTQuNSAyLjUgNS41IDEzLjUgNS41IDEzLjUgOS42IDE3LjUgNi45XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidmltZW9cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0yLjA2NSw3LjU5QzEuODQsNy4zNjcsMS42NTQsNy4wODIsMS40NjgsNi44MzhjLTAuMzMyLTAuNDItMC4xMzctMC40MTEsMC4yNzQtMC43NzJjMS4wMjYtMC45MSwyLjAwNC0xLjg5NiwzLjEyNy0yLjY4OCBjMS4wMTctMC43MTMsMi4zNjUtMS4xNzMsMy4yODYtMC4wMzljMC44NDksMS4wNDUsMC44NjksMi42MjksMS4wODQsMy44OTFjMC4yMTUsMS4zMDksMC40MjEsMi42NDgsMC44OCwzLjkwMSBjMC4xMjcsMC4zNTIsMC4zNywxLjAxOCwwLjgxLDEuMDc0YzAuNTY3LDAuMDc4LDEuMTQ1LTAuOTE3LDEuNDA4LTEuMjg5YzAuNjg0LTAuOTg3LDEuNjExLTIuMzE3LDEuNDk0LTMuNTg3IGMtMC4xMTUtMS4zNDktMS41NzItMS4wOTUtMi40ODItMC43NzNjMC4xNDYtMS41MTQsMS41NTUtMy4yMTYsMi45MTItMy43OTJjMS40MzktMC41OTcsMy41NzktMC41ODcsNC4zMDIsMS4wMzYgYzAuNzcyLDEuNzU5LDAuMDc4LDMuODAyLTAuNzYzLDUuMzk2Yy0wLjkxOCwxLjczMS0yLjEsMy4zMzMtMy4zNjMsNC44MjljLTEuMTE0LDEuMzI5LTIuNDMyLDIuNzg3LTQuMDkzLDMuNDIyIGMtMS44OTcsMC43MjMtMy4wMjEtMC42ODYtMy42NjctMi4zMThjLTAuNzA1LTEuNzc3LTEuMDU2LTMuNzcxLTEuNTY1LTUuNjIxQzQuODk4LDguNzI2LDQuNjQ0LDcuODM2LDQuMTM2LDcuMTkxIEMzLjQ3Myw2LjM1OCwyLjcyLDcuMTQxLDIuMDY1LDcuNTlDMS45NzcsNy41MDIsMi4xMTUsNy41NTEsMi4wNjUsNy41OUwyLjA2NSw3LjU5elxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIndhcm5pbmdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTRcXFwiIHI9XFxcIjFcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PHBhdGggZD1cXFwiTTEwLjk3LDcuNzIgQzEwLjg1LDkuNTQgMTAuNTYsMTEuMjkgMTAuNTYsMTEuMjkgQzEwLjUxLDExLjg3IDEwLjI3LDEyIDkuOTksMTIgQzkuNjksMTIgOS40OSwxMS44NyA5LjQzLDExLjI5IEM5LjQzLDExLjI5IDkuMTYsOS41NCA5LjAzLDcuNzIgQzguOTYsNi41NCA5LjAzLDYgOS4wMyw2IEM5LjAzLDUuNDUgOS40Niw1LjAyIDkuOTksNSBDMTAuNTMsNS4wMSAxMC45Nyw1LjQ0IDEwLjk3LDYgQzEwLjk3LDYgMTEuMDQsNi41NCAxMC45Nyw3LjcyIEwxMC45Nyw3LjcyIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ3aGF0c2FwcFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE2LjcsMy4zYy0xLjgtMS44LTQuMS0yLjgtNi43LTIuOGMtNS4yLDAtOS40LDQuMi05LjQsOS40YzAsMS43LDAuNCwzLjMsMS4zLDQuN2wtMS4zLDQuOWw1LTEuM2MxLjQsMC44LDIuOSwxLjIsNC41LDEuMiBsMCwwbDAsMGM1LjIsMCw5LjQtNC4yLDkuNC05LjRDMTkuNSw3LjQsMTguNSw1LDE2LjcsMy4zIE0xMC4xLDE3LjdMMTAuMSwxNy43Yy0xLjQsMC0yLjgtMC40LTQtMS4xbC0wLjMtMC4ybC0zLDAuOGwwLjgtMi45IGwtMC4yLTAuM2MtMC44LTEuMi0xLjItMi43LTEuMi00LjJjMC00LjMsMy41LTcuOCw3LjgtNy44YzIuMSwwLDQuMSwwLjgsNS41LDIuM2MxLjUsMS41LDIuMywzLjQsMi4zLDUuNSBDMTcuOSwxNC4yLDE0LjQsMTcuNywxMC4xLDE3LjcgTTE0LjQsMTEuOWMtMC4yLTAuMS0xLjQtMC43LTEuNi0wLjhjLTAuMi0wLjEtMC40LTAuMS0wLjUsMC4xYy0wLjIsMC4yLTAuNiwwLjgtMC44LDAuOSBjLTAuMSwwLjItMC4zLDAuMi0wLjUsMC4xYy0wLjItMC4xLTEtMC40LTEuOS0xLjJjLTAuNy0wLjYtMS4yLTEuNC0xLjMtMS42Yy0wLjEtMC4yLDAtMC40LDAuMS0wLjVDOCw4LjgsOC4xLDguNyw4LjIsOC41IGMwLjEtMC4xLDAuMi0wLjIsMC4yLTAuNGMwLjEtMC4yLDAtMC4zLDAtMC40QzguNCw3LjYsNy45LDYuNSw3LjcsNkM3LjUsNS41LDcuMyw1LjYsNy4yLDUuNmMtMC4xLDAtMC4zLDAtMC40LDAgYy0wLjIsMC0wLjQsMC4xLTAuNiwwLjNjLTAuMiwwLjItMC44LDAuOC0wLjgsMmMwLDEuMiwwLjgsMi4zLDEsMi40YzAuMSwwLjIsMS43LDIuNSw0LDMuNWMwLjYsMC4yLDEsMC40LDEuMywwLjUgYzAuNiwwLjIsMS4xLDAuMiwxLjUsMC4xYzAuNS0wLjEsMS40LTAuNiwxLjYtMS4xYzAuMi0wLjUsMC4yLTEsMC4xLTEuMUMxNC44LDEyLjEsMTQuNiwxMiwxNC40LDExLjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ3b3JkcHJlc3NcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMCwwLjVjLTUuMiwwLTkuNSw0LjMtOS41LDkuNXM0LjMsOS41LDkuNSw5LjVjNS4yLDAsOS41LTQuMyw5LjUtOS41UzE1LjIsMC41LDEwLDAuNUwxMCwwLjVMMTAsMC41eiBNMTUuNiwzLjloLTAuMSBjLTAuOCwwLTEuNCwwLjctMS40LDEuNWMwLDAuNywwLjQsMS4zLDAuOCwxLjljMC4zLDAuNiwwLjcsMS4zLDAuNywyLjNjMCwwLjctMC4zLDEuNS0wLjYsMi43TDE0LjEsMTVsLTMtOC45IGMwLjUsMCwwLjktMC4xLDAuOS0wLjFDMTIuNSw2LDEyLjUsNS4zLDEyLDUuNGMwLDAtMS4zLDAuMS0yLjIsMC4xQzksNS41LDcuNyw1LjQsNy43LDUuNEM3LjIsNS4zLDcuMiw2LDcuNiw2YzAsMCwwLjQsMC4xLDAuOSwwLjEgbDEuMywzLjVMOCwxNUw1LDYuMUM1LjUsNi4xLDUuOSw2LDUuOSw2QzYuNCw2LDYuMyw1LjMsNS45LDUuNGMwLDAtMS4zLDAuMS0yLjIsMC4xYy0wLjIsMC0wLjMsMC0wLjUsMGMxLjUtMi4yLDQtMy43LDYuOS0zLjcgQzEyLjIsMS43LDE0LjEsMi42LDE1LjYsMy45TDE1LjYsMy45TDE1LjYsMy45eiBNMi41LDYuNmwzLjksMTAuOGMtMi43LTEuMy00LjYtNC4yLTQuNi03LjRDMS44LDguOCwyLDcuNiwyLjUsNi42TDIuNSw2LjZMMi41LDYuNiB6IE0xMC4yLDEwLjdsMi41LDYuOWMwLDAsMCwwLjEsMC4xLDAuMUMxMS45LDE4LDExLDE4LjIsMTAsMTguMmMtMC44LDAtMS42LTAuMS0yLjMtMC4zTDEwLjIsMTAuN0wxMC4yLDEwLjdMMTAuMiwxMC43eiBNMTQuMiwxNy4xIGwyLjUtNy4zYzAuNS0xLjIsMC42LTIuMSwwLjYtMi45YzAtMC4zLDAtMC42LTAuMS0wLjhjMC42LDEuMiwxLDIuNSwxLDRDMTguMywxMywxNi42LDE1LjcsMTQuMiwxNy4xTDE0LjIsMTcuMUwxNC4yLDE3LjF6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwid29ybGRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTEsMTAuNSBMMTksMTAuNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTIuMzUsMTUuNSBMMTcuNjUsMTUuNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTIuMzUsNS41IEwxNy41MjMsNS41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTAsMTkuNDYgTDkuOTgsMTkuNDYgQzcuMzEsMTcuMzMgNS42MSwxNC4xNDEgNS42MSwxMC41OCBDNS42MSw3LjAyIDcuMzMsMy44MyAxMCwxLjcgQzEwLjAxLDEuNyA5Ljk5LDEuNyAxMCwxLjcgTDEwLDEuNyBDMTIuNjcsMy44MyAxNC40LDcuMDIgMTQuNCwxMC41OCBDMTQuNCwxNC4xNDEgMTIuNjcsMTcuMzMgMTAsMTkuNDYgTDEwLDE5LjQ2IEwxMCwxOS40NiBMMTAsMTkuNDYgWlxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMC41XFxcIiByPVxcXCI5XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwieGluZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTQuNCw0LjU2IEM0LjI0LDQuNTYgNC4xMSw0LjYxIDQuMDUsNC43MiBDMy45OCw0LjgzIDMuOTksNC45NyA0LjA3LDUuMTIgTDUuODIsOC4xNiBMNS44Miw4LjE3IEwzLjA2LDEzLjA0IEMyLjk5LDEzLjE4IDIuOTksMTMuMzMgMy4wNiwxMy40NCBDMy4xMiwxMy41NSAzLjI0LDEzLjYyIDMuNCwxMy42MiBMNiwxMy42MiBDNi4zOSwxMy42MiA2LjU3LDEzLjM2IDYuNzEsMTMuMTIgQzYuNzEsMTMuMTIgOS40MSw4LjM1IDkuNTEsOC4xNiBDOS40OSw4LjE0IDcuNzIsNS4wNCA3LjcyLDUuMDQgQzcuNTgsNC44MSA3LjM5LDQuNTYgNi45OSw0LjU2IEw0LjQsNC41NiBMNC40LDQuNTYgWlxcXCIvPjxwYXRoIGQ9XFxcIk0xNS4zLDEgQzE0LjkxLDEgMTQuNzQsMS4yNSAxNC42LDEuNSBDMTQuNiwxLjUgOS4wMSwxMS40MiA4LjgyLDExLjc0IEM4LjgzLDExLjc2IDEyLjUxLDE4LjUxIDEyLjUxLDE4LjUxIEMxMi42NCwxOC43NCAxMi44NCwxOSAxMy4yMywxOSBMMTUuODIsMTkgQzE1Ljk4LDE5IDE2LjEsMTguOTQgMTYuMTYsMTguODMgQzE2LjIzLDE4LjcyIDE2LjIzLDE4LjU3IDE2LjE2LDE4LjQzIEwxMi41LDExLjc0IEwxMi41LDExLjcyIEwxOC4yNSwxLjU2IEMxOC4zMiwxLjQyIDE4LjMyLDEuMjcgMTguMjUsMS4xNiBDMTguMjEsMS4wNiAxOC4wOCwxIDE3LjkzLDEgTDE1LjMsMSBMMTUuMywxIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ5ZWxwXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTcuMTc1LDE0Ljk3MWMtMC4xMTIsMC43Ny0xLjY4NiwyLjc2Ny0yLjQwNiwzLjA1NGMtMC4yNDYsMC4xLTAuNDg3LDAuMDc2LTAuNjc1LTAuMDY5XFx0Yy0wLjEyMi0wLjA5Ni0yLjQ0Ni0zLjg1OS0yLjQ0Ni0zLjg1OWMtMC4xOTQtMC4yOTMtMC4xNTctMC42ODIsMC4wODMtMC45NzhjMC4yMzQtMC4yODQsMC41ODEtMC4zOTMsMC44ODEtMC4yNzZcXHRjMC4wMTYsMC4wMSw0LjIxLDEuMzk0LDQuMzMyLDEuNDgyYzAuMTc4LDAuMTQ4LDAuMjYzLDAuMzc5LDAuMjI1LDAuNjQ2TDE3LjE3NSwxNC45NzFMMTcuMTc1LDE0Ljk3MXogTTExLjQ2NCwxMC43ODlcXHRjLTAuMjAzLTAuMzA3LTAuMTk5LTAuNjY2LDAuMDA5LTAuOTE2YzAsMCwyLjYyNS0zLjU3NCwyLjc0NS0zLjY1N2MwLjIwMy0wLjEzNSwwLjQ1Mi0wLjE0MSwwLjY5LTAuMDI1XFx0YzAuNjkxLDAuMzM1LDIuMDg1LDIuNDA1LDIuMTY3LDMuMTk5djAuMDI3YzAuMDI0LDAuMjcxLTAuMDgyLDAuNDkxLTAuMjczLDAuNjIzYy0wLjEzMiwwLjA4My00LjQzLDEuMTU1LTQuNDMsMS4xNTVcXHRjLTAuMzIyLDAuMDk2LTAuNjgtMC4wNi0wLjg4Mi0wLjM4MUwxMS40NjQsMTAuNzg5eiBNOS40NzUsOS41NjNDOS4zMiw5LjYwOSw4Ljg0OCw5Ljc1Nyw4LjI2OSw4LjgxN2MwLDAtMy45MTYtNi4xNi00LjAwNy02LjM1MVxcdGMtMC4wNTctMC4yMTIsMC4wMTEtMC40NTUsMC4yMDItMC42NUM1LjA0NywxLjIxMSw4LjIxLDAuMzI3LDkuMDM3LDAuNTI5YzAuMjcsMC4wNjksMC40NTcsMC4yMzgsMC41MjIsMC40NzlcXHRjMC4wNDcsMC4yNjYsMC40MzMsNS45ODIsMC40ODgsNy4yNjRDMTAuMDk4LDkuMzY4LDkuNjI5LDkuNTE3LDkuNDc1LDkuNTYzeiBNOS45MjcsMTkuMDY2Yy0wLjA4MywwLjIyNS0wLjI3MywwLjM3My0wLjU0LDAuNDIxXFx0Yy0wLjc2MiwwLjEzLTMuMTUtMC43NTEtMy42NDctMS4zNDJjLTAuMDk2LTAuMTMxLTAuMTU1LTAuMjYyLTAuMTY3LTAuMzk0Yy0wLjAxMS0wLjA5NSwwLTAuMTg5LDAuMDM2LTAuMjcyXFx0YzAuMDYxLTAuMTU1LDIuOTE3LTMuNTM4LDIuOTE3LTMuNTM4YzAuMjE0LTAuMjcyLDAuNTk1LTAuMzU1LDAuOTUyLTAuMjEzYzAuMzQ1LDAuMTMsMC41NiwwLjQyOCwwLjUzNiwwLjc0OVxcdEMxMC4wMTQsMTQuNDc5LDkuOTc3LDE4LjkyMyw5LjkyNywxOS4wNjZ6IE0zLjQ5NSwxMy45MTJjLTAuMjM1LTAuMDA5LTAuNDQ0LTAuMTQ4LTAuNTY4LTAuMzgyYy0wLjA4OS0wLjE3LTAuMTUxLTAuNDUzLTAuMTktMC43OTRcXHRDMi42MywxMS43MDEsMi43NjEsMTAuMTQ0LDMuMDcsOS42NDhjMC4xNDUtMC4yMjYsMC4zNTctMC4zNDUsMC41OTItMC4zMzZjMC4xNTQsMCw0LjI1NSwxLjY2Nyw0LjI1NSwxLjY2N1xcdGMwLjMyMSwwLjExOCwwLjUyMSwwLjQ1MywwLjUsMC44MzNjLTAuMDIzLDAuMzctMC4yMzYsMC42NTUtMC41NTEsMC43MzhMMy40OTUsMTMuOTEyelxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInlvdXR1YmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNSw0LjFjMSwwLjEsMi4zLDAsMywwLjhjMC44LDAuOCwwLjksMi4xLDAuOSwzLjFDMTksOS4yLDE5LDEwLjksMTksMTJjLTAuMSwxLjEsMCwyLjQtMC41LDMuNGMtMC41LDEuMS0xLjQsMS41LTIuNSwxLjYgYy0xLjIsMC4xLTguNiwwLjEtMTEsMGMtMS4xLTAuMS0yLjQtMC4xLTMuMi0xYy0wLjctMC44LTAuNy0yLTAuOC0zQzEsMTEuOCwxLDEwLjEsMSw4LjljMC0xLjEsMC0yLjQsMC41LTMuNEMyLDQuNSwzLDQuMyw0LjEsNC4yIEM1LjMsNC4xLDEyLjYsNCwxNSw0LjF6IE04LDcuNXY2bDUuNS0zTDgsNy41elxcXCIvPjwvc3ZnPlwiXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlVJa2l0KSB7XG4gICAgICB3aW5kb3cuVUlraXQudXNlKHBsdWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uikit/dist/js/uikit-icons.js\n");

/***/ }),

/***/ "./node_modules/uikit/dist/js/uikit.js":
/*!*********************************************!*\
  !*** ./node_modules/uikit/dist/js/uikit.js ***!
  \*********************************************/
/***/ (function(module) {

eval("/*! UIkit 3.15.18 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    const { hasOwnProperty, toString } = Object.prototype;\n\n    function hasOwn(obj, key) {\n      return hasOwnProperty.call(obj, key);\n    }\n\n    const hyphenateRe = /\\B([A-Z])/g;\n\n    const hyphenate = memoize((str) => str.replace(hyphenateRe, '-$1').toLowerCase());\n\n    const camelizeRe = /-(\\w)/g;\n\n    const camelize = memoize((str) => str.replace(camelizeRe, toUpper));\n\n    const ucfirst = memoize((str) =>\n    str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '');\n\n\n    function toUpper(_, c) {\n      return c ? c.toUpperCase() : '';\n    }\n\n    function startsWith(str, search) {\n      return str == null ? void 0 : str.startsWith == null ? void 0 : str.startsWith(search);\n    }\n\n    function endsWith(str, search) {\n      return str == null ? void 0 : str.endsWith == null ? void 0 : str.endsWith(search);\n    }\n\n    function includes(obj, search) {\n      return obj == null ? void 0 : obj.includes == null ? void 0 : obj.includes(search);\n    }\n\n    function findIndex(array, predicate) {\n      return array == null ? void 0 : array.findIndex == null ? void 0 : array.findIndex(predicate);\n    }\n\n    const { isArray, from: toArray } = Array;\n    const { assign } = Object;\n\n    function isFunction(obj) {\n      return typeof obj === 'function';\n    }\n\n    function isObject(obj) {\n      return obj !== null && typeof obj === 'object';\n    }\n\n    function isPlainObject(obj) {\n      return toString.call(obj) === '[object Object]';\n    }\n\n    function isWindow(obj) {\n      return isObject(obj) && obj === obj.window;\n    }\n\n    function isDocument(obj) {\n      return nodeType(obj) === 9;\n    }\n\n    function isNode(obj) {\n      return nodeType(obj) >= 1;\n    }\n\n    function isElement(obj) {\n      return nodeType(obj) === 1;\n    }\n\n    function nodeType(obj) {\n      return !isWindow(obj) && isObject(obj) && obj.nodeType;\n    }\n\n    function isBoolean(value) {\n      return typeof value === 'boolean';\n    }\n\n    function isString(value) {\n      return typeof value === 'string';\n    }\n\n    function isNumber(value) {\n      return typeof value === 'number';\n    }\n\n    function isNumeric(value) {\n      return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));\n    }\n\n    function isEmpty(obj) {\n      return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);\n    }\n\n    function isUndefined(value) {\n      return value === void 0;\n    }\n\n    function toBoolean(value) {\n      return isBoolean(value) ?\n      value :\n      value === 'true' || value === '1' || value === '' ?\n      true :\n      value === 'false' || value === '0' ?\n      false :\n      value;\n    }\n\n    function toNumber(value) {\n      const number = Number(value);\n      return isNaN(number) ? false : number;\n    }\n\n    function toFloat(value) {\n      return parseFloat(value) || 0;\n    }\n\n    function toNode(element) {\n      return toNodes(element)[0];\n    }\n\n    function toNodes(element) {\n      return element && (isNode(element) ? [element] : Array.from(element).filter(isNode)) || [];\n    }\n\n    function toWindow(element) {var _element;\n      if (isWindow(element)) {\n        return element;\n      }\n\n      element = toNode(element);\n      const document = isDocument(element) ? element : (_element = element) == null ? void 0 : _element.ownerDocument;\n\n      return (document == null ? void 0 : document.defaultView) || window;\n    }\n\n    function isEqual(value, other) {\n      return (\n        value === other ||\n        isObject(value) &&\n        isObject(other) &&\n        Object.keys(value).length === Object.keys(other).length &&\n        each(value, (val, key) => val === other[key]));\n\n    }\n\n    function swap(value, a, b) {\n      return value.replace(new RegExp(`${a}|${b}`, 'g'), (match) => match === a ? b : a);\n    }\n\n    function last(array) {\n      return array[array.length - 1];\n    }\n\n    function each(obj, cb) {\n      for (const key in obj) {\n        if (false === cb(obj[key], key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function sortBy$1(array, prop) {\n      return array.\n      slice().\n      sort(({ [prop]: propA = 0 }, { [prop]: propB = 0 }) => propA > propB ? 1 : propB > propA ? -1 : 0);\n\n    }\n\n    function sumBy(array, iteratee) {\n      return array.reduce(\n      (sum, item) => sum + toFloat(isFunction(iteratee) ? iteratee(item) : item[iteratee]),\n      0);\n\n    }\n\n    function uniqueBy(array, prop) {\n      const seen = new Set();\n      return array.filter(({ [prop]: check }) => seen.has(check) ? false : seen.add(check));\n    }\n\n    function clamp(number, min = 0, max = 1) {\n      return Math.min(Math.max(toNumber(number) || 0, min), max);\n    }\n\n    function noop() {}\n\n    function intersectRect(...rects) {\n      return [\n      ['bottom', 'top'],\n      ['right', 'left']].\n      every(\n      ([minProp, maxProp]) => Math.min(...rects.map(({ [minProp]: min }) => min)) -\n      Math.max(...rects.map(({ [maxProp]: max }) => max)) > 0);\n\n    }\n\n    function pointInRect(point, rect) {\n      return (\n        point.x <= rect.right &&\n        point.x >= rect.left &&\n        point.y <= rect.bottom &&\n        point.y >= rect.top);\n\n    }\n\n    function ratio(dimensions, prop, value) {\n      const aProp = prop === 'width' ? 'height' : 'width';\n\n      return {\n        [aProp]: dimensions[prop] ?\n        Math.round(value * dimensions[aProp] / dimensions[prop]) :\n        dimensions[aProp],\n        [prop]: value\n      };\n    }\n\n    function contain(dimensions, maxDimensions) {\n      dimensions = { ...dimensions };\n\n      for (const prop in dimensions) {\n        dimensions =\n        dimensions[prop] > maxDimensions[prop] ?\n        ratio(dimensions, prop, maxDimensions[prop]) :\n        dimensions;\n      }\n\n      return dimensions;\n    }\n\n    function cover$1(dimensions, maxDimensions) {\n      dimensions = contain(dimensions, maxDimensions);\n\n      for (const prop in dimensions) {\n        dimensions =\n        dimensions[prop] < maxDimensions[prop] ?\n        ratio(dimensions, prop, maxDimensions[prop]) :\n        dimensions;\n      }\n\n      return dimensions;\n    }\n\n    const Dimensions = { ratio, contain, cover: cover$1 };\n\n    function getIndex(i, elements, current = 0, finite = false) {\n      elements = toNodes(elements);\n\n      const { length } = elements;\n\n      if (!length) {\n        return -1;\n      }\n\n      i = isNumeric(i) ?\n      toNumber(i) :\n      i === 'next' ?\n      current + 1 :\n      i === 'previous' ?\n      current - 1 :\n      elements.indexOf(toNode(i));\n\n      if (finite) {\n        return clamp(i, 0, length - 1);\n      }\n\n      i %= length;\n\n      return i < 0 ? i + length : i;\n    }\n\n    function memoize(fn) {\n      const cache = Object.create(null);\n      return (key) => cache[key] || (cache[key] = fn(key));\n    }\n\n    class Deferred {\n      constructor() {\n        this.promise = new Promise((resolve, reject) => {\n          this.reject = reject;\n          this.resolve = resolve;\n        });\n      }\n    }\n\n    function attr(element, name, value) {\n      if (isObject(name)) {\n        for (const key in name) {\n          attr(element, key, name[key]);\n        }\n        return;\n      }\n\n      if (isUndefined(value)) {var _toNode;\n        return (_toNode = toNode(element)) == null ? void 0 : _toNode.getAttribute(name);\n      } else {\n        for (const el of toNodes(element)) {\n          if (isFunction(value)) {\n            value = value.call(el, attr(el, name));\n          }\n\n          if (value === null) {\n            removeAttr(el, name);\n          } else {\n            el.setAttribute(name, value);\n          }\n        }\n      }\n    }\n\n    function hasAttr(element, name) {\n      return toNodes(element).some((element) => element.hasAttribute(name));\n    }\n\n    function removeAttr(element, name) {\n      const elements = toNodes(element);\n      for (const attribute of name.split(' ')) {\n        for (const element of elements) {\n          element.removeAttribute(attribute);\n        }\n      }\n    }\n\n    function data(element, attribute) {\n      for (const name of [attribute, `data-${attribute}`]) {\n        if (hasAttr(element, name)) {\n          return attr(element, name);\n        }\n      }\n    }\n\n    const voidElements = {\n      area: true,\n      base: true,\n      br: true,\n      col: true,\n      embed: true,\n      hr: true,\n      img: true,\n      input: true,\n      keygen: true,\n      link: true,\n      meta: true,\n      param: true,\n      source: true,\n      track: true,\n      wbr: true\n    };\n    function isVoidElement(element) {\n      return toNodes(element).some((element) => voidElements[element.tagName.toLowerCase()]);\n    }\n\n    function isVisible(element) {\n      return toNodes(element).some(\n      (element) => element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n\n    }\n\n    const selInput = 'input,select,textarea,button';\n    function isInput(element) {\n      return toNodes(element).some((element) => matches(element, selInput));\n    }\n\n    const selFocusable = `${selInput},a[href],[tabindex]`;\n    function isFocusable(element) {\n      return matches(element, selFocusable);\n    }\n\n    function parent(element) {var _toNode;\n      return (_toNode = toNode(element)) == null ? void 0 : _toNode.parentElement;\n    }\n\n    function filter$1(element, selector) {\n      return toNodes(element).filter((element) => matches(element, selector));\n    }\n\n    function matches(element, selector) {\n      return toNodes(element).some((element) => element.matches(selector));\n    }\n\n    function closest(element, selector) {\n      return isElement(element) ?\n      element.closest(startsWith(selector, '>') ? selector.slice(1) : selector) :\n      toNodes(element).\n      map((element) => closest(element, selector)).\n      filter(Boolean);\n    }\n\n    function within(element, selector) {\n      return isString(selector) ?\n      !!closest(element, selector) :\n      toNode(selector).contains(toNode(element));\n    }\n\n    function parents(element, selector) {\n      const elements = [];\n\n      while (element = parent(element)) {\n        if (!selector || matches(element, selector)) {\n          elements.push(element);\n        }\n      }\n\n      return elements;\n    }\n\n    function children(element, selector) {\n      element = toNode(element);\n      const children = element ? toNodes(element.children) : [];\n      return selector ? filter$1(children, selector) : children;\n    }\n\n    function index(element, ref) {\n      return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element);\n    }\n\n    function query(selector, context) {\n      return find(selector, getContext(selector, context));\n    }\n\n    function queryAll(selector, context) {\n      return findAll(selector, getContext(selector, context));\n    }\n\n    function find(selector, context) {\n      return toNode(_query(selector, context, 'querySelector'));\n    }\n\n    function findAll(selector, context) {\n      return toNodes(_query(selector, context, 'querySelectorAll'));\n    }\n\n    const contextSelectorRe = /(^|[^\\\\],)\\s*[!>+~-]/;\n    const isContextSelector = memoize((selector) => selector.match(contextSelectorRe));\n\n    function getContext(selector, context = document) {\n      return isString(selector) && isContextSelector(selector) || isDocument(context) ?\n      context :\n      context.ownerDocument;\n    }\n\n    const contextSanitizeRe = /([!>+~-])(?=\\s+[!>+~-]|\\s*$)/g;\n    const sanatize = memoize((selector) => selector.replace(contextSanitizeRe, '$1 *'));\n\n    function _query(selector, context = document, queryFn) {\n      if (!selector || !isString(selector)) {\n        return selector;\n      }\n\n      selector = sanatize(selector);\n\n      if (isContextSelector(selector)) {\n        const split = splitSelector(selector);\n        selector = '';\n        for (let sel of split) {\n          let ctx = context;\n\n          if (sel[0] === '!') {\n            const selectors = sel.substr(1).trim().split(' ');\n            ctx = closest(parent(context), selectors[0]);\n            sel = selectors.slice(1).join(' ').trim();\n            if (!sel.length && split.length === 1) {\n              return ctx;\n            }\n          }\n\n          if (sel[0] === '-') {\n            const selectors = sel.substr(1).trim().split(' ');\n            const prev = (ctx || context).previousElementSibling;\n            ctx = matches(prev, sel.substr(1)) ? prev : null;\n            sel = selectors.slice(1).join(' ');\n          }\n\n          if (ctx) {\n            selector += `${selector ? ',' : ''}${domPath(ctx)} ${sel}`;\n          }\n        }\n\n        context = document;\n      }\n\n      try {\n        return context[queryFn](selector);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    const selectorRe = /.*?[^\\\\](?:,|$)/g;\n\n    const splitSelector = memoize((selector) =>\n    selector.match(selectorRe).map((selector) => selector.replace(/,$/, '').trim()));\n\n\n    function domPath(element) {\n      const names = [];\n      while (element.parentNode) {\n        const id = attr(element, 'id');\n        if (id) {\n          names.unshift(`#${escape(id)}`);\n          break;\n        } else {\n          let { tagName } = element;\n          if (tagName !== 'HTML') {\n            tagName += `:nth-child(${index(element) + 1})`;\n          }\n          names.unshift(tagName);\n          element = element.parentNode;\n        }\n      }\n      return names.join(' > ');\n    }\n\n    function escape(css) {\n      return isString(css) ? CSS.escape(css) : '';\n    }\n\n    function on(...args) {\n      let [targets, types, selector, listener, useCapture = false] = getArgs(args);\n\n      if (listener.length > 1) {\n        listener = detail(listener);\n      }\n\n      if (useCapture != null && useCapture.self) {\n        listener = selfFilter(listener);\n      }\n\n      if (selector) {\n        listener = delegate(selector, listener);\n      }\n\n      for (const type of types) {\n        for (const target of targets) {\n          target.addEventListener(type, listener, useCapture);\n        }\n      }\n\n      return () => off(targets, types, listener, useCapture);\n    }\n\n    function off(...args) {\n      let [targets, types,, listener, useCapture = false] = getArgs(args);\n      for (const type of types) {\n        for (const target of targets) {\n          target.removeEventListener(type, listener, useCapture);\n        }\n      }\n    }\n\n    function once(...args) {\n      const [element, types, selector, listener, useCapture = false, condition] = getArgs(args);\n      const off = on(\n      element,\n      types,\n      selector,\n      (e) => {\n        const result = !condition || condition(e);\n        if (result) {\n          off();\n          listener(e, result);\n        }\n      },\n      useCapture);\n\n\n      return off;\n    }\n\n    function trigger(targets, event, detail) {\n      return toEventTargets(targets).every((target) => target.dispatchEvent(createEvent(event, true, true, detail)));\n\n    }\n\n    function createEvent(e, bubbles = true, cancelable = false, detail) {\n      if (isString(e)) {\n        e = new CustomEvent(e, { bubbles, cancelable, detail });\n      }\n\n      return e;\n    }\n\n    function getArgs(args) {\n      // Event targets\n      args[0] = toEventTargets(args[0]);\n\n      // Event types\n      if (isString(args[1])) {\n        args[1] = args[1].split(' ');\n      }\n\n      // Delegate?\n      if (isFunction(args[2])) {\n        args.splice(2, 0, false);\n      }\n\n      return args;\n    }\n\n    function delegate(selector, listener) {\n      return (e) => {\n        const current =\n        selector[0] === '>' ?\n        findAll(selector, e.currentTarget).\n        reverse().\n        filter((element) => within(e.target, element))[0] :\n        closest(e.target, selector);\n\n        if (current) {\n          e.current = current;\n          listener.call(this, e);\n        }\n      };\n    }\n\n    function detail(listener) {\n      return (e) => isArray(e.detail) ? listener(e, ...e.detail) : listener(e);\n    }\n\n    function selfFilter(listener) {\n      return function (e) {\n        if (e.target === e.currentTarget || e.target === e.current) {\n          return listener.call(null, e);\n        }\n      };\n    }\n\n    function isEventTarget(target) {\n      return target && 'addEventListener' in target;\n    }\n\n    function toEventTarget(target) {\n      return isEventTarget(target) ? target : toNode(target);\n    }\n\n    function toEventTargets(target) {\n      return isArray(target) ?\n      target.map(toEventTarget).filter(Boolean) :\n      isString(target) ?\n      findAll(target) :\n      isEventTarget(target) ?\n      [target] :\n      toNodes(target);\n    }\n\n    function isTouch(e) {\n      return e.pointerType === 'touch' || !!e.touches;\n    }\n\n    function getEventPos(e) {var _e$touches, _e$changedTouches;\n      const { clientX: x, clientY: y } = ((_e$touches = e.touches) == null ? void 0 : _e$touches[0]) || ((_e$changedTouches = e.changedTouches) == null ? void 0 : _e$changedTouches[0]) || e;\n\n      return { x, y };\n    }\n\n    function ajax(url, options) {\n      const env = {\n        data: null,\n        method: 'GET',\n        headers: {},\n        xhr: new XMLHttpRequest(),\n        beforeSend: noop,\n        responseType: '',\n        ...options\n      };\n      return Promise.resolve().\n      then(() => env.beforeSend(env)).\n      then(() => send(url, env));\n    }\n\n    function send(url, env) {\n      return new Promise((resolve, reject) => {\n        const { xhr } = env;\n\n        for (const prop in env) {\n          if (prop in xhr) {\n            try {\n              xhr[prop] = env[prop];\n            } catch (e) {\n\n              // noop\n            }}\n        }\n\n        xhr.open(env.method.toUpperCase(), url);\n\n        for (const header in env.headers) {\n          xhr.setRequestHeader(header, env.headers[header]);\n        }\n\n        on(xhr, 'load', () => {\n          if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n            resolve(xhr);\n          } else {\n            reject(\n            assign(Error(xhr.statusText), {\n              xhr,\n              status: xhr.status\n            }));\n\n          }\n        });\n\n        on(xhr, 'error', () => reject(assign(Error('Network Error'), { xhr })));\n        on(xhr, 'timeout', () => reject(assign(Error('Network Timeout'), { xhr })));\n\n        xhr.send(env.data);\n      });\n    }\n\n    function getImage(src, srcset, sizes) {\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n\n        img.onerror = (e) => {\n          reject(e);\n        };\n        img.onload = () => {\n          resolve(img);\n        };\n\n        sizes && (img.sizes = sizes);\n        srcset && (img.srcset = srcset);\n        img.src = src;\n      });\n    }\n\n    const cssNumber = {\n      'animation-iteration-count': true,\n      'column-count': true,\n      'fill-opacity': true,\n      'flex-grow': true,\n      'flex-shrink': true,\n      'font-weight': true,\n      'line-height': true,\n      opacity: true,\n      order: true,\n      orphans: true,\n      'stroke-dasharray': true,\n      'stroke-dashoffset': true,\n      widows: true,\n      'z-index': true,\n      zoom: true\n    };\n\n    function css(element, property, value, priority = '') {\n      const elements = toNodes(element);\n      for (const element of elements) {\n        if (isString(property)) {\n          property = propName(property);\n\n          if (isUndefined(value)) {\n            return getComputedStyle(element).getPropertyValue(property);\n          } else {\n            element.style.setProperty(\n            property,\n            isNumeric(value) && !cssNumber[property] ?\n            `${value}px` :\n            value || isNumber(value) ?\n            value :\n            '',\n            priority);\n\n          }\n        } else if (isArray(property)) {\n          const props = {};\n          for (const prop of property) {\n            props[prop] = css(element, prop);\n          }\n          return props;\n        } else if (isObject(property)) {\n          priority = value;\n          each(property, (value, property) => css(element, property, value, priority));\n        }\n      }\n      return elements[0];\n    }\n\n    // https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty\n    const propName = memoize((name) => vendorPropName(name));\n\n    function vendorPropName(name) {\n      if (startsWith(name, '--')) {\n        return name;\n      }\n\n      name = hyphenate(name);\n\n      const { style } = document.documentElement;\n\n      if (name in style) {\n        return name;\n      }\n\n      for (const prefix of ['webkit', 'moz']) {\n        const prefixedName = `-${prefix}-${name}`;\n        if (prefixedName in style) {\n          return prefixedName;\n        }\n      }\n    }\n\n    function addClass(element, ...args) {\n      apply$1(element, args, 'add');\n    }\n\n    function removeClass(element, ...args) {\n      apply$1(element, args, 'remove');\n    }\n\n    function removeClasses(element, cls) {\n      attr(element, 'class', (value) => (value || '').replace(new RegExp(`\\\\b${cls}\\\\b\\\\s?`, 'g'), ''));\n\n    }\n\n    function replaceClass(element, ...args) {\n      args[0] && removeClass(element, args[0]);\n      args[1] && addClass(element, args[1]);\n    }\n\n    function hasClass(element, cls) {\n      [cls] = getClasses(cls);\n      return !!cls && toNodes(element).some((node) => node.classList.contains(cls));\n    }\n\n    function toggleClass(element, cls, force) {\n      const classes = getClasses(cls);\n\n      if (!isUndefined(force)) {\n        force = !!force;\n      }\n\n      for (const node of toNodes(element)) {\n        for (const cls of classes) {\n          node.classList.toggle(cls, force);\n        }\n      }\n    }\n\n    function apply$1(element, args, fn) {\n      args = args.reduce((args, arg) => args.concat(getClasses(arg)), []);\n\n      for (const node of toNodes(element)) {\n        node.classList[fn](...args);\n      }\n    }\n\n    function getClasses(str) {\n      return String(str).split(/\\s|,/).filter(Boolean);\n    }\n\n    function transition$1(element, props, duration = 400, timing = 'linear') {\n      duration = Math.round(duration);\n      return Promise.all(\n      toNodes(element).map(\n      (element) => new Promise((resolve, reject) => {\n        for (const name in props) {\n          const value = css(element, name);\n          if (value === '') {\n            css(element, name, value);\n          }\n        }\n\n        const timer = setTimeout(() => trigger(element, 'transitionend'), duration);\n\n        once(\n        element,\n        'transitionend transitioncanceled',\n        ({ type }) => {\n          clearTimeout(timer);\n          removeClass(element, 'uk-transition');\n          css(element, {\n            transitionProperty: '',\n            transitionDuration: '',\n            transitionTimingFunction: ''\n          });\n          type === 'transitioncanceled' ? reject() : resolve(element);\n        },\n        { self: true });\n\n\n        addClass(element, 'uk-transition');\n        css(element, {\n          transitionProperty: Object.keys(props).map(propName).join(','),\n          transitionDuration: `${duration}ms`,\n          transitionTimingFunction: timing,\n          ...props\n        });\n      })));\n\n\n    }\n\n    const Transition = {\n      start: transition$1,\n\n      async stop(element) {\n        trigger(element, 'transitionend');\n        await Promise.resolve();\n      },\n\n      async cancel(element) {\n        trigger(element, 'transitioncanceled');\n        await Promise.resolve();\n      },\n\n      inProgress(element) {\n        return hasClass(element, 'uk-transition');\n      }\n    };\n\n    const animationPrefix = 'uk-animation-';\n\n    function animate$2(element, animation, duration = 200, origin, out) {\n      return Promise.all(\n      toNodes(element).map(\n      (element) => new Promise((resolve, reject) => {\n        trigger(element, 'animationcanceled');\n        const timer = setTimeout(() => trigger(element, 'animationend'), duration);\n\n        once(\n        element,\n        'animationend animationcanceled',\n        ({ type }) => {\n          clearTimeout(timer);\n\n          type === 'animationcanceled' ? reject() : resolve(element);\n\n          css(element, 'animationDuration', '');\n          removeClasses(element, `${animationPrefix}\\\\S*`);\n        },\n        { self: true });\n\n\n        css(element, 'animationDuration', `${duration}ms`);\n        addClass(element, animation, animationPrefix + (out ? 'leave' : 'enter'));\n\n        if (startsWith(animation, animationPrefix)) {\n          origin && addClass(element, `uk-transform-origin-${origin}`);\n          out && addClass(element, `${animationPrefix}reverse`);\n        }\n      })));\n\n\n    }\n\n    const inProgressRe = new RegExp(`${animationPrefix}(enter|leave)`);\n\n    const Animation = {\n      in: animate$2,\n\n      out(element, animation, duration, origin) {\n        return animate$2(element, animation, duration, origin, true);\n      },\n\n      inProgress(element) {\n        return inProgressRe.test(attr(element, 'class'));\n      },\n\n      cancel(element) {\n        trigger(element, 'animationcanceled');\n      }\n    };\n\n    function ready(fn) {\n      if (document.readyState !== 'loading') {\n        fn();\n        return;\n      }\n\n      once(document, 'DOMContentLoaded', fn);\n    }\n\n    function isTag(element, tagName) {var _element$tagName;\n      return (element == null ? void 0 : (_element$tagName = element.tagName) == null ? void 0 : _element$tagName.toLowerCase()) === tagName.toLowerCase();\n    }\n\n    function empty(element) {\n      element = $(element);\n      element.innerHTML = '';\n      return element;\n    }\n\n    function html(parent, html) {\n      return isUndefined(html) ? $(parent).innerHTML : append(empty(parent), html);\n    }\n\n    const prepend = applyFn('prepend');\n    const append = applyFn('append');\n    const before = applyFn('before');\n    const after = applyFn('after');\n\n    function applyFn(fn) {\n      return function (ref, element) {var _$;\n        const nodes = toNodes(isString(element) ? fragment(element) : element);\n        (_$ = $(ref)) == null ? void 0 : _$[fn](...nodes);\n        return unwrapSingle(nodes);\n      };\n    }\n\n    function remove$1(element) {\n      toNodes(element).forEach((element) => element.remove());\n    }\n\n    function wrapAll(element, structure) {\n      structure = toNode(before(element, structure));\n\n      while (structure.firstChild) {\n        structure = structure.firstChild;\n      }\n\n      append(structure, element);\n\n      return structure;\n    }\n\n    function wrapInner(element, structure) {\n      return toNodes(\n      toNodes(element).map((element) => element.hasChildNodes() ?\n      wrapAll(toNodes(element.childNodes), structure) :\n      append(element, structure)));\n\n\n    }\n\n    function unwrap(element) {\n      toNodes(element).\n      map(parent).\n      filter((value, index, self) => self.indexOf(value) === index).\n      forEach((parent) => parent.replaceWith(...parent.childNodes));\n    }\n\n    const fragmentRe = /^\\s*<(\\w+|!)[^>]*>/;\n    const singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\n    function fragment(html) {\n      const matches = singleTagRe.exec(html);\n      if (matches) {\n        return document.createElement(matches[1]);\n      }\n\n      const container = document.createElement('div');\n      if (fragmentRe.test(html)) {\n        container.insertAdjacentHTML('beforeend', html.trim());\n      } else {\n        container.textContent = html;\n      }\n\n      return unwrapSingle(container.childNodes);\n    }\n\n    function unwrapSingle(nodes) {\n      return nodes.length > 1 ? nodes : nodes[0];\n    }\n\n    function apply(node, fn) {\n      if (!isElement(node)) {\n        return;\n      }\n\n      fn(node);\n      node = node.firstElementChild;\n      while (node) {\n        const next = node.nextElementSibling;\n        apply(node, fn);\n        node = next;\n      }\n    }\n\n    function $(selector, context) {\n      return isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);\n    }\n\n    function $$(selector, context) {\n      return isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);\n    }\n\n    function isHtml(str) {\n      return isString(str) && startsWith(str.trim(), '<');\n    }\n\n    const dirs$1 = {\n      width: ['left', 'right'],\n      height: ['top', 'bottom']\n    };\n\n    function dimensions$1(element) {\n      const rect = isElement(element) ?\n      toNode(element).getBoundingClientRect() :\n      { height: height(element), width: width(element), top: 0, left: 0 };\n\n      return {\n        height: rect.height,\n        width: rect.width,\n        top: rect.top,\n        left: rect.left,\n        bottom: rect.top + rect.height,\n        right: rect.left + rect.width\n      };\n    }\n\n    function offset(element, coordinates) {\n      const currentOffset = dimensions$1(element);\n\n      if (element) {\n        const { scrollY, scrollX } = toWindow(element);\n        const offsetBy = { height: scrollY, width: scrollX };\n\n        for (const dir in dirs$1) {\n          for (const prop of dirs$1[dir]) {\n            currentOffset[prop] += offsetBy[dir];\n          }\n        }\n      }\n\n      if (!coordinates) {\n        return currentOffset;\n      }\n\n      const pos = css(element, 'position');\n\n      each(css(element, ['left', 'top']), (value, prop) => css(\n      element,\n      prop,\n      coordinates[prop] -\n      currentOffset[prop] +\n      toFloat(pos === 'absolute' && value === 'auto' ? position(element)[prop] : value)));\n\n\n    }\n\n    function position(element) {\n      let { top, left } = offset(element);\n\n      const {\n        ownerDocument: { body, documentElement },\n        offsetParent\n      } = toNode(element);\n      let parent = offsetParent || documentElement;\n\n      while (\n      parent && (\n      parent === body || parent === documentElement) &&\n      css(parent, 'position') === 'static')\n      {\n        parent = parent.parentNode;\n      }\n\n      if (isElement(parent)) {\n        const parentOffset = offset(parent);\n        top -= parentOffset.top + toFloat(css(parent, 'borderTopWidth'));\n        left -= parentOffset.left + toFloat(css(parent, 'borderLeftWidth'));\n      }\n\n      return {\n        top: top - toFloat(css(element, 'marginTop')),\n        left: left - toFloat(css(element, 'marginLeft'))\n      };\n    }\n\n    function offsetPosition(element) {\n      element = toNode(element);\n\n      const offset = [element.offsetTop, element.offsetLeft];\n\n      while (element = element.offsetParent) {\n        offset[0] += element.offsetTop + toFloat(css(element, `borderTopWidth`));\n        offset[1] += element.offsetLeft + toFloat(css(element, `borderLeftWidth`));\n\n        if (css(element, 'position') === 'fixed') {\n          const win = toWindow(element);\n          offset[0] += win.scrollY;\n          offset[1] += win.scrollX;\n          return offset;\n        }\n      }\n\n      return offset;\n    }\n\n    const height = dimension('height');\n    const width = dimension('width');\n\n    function dimension(prop) {\n      const propName = ucfirst(prop);\n      return (element, value) => {\n        if (isUndefined(value)) {\n          if (isWindow(element)) {\n            return element[`inner${propName}`];\n          }\n\n          if (isDocument(element)) {\n            const doc = element.documentElement;\n            return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]);\n          }\n\n          element = toNode(element);\n\n          value = css(element, prop);\n          value = value === 'auto' ? element[`offset${propName}`] : toFloat(value) || 0;\n\n          return value - boxModelAdjust(element, prop);\n        } else {\n          return css(\n          element,\n          prop,\n          !value && value !== 0 ? '' : +value + boxModelAdjust(element, prop) + 'px');\n\n        }\n      };\n    }\n\n    function boxModelAdjust(element, prop, sizing = 'border-box') {\n      return css(element, 'boxSizing') === sizing ?\n      sumBy(\n      dirs$1[prop].map(ucfirst),\n      (prop) => toFloat(css(element, `padding${prop}`)) +\n      toFloat(css(element, `border${prop}Width`))) :\n\n      0;\n    }\n\n    function flipPosition(pos) {\n      for (const dir in dirs$1) {\n        for (const i in dirs$1[dir]) {\n          if (dirs$1[dir][i] === pos) {\n            return dirs$1[dir][1 - i];\n          }\n        }\n      }\n      return pos;\n    }\n\n    function toPx(value, property = 'width', element = window, offsetDim = false) {\n      if (!isString(value)) {\n        return toFloat(value);\n      }\n\n      return sumBy(parseCalc(value), (value) => {\n        const unit = parseUnit(value);\n\n        return unit ?\n        percent(\n        unit === 'vh' ?\n        getViewportHeight() :\n        unit === 'vw' ?\n        width(toWindow(element)) :\n        offsetDim ?\n        element[`offset${ucfirst(property)}`] :\n        dimensions$1(element)[property],\n        value) :\n\n        value;\n      });\n    }\n\n    const calcRe = /-?\\d+(?:\\.\\d+)?(?:v[wh]|%|px)?/g;\n    const parseCalc = memoize((calc) => calc.toString().replace(/\\s/g, '').match(calcRe) || []);\n    const unitRe$1 = /(?:v[hw]|%)$/;\n    const parseUnit = memoize((str) => (str.match(unitRe$1) || [])[0]);\n\n    function percent(base, value) {\n      return base * toFloat(value) / 100;\n    }\n\n    let vh;\n    let vhEl;\n\n    function getViewportHeight() {\n      if (vh) {\n        return vh;\n      }\n      if (!vhEl) {\n        vhEl = $('<div>');\n        css(vhEl, {\n          height: '100vh',\n          position: 'fixed'\n        });\n        on(window, 'resize', () => vh = null);\n      }\n\n      append(document.body, vhEl);\n      vh = vhEl.clientHeight;\n      remove$1(vhEl);\n      return vh;\n    }\n\n    const inBrowser = typeof window !== 'undefined';\n    const isRtl = inBrowser && document.dir === 'rtl';\n\n    const hasTouch = inBrowser && 'ontouchstart' in window;\n    const hasPointerEvents = inBrowser && window.PointerEvent;\n\n    const pointerDown$1 = hasPointerEvents ? 'pointerdown' : hasTouch ? 'touchstart' : 'mousedown';\n    const pointerMove$1 = hasPointerEvents ? 'pointermove' : hasTouch ? 'touchmove' : 'mousemove';\n    const pointerUp$1 = hasPointerEvents ? 'pointerup' : hasTouch ? 'touchend' : 'mouseup';\n    const pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouch ? '' : 'mouseenter';\n    const pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouch ? '' : 'mouseleave';\n    const pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';\n\n    /*\n        Based on:\n        Copyright (c) 2016 Wilson Page wilsonpage@me.com\n        https://github.com/wilsonpage/fastdom\n    */\n\n    const fastdom = {\n      reads: [],\n      writes: [],\n\n      read(task) {\n        this.reads.push(task);\n        scheduleFlush();\n        return task;\n      },\n\n      write(task) {\n        this.writes.push(task);\n        scheduleFlush();\n        return task;\n      },\n\n      clear(task) {\n        remove(this.reads, task);\n        remove(this.writes, task);\n      },\n\n      flush\n    };\n\n    function flush(recursion) {\n      runTasks(fastdom.reads);\n      runTasks(fastdom.writes.splice(0));\n\n      fastdom.scheduled = false;\n\n      if (fastdom.reads.length || fastdom.writes.length) {\n        scheduleFlush(recursion + 1);\n      }\n    }\n\n    const RECURSION_LIMIT = 4;\n    function scheduleFlush(recursion) {\n      if (fastdom.scheduled) {\n        return;\n      }\n\n      fastdom.scheduled = true;\n      if (recursion && recursion < RECURSION_LIMIT) {\n        Promise.resolve().then(() => flush(recursion));\n      } else {\n        requestAnimationFrame(() => flush(1));\n      }\n    }\n\n    function runTasks(tasks) {\n      let task;\n      while (task = tasks.shift()) {\n        try {\n          task();\n        } catch (e) {\n          console.error(e);\n        }\n      }\n    }\n\n    function remove(array, item) {\n      const index = array.indexOf(item);\n      return ~index && array.splice(index, 1);\n    }\n\n    function MouseTracker() {}\n\n    MouseTracker.prototype = {\n      positions: [],\n\n      init() {\n        this.positions = [];\n\n        let position;\n        this.unbind = on(document, 'mousemove', (e) => position = getEventPos(e));\n        this.interval = setInterval(() => {\n          if (!position) {\n            return;\n          }\n\n          this.positions.push(position);\n\n          if (this.positions.length > 5) {\n            this.positions.shift();\n          }\n        }, 50);\n      },\n\n      cancel() {var _this$unbind;\n        (_this$unbind = this.unbind) == null ? void 0 : _this$unbind.call(this);\n        this.interval && clearInterval(this.interval);\n      },\n\n      movesTo(target) {\n        if (this.positions.length < 2) {\n          return false;\n        }\n\n        const p = target.getBoundingClientRect();\n        const { left, right, top, bottom } = p;\n\n        const [prevPosition] = this.positions;\n        const position = last(this.positions);\n        const path = [prevPosition, position];\n\n        if (pointInRect(position, p)) {\n          return false;\n        }\n\n        const diagonals = [\n        [\n        { x: left, y: top },\n        { x: right, y: bottom }],\n\n        [\n        { x: left, y: bottom },\n        { x: right, y: top }]];\n\n\n\n        return diagonals.some((diagonal) => {\n          const intersection = intersect(path, diagonal);\n          return intersection && pointInRect(intersection, p);\n        });\n      }\n    };\n\n    // Inspired by http://paulbourke.net/geometry/pointlineplane/\n    function intersect([{ x: x1, y: y1 }, { x: x2, y: y2 }], [{ x: x3, y: y3 }, { x: x4, y: y4 }]) {\n      const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n      // Lines are parallel\n      if (denominator === 0) {\n        return false;\n      }\n\n      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n\n      if (ua < 0) {\n        return false;\n      }\n\n      // Return an object with the x and y coordinates of the intersection\n      return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };\n    }\n\n    function observeIntersection(targets, cb, options, intersecting = true) {\n      const observer = new IntersectionObserver(\n      intersecting ?\n      (entries, observer) => {\n        if (entries.some((entry) => entry.isIntersecting)) {\n          cb(entries, observer);\n        }\n      } :\n      cb,\n      options);\n\n      for (const el of toNodes(targets)) {\n        observer.observe(el);\n      }\n\n      return observer;\n    }\n\n    const hasResizeObserver = inBrowser && window.ResizeObserver;\n    function observeResize(targets, cb, options = { box: 'border-box' }) {\n      if (hasResizeObserver) {\n        return observe(ResizeObserver, targets, cb, options);\n      }\n\n      // Fallback Safari < 13.1\n      initResizeListener();\n      listeners.add(cb);\n\n      return {\n        disconnect() {\n          listeners.delete(cb);\n        }\n      };\n    }\n\n    let listeners;\n    function initResizeListener() {\n      if (listeners) {\n        return;\n      }\n\n      listeners = new Set();\n\n      // throttle 'resize'\n      let pendingResize;\n      const handleResize = () => {\n        if (pendingResize) {\n          return;\n        }\n        pendingResize = true;\n        requestAnimationFrame(() => pendingResize = false);\n        for (const listener of listeners) {\n          listener();\n        }\n      };\n\n      on(window, 'load resize', handleResize);\n      on(document, 'loadedmetadata load', handleResize, true);\n    }\n\n    function observeMutation(targets, cb, options) {\n      return observe(MutationObserver, targets, cb, options);\n    }\n\n    function observe(Observer, targets, cb, options) {\n      const observer = new Observer(cb);\n      for (const el of toNodes(targets)) {\n        observer.observe(el, options);\n      }\n\n      return observer;\n    }\n\n    const strats = {};\n\n    strats.events =\n    strats.created =\n    strats.beforeConnect =\n    strats.connected =\n    strats.beforeDisconnect =\n    strats.disconnected =\n    strats.destroy =\n    concatStrat;\n\n    // args strategy\n    strats.args = function (parentVal, childVal) {\n      return childVal !== false && concatStrat(childVal || parentVal);\n    };\n\n    // update strategy\n    strats.update = function (parentVal, childVal) {\n      return sortBy$1(\n      concatStrat(parentVal, isFunction(childVal) ? { read: childVal } : childVal),\n      'order');\n\n    };\n\n    // property strategy\n    strats.props = function (parentVal, childVal) {\n      if (isArray(childVal)) {\n        const value = {};\n        for (const key of childVal) {\n          value[key] = String;\n        }\n        childVal = value;\n      }\n\n      return strats.methods(parentVal, childVal);\n    };\n\n    // extend strategy\n    strats.computed = strats.methods = function (parentVal, childVal) {\n      return childVal ? parentVal ? { ...parentVal, ...childVal } : childVal : parentVal;\n    };\n\n    // data strategy\n    strats.data = function (parentVal, childVal, vm) {\n      if (!vm) {\n        if (!childVal) {\n          return parentVal;\n        }\n\n        if (!parentVal) {\n          return childVal;\n        }\n\n        return function (vm) {\n          return mergeFnData(parentVal, childVal, vm);\n        };\n      }\n\n      return mergeFnData(parentVal, childVal, vm);\n    };\n\n    function mergeFnData(parentVal, childVal, vm) {\n      return strats.computed(\n      isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal,\n      isFunction(childVal) ? childVal.call(vm, vm) : childVal);\n\n    }\n\n    // concat strategy\n    function concatStrat(parentVal, childVal) {\n      parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;\n\n      return childVal ?\n      parentVal ?\n      parentVal.concat(childVal) :\n      isArray(childVal) ?\n      childVal :\n      [childVal] :\n      parentVal;\n    }\n\n    // default strategy\n    function defaultStrat(parentVal, childVal) {\n      return isUndefined(childVal) ? parentVal : childVal;\n    }\n\n    function mergeOptions(parent, child, vm) {\n      const options = {};\n\n      if (isFunction(child)) {\n        child = child.options;\n      }\n\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n\n      if (child.mixins) {\n        for (const mixin of child.mixins) {\n          parent = mergeOptions(parent, mixin, vm);\n        }\n      }\n\n      for (const key in parent) {\n        mergeKey(key);\n      }\n\n      for (const key in child) {\n        if (!hasOwn(parent, key)) {\n          mergeKey(key);\n        }\n      }\n\n      function mergeKey(key) {\n        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);\n      }\n\n      return options;\n    }\n\n    function parseOptions(options, args = []) {\n      try {\n        return options ?\n        startsWith(options, '{') ?\n        JSON.parse(options) :\n        args.length && !includes(options, ':') ?\n        { [args[0]]: options } :\n        options.split(';').reduce((options, option) => {\n          const [key, value] = option.split(/:(.*)/);\n          if (key && !isUndefined(value)) {\n            options[key.trim()] = value.trim();\n          }\n          return options;\n        }, {}) :\n        {};\n      } catch (e) {\n        return {};\n      }\n    }\n\n    function play(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'playVideo', method: 'play' });\n      }\n\n      if (isHTML5(el)) {\n        try {\n          el.play().catch(noop);\n        } catch (e) {\n\n          // noop\n        }}\n    }\n\n    function pause(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'pauseVideo', method: 'pause' });\n      }\n\n      if (isHTML5(el)) {\n        el.pause();\n      }\n    }\n\n    function mute(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'mute', method: 'setVolume', value: 0 });\n      }\n\n      if (isHTML5(el)) {\n        el.muted = true;\n      }\n    }\n\n    function isVideo(el) {\n      return isHTML5(el) || isIFrame(el);\n    }\n\n    function isHTML5(el) {\n      return isTag(el, 'video');\n    }\n\n    function isIFrame(el) {\n      return isTag(el, 'iframe') && (isYoutube(el) || isVimeo(el));\n    }\n\n    function isYoutube(el) {\n      return !!el.src.match(\n      /\\/\\/.*?youtube(-nocookie)?\\.[a-z]+\\/(watch\\?v=[^&\\s]+|embed)|youtu\\.be\\/.*/);\n\n    }\n\n    function isVimeo(el) {\n      return !!el.src.match(/vimeo\\.com\\/video\\/.*/);\n    }\n\n    async function call(el, cmd) {\n      await enableApi(el);\n      post(el, cmd);\n    }\n\n    function post(el, cmd) {\n      try {\n        el.contentWindow.postMessage(JSON.stringify({ event: 'command', ...cmd }), '*');\n      } catch (e) {\n\n        // noop\n      }}\n\n    const stateKey = '_ukPlayer';\n    let counter = 0;\n    function enableApi(el) {\n      if (el[stateKey]) {\n        return el[stateKey];\n      }\n\n      const youtube = isYoutube(el);\n      const vimeo = isVimeo(el);\n\n      const id = ++counter;\n      let poller;\n\n      return el[stateKey] = new Promise((resolve) => {\n        youtube &&\n        once(el, 'load', () => {\n          const listener = () => post(el, { event: 'listening', id });\n          poller = setInterval(listener, 100);\n          listener();\n        });\n\n        once(window, 'message', resolve, false, ({ data }) => {\n          try {\n            data = JSON.parse(data);\n            return (\n              data && (\n              youtube && data.id === id && data.event === 'onReady' ||\n              vimeo && Number(data.player_id) === id));\n\n          } catch (e) {\n\n            // noop\n          }});\n\n        el.src = `${el.src}${includes(el.src, '?') ? '&' : '?'}${\n    youtube ? 'enablejsapi=1' : `api=1&player_id=${id}`\n    }`;\n      }).then(() => clearInterval(poller));\n    }\n\n    function isInView(element, offsetTop = 0, offsetLeft = 0) {\n      if (!isVisible(element)) {\n        return false;\n      }\n\n      return intersectRect(\n      ...scrollParents(element).\n      map((parent) => {\n        const { top, left, bottom, right } = offsetViewport(parent);\n\n        return {\n          top: top - offsetTop,\n          left: left - offsetLeft,\n          bottom: bottom + offsetTop,\n          right: right + offsetLeft\n        };\n      }).\n      concat(offset(element)));\n\n    }\n\n    function scrollIntoView(element, { offset: offsetBy = 0 } = {}) {\n      const parents = isVisible(element) ? scrollParents(element) : [];\n      return parents.reduce(\n      (fn, scrollElement, i) => {\n        const { scrollTop, scrollHeight, offsetHeight } = scrollElement;\n        const viewport = offsetViewport(scrollElement);\n        const maxScroll = scrollHeight - viewport.height;\n        const { height: elHeight, top: elTop } = parents[i - 1] ?\n        offsetViewport(parents[i - 1]) :\n        offset(element);\n\n        let top = Math.ceil(elTop - viewport.top - offsetBy + scrollTop);\n\n        if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {\n          top += offsetBy;\n        } else {\n          offsetBy = 0;\n        }\n\n        if (top > maxScroll) {\n          offsetBy -= top - maxScroll;\n          top = maxScroll;\n        } else if (top < 0) {\n          offsetBy -= top;\n          top = 0;\n        }\n\n        return () => scrollTo(scrollElement, top - scrollTop).then(fn);\n      },\n      () => Promise.resolve())();\n\n\n      function scrollTo(element, top) {\n        return new Promise((resolve) => {\n          const scroll = element.scrollTop;\n          const duration = getDuration(Math.abs(top));\n          const start = Date.now();\n\n          (function step() {\n            const percent = ease(clamp((Date.now() - start) / duration));\n\n            element.scrollTop = scroll + top * percent;\n\n            // scroll more if we have not reached our destination\n            if (percent === 1) {\n              resolve();\n            } else {\n              requestAnimationFrame(step);\n            }\n          })();\n        });\n      }\n\n      function getDuration(dist) {\n        return 40 * Math.pow(dist, 0.375);\n      }\n\n      function ease(k) {\n        return 0.5 * (1 - Math.cos(Math.PI * k));\n      }\n    }\n\n    function scrolledOver(element, startOffset = 0, endOffset = 0) {\n      if (!isVisible(element)) {\n        return 0;\n      }\n\n      const [scrollElement] = scrollParents(element, /auto|scroll/, true);\n      const { scrollHeight, scrollTop } = scrollElement;\n      const { height: viewportHeight } = offsetViewport(scrollElement);\n      const maxScroll = scrollHeight - viewportHeight;\n      const elementOffsetTop = offsetPosition(element)[0] - offsetPosition(scrollElement)[0];\n\n      const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset);\n      const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset);\n\n      return clamp((scrollTop - start) / (end - start));\n    }\n\n    function scrollParents(element, overflowRe = /auto|scroll|hidden|clip/, scrollable = false) {\n      const scrollEl = scrollingElement(element);\n\n      let ancestors = parents(element).reverse();\n      ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);\n\n      const fixedIndex = findIndex(ancestors, (el) => css(el, 'position') === 'fixed');\n      if (~fixedIndex) {\n        ancestors = ancestors.slice(fixedIndex);\n      }\n\n      return [scrollEl].\n      concat(\n      ancestors.filter(\n      (parent) => overflowRe.test(css(parent, 'overflow')) && (\n      !scrollable || parent.scrollHeight > offsetViewport(parent).height))).\n\n\n      reverse();\n    }\n\n    function offsetViewport(scrollElement) {\n      const window = toWindow(scrollElement);\n      const {\n        document: { documentElement }\n      } = window;\n      let viewportElement =\n      scrollElement === scrollingElement(scrollElement) ? window : scrollElement;\n\n      const { visualViewport } = window;\n      if (isWindow(viewportElement) && visualViewport) {\n        let { height, width, scale, pageTop: top, pageLeft: left } = visualViewport;\n        height = Math.round(height * scale);\n        width = Math.round(width * scale);\n        return { height, width, top, left, bottom: top + height, right: left + width };\n      }\n\n      let rect = offset(viewportElement);\n      if (css(viewportElement, 'display') === 'inline') {\n        return rect;\n      }\n\n      for (let [prop, dir, start, end] of [\n      ['width', 'x', 'left', 'right'],\n      ['height', 'y', 'top', 'bottom']])\n      {\n        if (isWindow(viewportElement)) {\n          // iOS 12 returns <body> as scrollingElement\n          viewportElement = documentElement;\n        } else {\n          rect[start] += toFloat(css(viewportElement, `border-${start}-width`));\n        }\n        rect[prop] = rect[dir] = viewportElement[`client${ucfirst(prop)}`];\n        rect[end] = rect[prop] + rect[start];\n      }\n      return rect;\n    }\n\n    function scrollingElement(element) {\n      return toWindow(element).document.scrollingElement;\n    }\n\n    const dirs = [\n    ['width', 'x', 'left', 'right'],\n    ['height', 'y', 'top', 'bottom']];\n\n\n    function positionAt(element, target, options) {\n      options = {\n        attach: {\n          element: ['left', 'top'],\n          target: ['left', 'top'],\n          ...options.attach\n        },\n        offset: [0, 0],\n        placement: [],\n        ...options\n      };\n\n      if (!isArray(target)) {\n        target = [target, target];\n      }\n\n      offset(element, getPosition(element, target, options));\n    }\n\n    function getPosition(element, target, options) {\n      const position = attachTo(element, target, options);\n      const { boundary, viewportOffset = 0, placement } = options;\n\n      let offsetPosition = position;\n      for (const [i, [prop,, start, end]] of Object.entries(dirs)) {\n        const viewport = getViewport$2(element, target[i], viewportOffset, boundary, i);\n\n        if (isWithin(position, viewport, i)) {\n          continue;\n        }\n\n        let offsetBy = 0;\n\n        // Flip\n        if (placement[i] === 'flip') {\n          const attach = options.attach.target[i];\n          if (\n          attach === end && position[end] <= viewport[end] ||\n          attach === start && position[start] >= viewport[start])\n          {\n            continue;\n          }\n\n          offsetBy = flip(element, target, options, i)[start] - position[start];\n\n          const scrollArea = getScrollArea(element, target[i], viewportOffset, i);\n\n          if (!isWithin(applyOffset(position, offsetBy, i), scrollArea, i)) {\n            if (isWithin(position, scrollArea, i)) {\n              continue;\n            }\n\n            if (options.recursion) {\n              return false;\n            }\n\n            const newPos = flipAxis(element, target, options);\n\n            if (newPos && isWithin(newPos, scrollArea, 1 - i)) {\n              return newPos;\n            }\n\n            continue;\n          }\n\n          // Shift\n        } else if (placement[i] === 'shift') {\n          const targetDim = offset(target[i]);\n          const { offset: elOffset } = options;\n          offsetBy =\n          clamp(\n          clamp(position[start], viewport[start], viewport[end] - position[prop]),\n          targetDim[start] - position[prop] + elOffset[i],\n          targetDim[end] - elOffset[i]) -\n          position[start];\n        }\n\n        offsetPosition = applyOffset(offsetPosition, offsetBy, i);\n      }\n\n      return offsetPosition;\n    }\n\n    function attachTo(element, target, options) {\n      let { attach, offset: offsetBy } = {\n        attach: {\n          element: ['left', 'top'],\n          target: ['left', 'top'],\n          ...options.attach\n        },\n        offset: [0, 0],\n        ...options\n      };\n\n      let elOffset = offset(element);\n\n      for (const [i, [prop,, start, end]] of Object.entries(dirs)) {\n        const targetOffset =\n        attach.target[i] === attach.element[i] ? offsetViewport(target[i]) : offset(target[i]);\n\n        elOffset = applyOffset(\n        elOffset,\n        targetOffset[start] -\n        elOffset[start] +\n        moveBy(attach.target[i], end, targetOffset[prop]) -\n        moveBy(attach.element[i], end, elOffset[prop]) +\n        +offsetBy[i],\n        i);\n\n      }\n      return elOffset;\n    }\n\n    function applyOffset(position, offset, i) {\n      const [, dir, start, end] = dirs[i];\n      const newPos = { ...position };\n      newPos[start] = position[dir] = position[start] + offset;\n      newPos[end] += offset;\n      return newPos;\n    }\n\n    function moveBy(attach, end, dim) {\n      return attach === 'center' ? dim / 2 : attach === end ? dim : 0;\n    }\n\n    function getViewport$2(element, target, viewportOffset, boundary, i) {\n      let viewport = getIntersectionArea(...commonScrollParents(element, target).map(offsetViewport));\n\n      if (viewportOffset) {\n        viewport[dirs[i][2]] += viewportOffset;\n        viewport[dirs[i][3]] -= viewportOffset;\n      }\n\n      if (boundary) {\n        viewport = getIntersectionArea(\n        viewport,\n        offset(isArray(boundary) ? boundary[i] : boundary));\n\n      }\n\n      return viewport;\n    }\n\n    function getScrollArea(element, target, viewportOffset, i) {\n      const [prop, axis, start, end] = dirs[i];\n      const [scrollElement] = commonScrollParents(element, target);\n      const viewport = offsetViewport(scrollElement);\n\n      if (['auto', 'scroll'].includes(css(scrollElement, `overflow-${axis}`))) {\n        viewport[start] -= scrollElement[`scroll${ucfirst(start)}`];\n        viewport[end] = scrollElement[`scroll${ucfirst(prop)}`];\n      }\n\n      viewport[start] += viewportOffset;\n      viewport[end] -= viewportOffset;\n\n      return viewport;\n    }\n\n    function commonScrollParents(element, target) {\n      return scrollParents(target).filter((parent) => within(element, parent));\n    }\n\n    function getIntersectionArea(...rects) {\n      let area = {};\n      for (const rect of rects) {\n        for (const [,, start, end] of dirs) {\n          area[start] = Math.max(area[start] || 0, rect[start]);\n          area[end] = Math.min(...[area[end], rect[end]].filter(Boolean));\n        }\n      }\n      return area;\n    }\n\n    function isWithin(positionA, positionB, i) {\n      const [,, start, end] = dirs[i];\n      return positionA[start] >= positionB[start] && positionA[end] <= positionB[end];\n    }\n\n    function flip(element, target, { offset, attach }, i) {\n      return attachTo(element, target, {\n        attach: {\n          element: flipAttach(attach.element, i),\n          target: flipAttach(attach.target, i)\n        },\n        offset: flipOffset(offset, i)\n      });\n    }\n\n    function flipAxis(element, target, options) {\n      return getPosition(element, target, {\n        ...options,\n        attach: {\n          element: options.attach.element.map(flipAttachAxis).reverse(),\n          target: options.attach.target.map(flipAttachAxis).reverse()\n        },\n        offset: options.offset.reverse(),\n        placement: options.placement.reverse(),\n        recursion: true\n      });\n    }\n\n    function flipAttach(attach, i) {\n      const newAttach = [...attach];\n      const index = dirs[i].indexOf(attach[i]);\n      if (~index) {\n        newAttach[i] = dirs[i][1 - index % 2 + 2];\n      }\n      return newAttach;\n    }\n\n    function flipAttachAxis(prop) {\n      for (let i = 0; i < dirs.length; i++) {\n        const index = dirs[i].indexOf(prop);\n        if (~index) {\n          return dirs[1 - i][index % 2 + 2];\n        }\n      }\n    }\n\n    function flipOffset(offset, i) {\n      offset = [...offset];\n      offset[i] *= -1;\n      return offset;\n    }\n\n    var util = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        ajax: ajax,\n        getImage: getImage,\n        Transition: Transition,\n        Animation: Animation,\n        attr: attr,\n        hasAttr: hasAttr,\n        removeAttr: removeAttr,\n        data: data,\n        addClass: addClass,\n        removeClass: removeClass,\n        removeClasses: removeClasses,\n        replaceClass: replaceClass,\n        hasClass: hasClass,\n        toggleClass: toggleClass,\n        dimensions: dimensions$1,\n        offset: offset,\n        position: position,\n        offsetPosition: offsetPosition,\n        height: height,\n        width: width,\n        boxModelAdjust: boxModelAdjust,\n        flipPosition: flipPosition,\n        toPx: toPx,\n        ready: ready,\n        isTag: isTag,\n        empty: empty,\n        html: html,\n        prepend: prepend,\n        append: append,\n        before: before,\n        after: after,\n        remove: remove$1,\n        wrapAll: wrapAll,\n        wrapInner: wrapInner,\n        unwrap: unwrap,\n        fragment: fragment,\n        apply: apply,\n        $: $,\n        $$: $$,\n        inBrowser: inBrowser,\n        isRtl: isRtl,\n        hasTouch: hasTouch,\n        pointerDown: pointerDown$1,\n        pointerMove: pointerMove$1,\n        pointerUp: pointerUp$1,\n        pointerEnter: pointerEnter,\n        pointerLeave: pointerLeave,\n        pointerCancel: pointerCancel,\n        on: on,\n        off: off,\n        once: once,\n        trigger: trigger,\n        createEvent: createEvent,\n        toEventTargets: toEventTargets,\n        isTouch: isTouch,\n        getEventPos: getEventPos,\n        fastdom: fastdom,\n        isVoidElement: isVoidElement,\n        isVisible: isVisible,\n        selInput: selInput,\n        isInput: isInput,\n        selFocusable: selFocusable,\n        isFocusable: isFocusable,\n        parent: parent,\n        filter: filter$1,\n        matches: matches,\n        closest: closest,\n        within: within,\n        parents: parents,\n        children: children,\n        index: index,\n        hasOwn: hasOwn,\n        hyphenate: hyphenate,\n        camelize: camelize,\n        ucfirst: ucfirst,\n        startsWith: startsWith,\n        endsWith: endsWith,\n        includes: includes,\n        findIndex: findIndex,\n        isArray: isArray,\n        toArray: toArray,\n        assign: assign,\n        isFunction: isFunction,\n        isObject: isObject,\n        isPlainObject: isPlainObject,\n        isWindow: isWindow,\n        isDocument: isDocument,\n        isNode: isNode,\n        isElement: isElement,\n        isBoolean: isBoolean,\n        isString: isString,\n        isNumber: isNumber,\n        isNumeric: isNumeric,\n        isEmpty: isEmpty,\n        isUndefined: isUndefined,\n        toBoolean: toBoolean,\n        toNumber: toNumber,\n        toFloat: toFloat,\n        toNode: toNode,\n        toNodes: toNodes,\n        toWindow: toWindow,\n        isEqual: isEqual,\n        swap: swap,\n        last: last,\n        each: each,\n        sortBy: sortBy$1,\n        sumBy: sumBy,\n        uniqueBy: uniqueBy,\n        clamp: clamp,\n        noop: noop,\n        intersectRect: intersectRect,\n        pointInRect: pointInRect,\n        Dimensions: Dimensions,\n        getIndex: getIndex,\n        memoize: memoize,\n        Deferred: Deferred,\n        MouseTracker: MouseTracker,\n        observeIntersection: observeIntersection,\n        observeResize: observeResize,\n        observeMutation: observeMutation,\n        mergeOptions: mergeOptions,\n        parseOptions: parseOptions,\n        play: play,\n        pause: pause,\n        mute: mute,\n        isVideo: isVideo,\n        positionAt: positionAt,\n        query: query,\n        queryAll: queryAll,\n        find: find,\n        findAll: findAll,\n        escape: escape,\n        css: css,\n        propName: propName,\n        isInView: isInView,\n        scrollIntoView: scrollIntoView,\n        scrolledOver: scrolledOver,\n        scrollParents: scrollParents,\n        offsetViewport: offsetViewport\n    });\n\n    function globalAPI (UIkit) {\n      const DATA = UIkit.data;\n\n      UIkit.use = function (plugin) {\n        if (plugin.installed) {\n          return;\n        }\n\n        plugin.call(null, this);\n        plugin.installed = true;\n\n        return this;\n      };\n\n      UIkit.mixin = function (mixin, component) {\n        component = (isString(component) ? UIkit.component(component) : component) || this;\n        component.options = mergeOptions(component.options, mixin);\n      };\n\n      UIkit.extend = function (options) {\n        options = options || {};\n\n        const Super = this;\n        const Sub = function UIkitComponent(options) {\n          this._init(options);\n        };\n\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.options = mergeOptions(Super.options, options);\n\n        Sub.super = Super;\n        Sub.extend = Super.extend;\n\n        return Sub;\n      };\n\n      UIkit.update = function (element, e) {\n        element = element ? toNode(element) : document.body;\n\n        for (const parentEl of parents(element).reverse()) {\n          update(parentEl[DATA], e);\n        }\n\n        apply(element, (element) => update(element[DATA], e));\n      };\n\n      let container;\n      Object.defineProperty(UIkit, 'container', {\n        get() {\n          return container || document.body;\n        },\n\n        set(element) {\n          container = $(element);\n        }\n      });\n\n      function update(data, e) {\n        if (!data) {\n          return;\n        }\n\n        for (const name in data) {\n          if (data[name]._connected) {\n            data[name]._callUpdate(e);\n          }\n        }\n      }\n    }\n\n    function hooksAPI (UIkit) {\n      UIkit.prototype._callHook = function (hook) {var _this$$options$hook;\n        (_this$$options$hook = this.$options[hook]) == null ? void 0 : _this$$options$hook.forEach((handler) => handler.call(this));\n      };\n\n      UIkit.prototype._callConnected = function () {\n        if (this._connected) {\n          return;\n        }\n\n        this._data = {};\n        this._computed = {};\n\n        this._initProps();\n\n        this._callHook('beforeConnect');\n        this._connected = true;\n\n        this._initEvents();\n        this._initObservers();\n\n        this._callHook('connected');\n        this._callUpdate();\n      };\n\n      UIkit.prototype._callDisconnected = function () {\n        if (!this._connected) {\n          return;\n        }\n\n        this._callHook('beforeDisconnect');\n        this._disconnectObservers();\n        this._unbindEvents();\n        this._callHook('disconnected');\n\n        this._connected = false;\n        delete this._watch;\n      };\n\n      UIkit.prototype._callUpdate = function (e = 'update') {\n        if (!this._connected) {\n          return;\n        }\n\n        if (e === 'update' || e === 'resize') {\n          this._callWatches();\n        }\n\n        if (!this.$options.update) {\n          return;\n        }\n\n        if (!this._updates) {\n          this._updates = new Set();\n          fastdom.read(() => {\n            if (this._connected) {\n              runUpdates.call(this, this._updates);\n            }\n            delete this._updates;\n          });\n        }\n\n        this._updates.add(e.type || e);\n      };\n\n      UIkit.prototype._callWatches = function () {\n        if (this._watch) {\n          return;\n        }\n\n        const initial = !hasOwn(this, '_watch');\n\n        this._watch = fastdom.read(() => {\n          if (this._connected) {\n            runWatches.call(this, initial);\n          }\n          this._watch = null;\n        });\n      };\n\n      function runUpdates(types) {\n        for (const { read, write, events = [] } of this.$options.update) {\n          if (!types.has('update') && !events.some((type) => types.has(type))) {\n            continue;\n          }\n\n          let result;\n          if (read) {\n            result = read.call(this, this._data, types);\n\n            if (result && isPlainObject(result)) {\n              assign(this._data, result);\n            }\n          }\n\n          if (write && result !== false) {\n            fastdom.write(() => {\n              if (this._connected) {\n                write.call(this, this._data, types);\n              }\n            });\n          }\n        }\n      }\n\n      function runWatches(initial) {\n        const {\n          $options: { computed }\n        } = this;\n        const values = { ...this._computed };\n        this._computed = {};\n\n        for (const key in computed) {\n          const { watch, immediate } = computed[key];\n          if (\n          watch && (\n          initial && immediate ||\n          hasOwn(values, key) && !isEqual(values[key], this[key])))\n          {\n            watch.call(this, this[key], values[key]);\n          }\n        }\n      }\n    }\n\n    function stateAPI (UIkit) {\n      let uid = 0;\n\n      UIkit.prototype._init = function (options) {\n        options = options || {};\n        options.data = normalizeData(options, this.constructor.options);\n\n        this.$options = mergeOptions(this.constructor.options, options, this);\n        this.$el = null;\n        this.$props = {};\n\n        this._uid = uid++;\n        this._initData();\n        this._initMethods();\n        this._initComputeds();\n        this._callHook('created');\n\n        if (options.el) {\n          this.$mount(options.el);\n        }\n      };\n\n      UIkit.prototype._initData = function () {\n        const { data = {} } = this.$options;\n\n        for (const key in data) {\n          this.$props[key] = this[key] = data[key];\n        }\n      };\n\n      UIkit.prototype._initMethods = function () {\n        const { methods } = this.$options;\n\n        if (methods) {\n          for (const key in methods) {\n            this[key] = methods[key].bind(this);\n          }\n        }\n      };\n\n      UIkit.prototype._initComputeds = function () {\n        const { computed } = this.$options;\n\n        this._computed = {};\n\n        if (computed) {\n          for (const key in computed) {\n            registerComputed(this, key, computed[key]);\n          }\n        }\n      };\n\n      UIkit.prototype._initProps = function (props) {\n        let key;\n\n        props = props || getProps$1(this.$options);\n\n        for (key in props) {\n          if (!isUndefined(props[key])) {\n            this.$props[key] = props[key];\n          }\n        }\n\n        const exclude = [this.$options.computed, this.$options.methods];\n        for (key in this.$props) {\n          if (key in props && notIn(exclude, key)) {\n            this[key] = this.$props[key];\n          }\n        }\n      };\n\n      UIkit.prototype._initEvents = function () {\n        this._events = [];\n        for (const event of this.$options.events || []) {\n          if (hasOwn(event, 'handler')) {\n            registerEvent(this, event);\n          } else {\n            for (const key in event) {\n              registerEvent(this, event[key], key);\n            }\n          }\n        }\n      };\n\n      UIkit.prototype._unbindEvents = function () {\n        this._events.forEach((unbind) => unbind());\n        delete this._events;\n      };\n\n      UIkit.prototype._initObservers = function () {\n        this._observers = [initPropsObserver(this), initChildListObserver(this)];\n      };\n\n      UIkit.prototype.registerObserver = function (...observer) {\n        this._observers.push(...observer);\n      };\n\n      UIkit.prototype._disconnectObservers = function () {\n        this._observers.forEach((observer) => observer == null ? void 0 : observer.disconnect());\n      };\n    }\n\n    function getProps$1(opts) {\n      const data$1 = {};\n      const { args = [], props = {}, el, id } = opts;\n\n      if (!props) {\n        return data$1;\n      }\n\n      for (const key in props) {\n        const prop = hyphenate(key);\n        let value = data(el, prop);\n\n        if (isUndefined(value)) {\n          continue;\n        }\n\n        value = props[key] === Boolean && value === '' ? true : coerce$1(props[key], value);\n\n        if (prop === 'target' && startsWith(value, '_')) {\n          continue;\n        }\n\n        data$1[key] = value;\n      }\n\n      const options = parseOptions(data(el, id), args);\n\n      for (const key in options) {\n        const prop = camelize(key);\n        if (!isUndefined(props[prop])) {\n          data$1[prop] = coerce$1(props[prop], options[key]);\n        }\n      }\n\n      return data$1;\n    }\n\n    function registerComputed(component, key, cb) {\n      Object.defineProperty(component, key, {\n        enumerable: true,\n\n        get() {\n          const { _computed, $props, $el } = component;\n\n          if (!hasOwn(_computed, key)) {\n            _computed[key] = (cb.get || cb).call(component, $props, $el);\n          }\n\n          return _computed[key];\n        },\n\n        set(value) {\n          const { _computed } = component;\n\n          _computed[key] = cb.set ? cb.set.call(component, value) : value;\n\n          if (isUndefined(_computed[key])) {\n            delete _computed[key];\n          }\n        }\n      });\n    }\n\n    function registerEvent(component, event, key) {\n      if (!isPlainObject(event)) {\n        event = { name: key, handler: event };\n      }\n\n      let { name, el, handler, capture, passive, delegate, filter, self } = event;\n      el = isFunction(el) ? el.call(component) : el || component.$el;\n\n      if (isArray(el)) {\n        el.forEach((el) => registerEvent(component, { ...event, el }, key));\n        return;\n      }\n\n      if (!el || filter && !filter.call(component)) {\n        return;\n      }\n\n      component._events.push(\n      on(\n      el,\n      name,\n      delegate ? isString(delegate) ? delegate : delegate.call(component) : null,\n      isString(handler) ? component[handler] : handler.bind(component),\n      { passive, capture, self }));\n\n\n    }\n\n    function notIn(options, key) {\n      return options.every((arr) => !arr || !hasOwn(arr, key));\n    }\n\n    function coerce$1(type, value) {\n      if (type === Boolean) {\n        return toBoolean(value);\n      } else if (type === Number) {\n        return toNumber(value);\n      } else if (type === 'list') {\n        return toList(value);\n      }\n\n      return type ? type(value) : value;\n    }\n\n    function toList(value) {\n      return isArray(value) ?\n      value :\n      isString(value) ?\n      value.\n      split(/,(?![^(]*\\))/).\n      map((value) => isNumeric(value) ? toNumber(value) : toBoolean(value.trim())) :\n      [value];\n    }\n\n    function normalizeData({ data = {} }, { args = [], props = {} }) {\n      if (isArray(data)) {\n        data = data.slice(0, args.length).reduce((data, value, index) => {\n          if (isPlainObject(value)) {\n            assign(data, value);\n          } else {\n            data[args[index]] = value;\n          }\n          return data;\n        }, {});\n      }\n\n      for (const key in data) {\n        if (isUndefined(data[key])) {\n          delete data[key];\n        } else if (props[key]) {\n          data[key] = coerce$1(props[key], data[key]);\n        }\n      }\n\n      return data;\n    }\n\n    function initChildListObserver(component) {\n      let { el, computed } = component.$options;\n\n      if (!computed) {\n        return;\n      }\n\n      for (const key in computed) {\n        if (computed[key].document) {\n          el = el.ownerDocument;\n          break;\n        }\n      }\n\n      const observer = new MutationObserver(() => component._callWatches());\n      observer.observe(el, {\n        childList: true,\n        subtree: true\n      });\n\n      return observer;\n    }\n\n    function initPropsObserver(component) {\n      const { $options, $props } = component;\n      const { id, attrs, props, el } = $options;\n\n      if (!props || attrs === false) {\n        return;\n      }\n\n      const attributes = isArray(attrs) ? attrs : Object.keys(props);\n      const filter = attributes.map((key) => hyphenate(key)).concat(id);\n\n      const observer = new MutationObserver((records) => {\n        const data = getProps$1($options);\n        if (\n        records.some(({ attributeName }) => {\n          const prop = attributeName.replace('data-', '');\n          return (prop === id ? attributes : [camelize(prop), camelize(attributeName)]).some(\n          (prop) => !isUndefined(data[prop]) && data[prop] !== $props[prop]);\n\n        }))\n        {\n          component.$reset();\n        }\n      });\n\n      observer.observe(el, {\n        attributes: true,\n        attributeFilter: filter.concat(filter.map((key) => `data-${key}`))\n      });\n\n      return observer;\n    }\n\n    function instanceAPI (UIkit) {\n      const DATA = UIkit.data;\n\n      UIkit.prototype.$create = function (component, element, data) {\n        return UIkit[component](element, data);\n      };\n\n      UIkit.prototype.$mount = function (el) {\n        const { name } = this.$options;\n\n        if (!el[DATA]) {\n          el[DATA] = {};\n        }\n\n        if (el[DATA][name]) {\n          return;\n        }\n\n        el[DATA][name] = this;\n\n        this.$el = this.$options.el = this.$options.el || el;\n\n        if (within(el, document)) {\n          this._callConnected();\n        }\n      };\n\n      UIkit.prototype.$reset = function () {\n        this._callDisconnected();\n        this._callConnected();\n      };\n\n      UIkit.prototype.$destroy = function (removeEl = false) {\n        const { el, name } = this.$options;\n\n        if (el) {\n          this._callDisconnected();\n        }\n\n        this._callHook('destroy');\n\n        if (!(el != null && el[DATA])) {\n          return;\n        }\n\n        delete el[DATA][name];\n\n        if (!isEmpty(el[DATA])) {\n          delete el[DATA];\n        }\n\n        if (removeEl) {\n          remove$1(this.$el);\n        }\n      };\n\n      UIkit.prototype.$emit = function (e) {\n        this._callUpdate(e);\n      };\n\n      UIkit.prototype.$update = function (element = this.$el, e) {\n        UIkit.update(element, e);\n      };\n\n      UIkit.prototype.$getComponent = UIkit.getComponent;\n\n      Object.defineProperty(\n      UIkit.prototype,\n      '$container',\n      Object.getOwnPropertyDescriptor(UIkit, 'container'));\n\n    }\n\n    const components$3 = {};\n    function componentAPI (UIkit) {\n      const { data: DATA, prefix: PREFIX } = UIkit;\n\n      UIkit.component = function (name, options) {\n        name = hyphenate(name);\n        const id = PREFIX + name;\n\n        if (!options) {\n          if (isPlainObject(components$3[id])) {\n            components$3[id] = components$3[`data-${id}`] = UIkit.extend(components$3[id]);\n          }\n\n          return components$3[id];\n        }\n\n        name = camelize(name);\n\n        UIkit[name] = function (element, data) {\n          const component = UIkit.component(name);\n\n          return component.options.functional ?\n          new component({ data: isPlainObject(element) ? element : [...arguments] }) :\n          element ?\n          $$(element).map(init)[0] :\n          init();\n\n          function init(element) {\n            const instance = UIkit.getComponent(element, name);\n\n            if (instance) {\n              if (data) {\n                instance.$destroy();\n              } else {\n                return instance;\n              }\n            }\n\n            return new component({ el: element, data });\n          }\n        };\n\n        const opt = isPlainObject(options) ? { ...options } : options.options;\n\n        opt.id = id;\n        opt.name = name;\n\n        opt.install == null ? void 0 : opt.install(UIkit, opt, name);\n\n        if (UIkit._initialized && !opt.functional) {\n          requestAnimationFrame(() => UIkit[name](`[${id}],[data-${id}]`));\n        }\n\n        return components$3[id] = components$3[`data-${id}`] = isPlainObject(options) ? opt : options;\n      };\n\n      UIkit.getComponents = (element) => (element == null ? void 0 : element[DATA]) || {};\n      UIkit.getComponent = (element, name) => UIkit.getComponents(element)[name];\n\n      UIkit.connect = (node) => {\n        if (node[DATA]) {\n          for (const name in node[DATA]) {\n            node[DATA][name]._callConnected();\n          }\n        }\n\n        for (const attribute of node.getAttributeNames()) {\n          const name = getComponentName(attribute);\n          name && UIkit[name](node);\n        }\n      };\n\n      UIkit.disconnect = (node) => {\n        for (const name in node[DATA]) {\n          node[DATA][name]._callDisconnected();\n        }\n      };\n    }\n\n    function getComponentName(attribute) {\n      const cmp = components$3[attribute];\n      return cmp && (isPlainObject(cmp) ? cmp : cmp.options).name;\n    }\n\n    const UIkit = function (options) {\n      this._init(options);\n    };\n\n    UIkit.util = util;\n    UIkit.data = '__uikit__';\n    UIkit.prefix = 'uk-';\n    UIkit.options = {};\n    UIkit.version = '3.15.18';\n\n    globalAPI(UIkit);\n    hooksAPI(UIkit);\n    stateAPI(UIkit);\n    componentAPI(UIkit);\n    instanceAPI(UIkit);\n\n    function boot (UIkit) {\n      const { connect, disconnect } = UIkit;\n\n      if (!inBrowser || !window.MutationObserver) {\n        return;\n      }\n\n      requestAnimationFrame(function () {\n        trigger(document, 'uikit:init', UIkit);\n\n        if (document.body) {\n          apply(document.body, connect);\n        }\n\n        new MutationObserver((records) => records.forEach(applyChildListMutation)).observe(\n        document,\n        {\n          childList: true,\n          subtree: true\n        });\n\n\n        new MutationObserver((records) => records.forEach(applyAttributeMutation)).observe(\n        document,\n        {\n          attributes: true,\n          subtree: true\n        });\n\n\n        UIkit._initialized = true;\n      });\n\n      function applyChildListMutation({ addedNodes, removedNodes }) {\n        for (const node of addedNodes) {\n          apply(node, connect);\n        }\n\n        for (const node of removedNodes) {\n          apply(node, disconnect);\n        }\n      }\n\n      function applyAttributeMutation({ target, attributeName }) {\n        const name = getComponentName(attributeName);\n\n        if (name) {var _UIkit$getComponent;\n          if (hasAttr(target, attributeName)) {\n            UIkit[name](target);\n            return;\n          }\n\n          (_UIkit$getComponent = UIkit.getComponent(target, name)) == null ? void 0 : _UIkit$getComponent.$destroy();\n        }\n      }\n    }\n\n    var Class = {\n      connected() {\n        addClass(this.$el, this.$options.id);\n      }\n    };\n\n    var Lazyload = {\n      data: {\n        preload: 5\n      },\n\n      methods: {\n        lazyload(observeTargets = this.$el, targets = this.$el) {\n          this.registerObserver(\n          observeIntersection(observeTargets, (entries, observer) => {\n            for (const el of toNodes(isFunction(targets) ? targets() : targets)) {\n              $$('[loading=\"lazy\"]', el).\n              slice(0, this.preload - 1).\n              forEach((el) => removeAttr(el, 'loading'));\n            }\n\n            for (const el of entries.\n            filter(({ isIntersecting }) => isIntersecting).\n            map(({ target }) => target)) {\n              observer.unobserve(el);\n            }\n          }));\n\n        }\n      }\n    };\n\n    var Togglable = {\n      props: {\n        cls: Boolean,\n        animation: 'list',\n        duration: Number,\n        velocity: Number,\n        origin: String,\n        transition: String\n      },\n\n      data: {\n        cls: false,\n        animation: [false],\n        duration: 200,\n        velocity: 0.2,\n        origin: false,\n        transition: 'ease',\n        clsEnter: 'uk-togglabe-enter',\n        clsLeave: 'uk-togglabe-leave'\n      },\n\n      computed: {\n        hasAnimation({ animation }) {\n          return !!animation[0];\n        },\n\n        hasTransition({ animation }) {\n          return ['slide', 'reveal'].some((transition) => startsWith(animation[0], transition));\n        }\n      },\n\n      methods: {\n        toggleElement(targets, toggle, animate) {\n          return new Promise((resolve) => Promise.all(\n          toNodes(targets).map((el) => {\n            const show = isBoolean(toggle) ? toggle : !this.isToggled(el);\n\n            if (!trigger(el, `before${show ? 'show' : 'hide'}`, [this])) {\n              return Promise.reject();\n            }\n\n            const promise = (\n            isFunction(animate) ?\n            animate :\n            animate === false || !this.hasAnimation ?\n            toggleInstant :\n            this.hasTransition ?\n            toggleTransition :\n            toggleAnimation)(\n            el, show, this);\n\n            const cls = show ? this.clsEnter : this.clsLeave;\n\n            addClass(el, cls);\n\n            trigger(el, show ? 'show' : 'hide', [this]);\n\n            const done = () => {\n              removeClass(el, cls);\n              trigger(el, show ? 'shown' : 'hidden', [this]);\n            };\n\n            return promise ?\n            promise.then(done, () => {\n              removeClass(el, cls);\n              return Promise.reject();\n            }) :\n            done();\n          })).\n          then(resolve, noop));\n\n        },\n\n        isToggled(el = this.$el) {\n          [el] = toNodes(el);\n          return hasClass(el, this.clsEnter) ?\n          true :\n          hasClass(el, this.clsLeave) ?\n          false :\n          this.cls ?\n          hasClass(el, this.cls.split(' ')[0]) :\n          isVisible(el);\n        },\n\n        _toggle(el, toggled) {\n          if (!el) {\n            return;\n          }\n\n          toggled = Boolean(toggled);\n\n          let changed;\n          if (this.cls) {\n            changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);\n            changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);\n          } else {\n            changed = toggled === el.hidden;\n            changed && (el.hidden = !toggled);\n          }\n\n          $$('[autofocus]', el).some((el) => isVisible(el) ? el.focus() || true : el.blur());\n\n          if (changed) {\n            trigger(el, 'toggled', [toggled, this]);\n          }\n        }\n      }\n    };\n\n    function toggleInstant(el, show, { _toggle }) {\n      Animation.cancel(el);\n      Transition.cancel(el);\n      return _toggle(el, show);\n    }\n\n    async function toggleTransition(\n    el,\n    show,\n    { animation, duration, velocity, transition, _toggle })\n    {var _animation$;\n      const [mode = 'reveal', startProp = 'top'] = ((_animation$ = animation[0]) == null ? void 0 : _animation$.split('-')) || [];\n\n      const dirs = [\n      ['left', 'right'],\n      ['top', 'bottom']];\n\n      const dir = dirs[includes(dirs[0], startProp) ? 0 : 1];\n      const end = dir[1] === startProp;\n      const props = ['width', 'height'];\n      const dimProp = props[dirs.indexOf(dir)];\n      const marginProp = `margin-${dir[0]}`;\n      const marginStartProp = `margin-${startProp}`;\n\n      let currentDim = dimensions$1(el)[dimProp];\n\n      const inProgress = Transition.inProgress(el);\n      await Transition.cancel(el);\n\n      if (show) {\n        _toggle(el, true);\n      }\n\n      const prevProps = Object.fromEntries(\n      [\n      'padding',\n      'border',\n      'width',\n      'height',\n      'minWidth',\n      'minHeight',\n      'overflowY',\n      'overflowX',\n      marginProp,\n      marginStartProp].\n      map((key) => [key, el.style[key]]));\n\n\n      const dim = dimensions$1(el);\n      const currentMargin = toFloat(css(el, marginProp));\n      const marginStart = toFloat(css(el, marginStartProp));\n      const endDim = dim[dimProp] + marginStart;\n\n      if (!inProgress && !show) {\n        currentDim += marginStart;\n      }\n\n      const [wrapper] = wrapInner(el, '<div>');\n      css(wrapper, {\n        boxSizing: 'border-box',\n        height: dim.height,\n        width: dim.width,\n        ...css(el, [\n        'overflow',\n        'padding',\n        'borderTop',\n        'borderRight',\n        'borderBottom',\n        'borderLeft',\n        'borderImage',\n        marginStartProp])\n\n      });\n\n      css(el, {\n        padding: 0,\n        border: 0,\n        minWidth: 0,\n        minHeight: 0,\n        [marginStartProp]: 0,\n        width: dim.width,\n        height: dim.height,\n        overflow: 'hidden',\n        [dimProp]: currentDim\n      });\n\n      const percent = currentDim / endDim;\n      duration = (velocity * endDim + duration) * (show ? 1 - percent : percent);\n      const endProps = { [dimProp]: show ? endDim : 0 };\n\n      if (end) {\n        css(el, marginProp, endDim - currentDim + currentMargin);\n        endProps[marginProp] = show ? currentMargin : endDim + currentMargin;\n      }\n\n      if (!end ^ mode === 'reveal') {\n        css(wrapper, marginProp, -endDim + currentDim);\n        Transition.start(wrapper, { [marginProp]: show ? 0 : -endDim }, duration, transition);\n      }\n\n      try {\n        await Transition.start(el, endProps, duration, transition);\n      } finally {\n        css(el, prevProps);\n        unwrap(wrapper.firstChild);\n\n        if (!show) {\n          _toggle(el, false);\n        }\n      }\n    }\n\n    function toggleAnimation(el, show, cmp) {\n      Animation.cancel(el);\n\n      const { animation, duration, _toggle } = cmp;\n\n      if (show) {\n        _toggle(el, true);\n        return Animation.in(el, animation[0], duration, cmp.origin);\n      }\n\n      return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(() => _toggle(el, false));\n\n    }\n\n    var Accordion = {\n      mixins: [Class, Lazyload, Togglable],\n\n      props: {\n        animation: Boolean,\n        targets: String,\n        active: null,\n        collapsible: Boolean,\n        multiple: Boolean,\n        toggle: String,\n        content: String,\n        offset: Number\n      },\n\n      data: {\n        targets: '> *',\n        active: false,\n        animation: true,\n        collapsible: true,\n        multiple: false,\n        clsOpen: 'uk-open',\n        toggle: '> .uk-accordion-title',\n        content: '> .uk-accordion-content',\n        offset: 0\n      },\n\n      computed: {\n        items: {\n          get({ targets }, $el) {\n            return $$(targets, $el);\n          },\n\n          watch(items, prev) {\n            if (prev || hasClass(items, this.clsOpen)) {\n              return;\n            }\n\n            const active =\n            this.active !== false && items[Number(this.active)] ||\n            !this.collapsible && items[0];\n\n            if (active) {\n              this.toggle(active, false);\n            }\n          },\n\n          immediate: true\n        },\n\n        toggles({ toggle }) {\n          return this.items.map((item) => $(toggle, item));\n        },\n\n        contents: {\n          get({ content }) {\n            return this.items.map((item) => $(content, item));\n          },\n\n          watch(items) {\n            for (const el of items) {\n              hide(\n              el,\n              !hasClass(\n              this.items.find((item) => within(el, item)),\n              this.clsOpen));\n\n\n            }\n          },\n\n          immediate: true\n        }\n      },\n\n      connected() {\n        this.lazyload();\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return `${this.targets} ${this.$props.toggle}`;\n        },\n\n        async handler(e) {var _this$_off;\n          e.preventDefault();\n\n          (_this$_off = this._off) == null ? void 0 : _this$_off.call(this);\n          this._off = keepScrollPosition(e.target);\n          await this.toggle(index(this.toggles, e.current));\n          this._off();\n        }\n      }],\n\n\n      methods: {\n        async toggle(item, animate) {\n          item = this.items[getIndex(item, this.items)];\n          let items = [item];\n          const activeItems = filter$1(this.items, `.${this.clsOpen}`);\n\n          if (!this.multiple && !includes(activeItems, items[0])) {\n            items = items.concat(activeItems);\n          }\n\n          if (!this.collapsible && activeItems.length < 2 && includes(activeItems, item)) {\n            return;\n          }\n\n          await Promise.all(\n          items.map((el) => this.toggleElement(el, !includes(activeItems, el), (el, show) => {\n            toggleClass(el, this.clsOpen, show);\n            attr($(this.$props.toggle, el), 'aria-expanded', show);\n\n            if (animate === false || !this.animation) {\n              hide($(this.content, el), !show);\n              return;\n            }\n\n            return transition(el, show, this);\n          })));\n\n\n        }\n      }\n    };\n\n    function hide(el, hide) {\n      el && (el.hidden = hide);\n    }\n\n    async function transition(el, show, { content, duration, velocity, transition }) {var _el$_wrapper;\n      content = ((_el$_wrapper = el._wrapper) == null ? void 0 : _el$_wrapper.firstElementChild) || $(content, el);\n\n      if (!el._wrapper) {\n        el._wrapper = wrapAll(content, '<div>');\n      }\n\n      const wrapper = el._wrapper;\n      css(wrapper, 'overflow', 'hidden');\n      const currentHeight = toFloat(css(wrapper, 'height'));\n\n      await Transition.cancel(wrapper);\n      hide(content, false);\n\n      const endHeight = sumBy(\n      ['height', 'paddingTop', 'paddingBottom', 'marginTop', 'marginBottom'],\n      (prop) => css(content, prop));\n\n      const percent = currentHeight / endHeight;\n      duration = (velocity * endHeight + duration) * (show ? 1 - percent : percent);\n      css(wrapper, 'height', currentHeight);\n\n      await Transition.start(wrapper, { height: show ? endHeight : 0 }, duration, transition);\n\n      unwrap(content);\n      delete el._wrapper;\n\n      if (!show) {\n        hide(content, true);\n      }\n    }\n\n    function keepScrollPosition(el) {\n      const scrollParent = scrollParents(el)[0];\n      let frame;\n      (function scroll() {\n        frame = requestAnimationFrame(() => {\n          const { top } = el.getBoundingClientRect();\n          if (top < 0) {\n            scrollParent.scrollTop += top;\n          }\n          scroll();\n        });\n      })();\n\n      return () => requestAnimationFrame(() => cancelAnimationFrame(frame));\n    }\n\n    var alert = {\n      mixins: [Class, Togglable],\n\n      args: 'animation',\n\n      props: {\n        animation: Boolean,\n        close: String\n      },\n\n      data: {\n        animation: true,\n        selClose: '.uk-alert-close',\n        duration: 150\n      },\n\n      events: {\n        name: 'click',\n\n        delegate() {\n          return this.selClose;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.close();\n        }\n      },\n\n      methods: {\n        async close() {\n          await this.toggleElement(this.$el, false, animate$1);\n          this.$destroy(true);\n        }\n      }\n    };\n\n    function animate$1(el, show, { duration, transition, velocity }) {\n      const height = toFloat(css(el, 'height'));\n      css(el, 'height', height);\n      return Transition.start(\n      el,\n      {\n        height: 0,\n        marginTop: 0,\n        marginBottom: 0,\n        paddingTop: 0,\n        paddingBottom: 0,\n        borderTop: 0,\n        borderBottom: 0,\n        opacity: 0\n      },\n      velocity * height + duration,\n      transition);\n\n    }\n\n    var Video = {\n      args: 'autoplay',\n\n      props: {\n        automute: Boolean,\n        autoplay: Boolean\n      },\n\n      data: {\n        automute: false,\n        autoplay: true\n      },\n\n      connected() {\n        this.inView = this.autoplay === 'inview';\n\n        if (this.inView && !hasAttr(this.$el, 'preload')) {\n          this.$el.preload = 'none';\n        }\n\n        if (isTag(this.$el, 'iframe') && !hasAttr(this.$el, 'allow')) {\n          this.$el.allow = 'autoplay';\n        }\n\n        if (this.automute) {\n          mute(this.$el);\n        }\n\n        this.registerObserver(observeIntersection(this.$el, () => this.$emit(), {}, false));\n      },\n\n      update: {\n        read({ visible }) {\n          if (!isVideo(this.$el)) {\n            return false;\n          }\n\n          return {\n            prev: visible,\n            visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',\n            inView: this.inView && isInView(this.$el)\n          };\n        },\n\n        write({ prev, visible, inView }) {\n          if (!visible || this.inView && !inView) {\n            pause(this.$el);\n          } else if (this.autoplay === true && !prev || this.inView && inView) {\n            play(this.$el);\n          }\n        }\n      }\n    };\n\n    var Resize = {\n      connected() {var _this$$options$resize;\n        this.registerObserver(\n        observeResize(((_this$$options$resize = this.$options.resizeTargets) == null ? void 0 : _this$$options$resize.call(this)) || this.$el, () => this.$emit('resize')));\n\n\n      }\n    };\n\n    var cover = {\n      mixins: [Resize, Video],\n\n      props: {\n        width: Number,\n        height: Number\n      },\n\n      data: {\n        automute: true\n      },\n\n      events: {\n        'load loadedmetadata'() {\n          this.$emit('resize');\n        }\n      },\n\n      resizeTargets() {\n        return [this.$el, getPositionedParent(this.$el) || parent(this.$el)];\n      },\n\n      update: {\n        read() {\n          const { ratio, cover } = Dimensions;\n          const { $el, width, height } = this;\n\n          let dim = { width, height };\n\n          if (!dim.width || !dim.height) {\n            const intrinsic = {\n              width: $el.naturalWidth || $el.videoWidth || $el.clientWidth,\n              height: $el.naturalHeight || $el.videoHeight || $el.clientHeight\n            };\n\n            if (dim.width) {\n              dim = ratio(intrinsic, 'width', dim.width);\n            } else if (height) {\n              dim = ratio(intrinsic, 'height', dim.height);\n            } else {\n              dim = intrinsic;\n            }\n          }\n\n          const { offsetHeight: coverHeight, offsetWidth: coverWidth } =\n          getPositionedParent($el) || parent($el);\n          const coverDim = cover(dim, {\n            width: coverWidth + (coverWidth % 2 ? 1 : 0),\n            height: coverHeight + (coverHeight % 2 ? 1 : 0)\n          });\n\n          if (!coverDim.width || !coverDim.height) {\n            return false;\n          }\n\n          return coverDim;\n        },\n\n        write({ height, width }) {\n          css(this.$el, { height, width });\n        },\n\n        events: ['resize']\n      }\n    };\n\n    function getPositionedParent(el) {\n      while (el = parent(el)) {\n        if (css(el, 'position') !== 'static') {\n          return el;\n        }\n      }\n    }\n\n    var Container = {\n      props: {\n        container: Boolean\n      },\n\n      data: {\n        container: true\n      },\n\n      computed: {\n        container({ container }) {\n          return container === true && this.$container || container && $(container);\n        }\n      }\n    };\n\n    var Position = {\n      props: {\n        pos: String,\n        offset: null,\n        flip: Boolean,\n        shift: Boolean,\n        inset: Boolean\n      },\n\n      data: {\n        pos: `bottom-${isRtl ? 'right' : 'left'}`,\n        offset: false,\n        flip: true,\n        shift: true,\n        inset: false\n      },\n\n      connected() {\n        this.pos = this.$props.pos.split('-').concat('center').slice(0, 2);\n        [this.dir, this.align] = this.pos;\n        this.axis = includes(['top', 'bottom'], this.dir) ? 'y' : 'x';\n      },\n\n      methods: {\n        positionAt(element, target, boundary) {\n          let offset = [this.getPositionOffset(element), this.getShiftOffset(element)];\n          const placement = [this.flip && 'flip', this.shift && 'shift'];\n\n          const attach = {\n            element: [this.inset ? this.dir : flipPosition(this.dir), this.align],\n            target: [this.dir, this.align]\n          };\n\n          if (this.axis === 'y') {\n            for (const prop in attach) {\n              attach[prop].reverse();\n            }\n            offset.reverse();\n            placement.reverse();\n          }\n\n          const [scrollElement] = scrollParents(element, /auto|scroll/);\n          const { scrollTop, scrollLeft } = scrollElement;\n\n          // Ensure none positioned element does not generate scrollbars\n          const elDim = dimensions$1(element);\n          css(element, { top: -elDim.height, left: -elDim.width });\n\n          positionAt(element, target, {\n            attach,\n            offset,\n            boundary,\n            placement,\n            viewportOffset: this.getViewportOffset(element)\n          });\n\n          // Restore scroll position\n          scrollElement.scrollTop = scrollTop;\n          scrollElement.scrollLeft = scrollLeft;\n        },\n\n        getPositionOffset(element) {\n          return (\n            toPx(\n            this.offset === false ? css(element, '--uk-position-offset') : this.offset,\n            this.axis === 'x' ? 'width' : 'height',\n            element) * (\n\n            includes(['left', 'top'], this.dir) ? -1 : 1) * (\n            this.inset ? -1 : 1));\n\n        },\n\n        getShiftOffset(element) {\n          return this.align === 'center' ?\n          0 :\n          toPx(\n          css(element, '--uk-position-shift-offset'),\n          this.axis === 'y' ? 'width' : 'height',\n          element) * (\n          includes(['left', 'top'], this.align) ? 1 : -1);\n        },\n\n        getViewportOffset(element) {\n          return toPx(css(element, '--uk-position-viewport-offset'));\n        }\n      }\n    };\n\n    const active$1 = [];\n\n    var Modal = {\n      mixins: [Class, Container, Togglable],\n\n      props: {\n        selPanel: String,\n        selClose: String,\n        escClose: Boolean,\n        bgClose: Boolean,\n        stack: Boolean\n      },\n\n      data: {\n        cls: 'uk-open',\n        escClose: true,\n        bgClose: true,\n        overlay: true,\n        stack: false\n      },\n\n      computed: {\n        panel({ selPanel }, $el) {\n          return $(selPanel, $el);\n        },\n\n        transitionElement() {\n          return this.panel;\n        },\n\n        bgClose({ bgClose }) {\n          return bgClose && this.panel;\n        }\n      },\n\n      beforeDisconnect() {\n        if (includes(active$1, this)) {\n          this.toggleElement(this.$el, false, false);\n        }\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return `${this.selClose},a[href*=\"#\"]`;\n        },\n\n        handler(e) {\n          const { current, defaultPrevented } = e;\n          const { hash } = current;\n          if (\n          !defaultPrevented &&\n          hash &&\n          isSameSiteAnchor(current) &&\n          !within(hash, this.$el) &&\n          $(hash, document.body))\n          {\n            this.hide();\n          } else if (matches(current, this.selClose)) {\n            e.preventDefault();\n            this.hide();\n          }\n        }\n      },\n\n      {\n        name: 'toggle',\n\n        self: true,\n\n        handler(e) {\n          if (e.defaultPrevented) {\n            return;\n          }\n\n          e.preventDefault();\n\n          if (this.isToggled() === includes(active$1, this)) {\n            this.toggle();\n          }\n        }\n      },\n\n      {\n        name: 'beforeshow',\n\n        self: true,\n\n        handler(e) {\n          if (includes(active$1, this)) {\n            return false;\n          }\n\n          if (!this.stack && active$1.length) {\n            Promise.all(active$1.map((modal) => modal.hide())).then(this.show);\n            e.preventDefault();\n          } else {\n            active$1.push(this);\n          }\n        }\n      },\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          once(\n          this.$el,\n          'hide',\n          on(document, 'focusin', (e) => {\n            if (last(active$1) === this && !within(e.target, this.$el)) {\n              this.$el.focus();\n            }\n          }));\n\n\n          if (this.overlay) {\n            once(this.$el, 'hidden', preventOverscroll(this.$el), { self: true });\n            once(this.$el, 'hidden', preventBackgroundScroll(), { self: true });\n          }\n\n          if (this.stack) {\n            css(this.$el, 'zIndex', toFloat(css(this.$el, 'zIndex')) + active$1.length);\n          }\n\n          addClass(document.documentElement, this.clsPage);\n\n          if (this.bgClose) {\n            once(\n            this.$el,\n            'hide',\n            on(document, pointerDown$1, ({ target }) => {\n              if (\n              last(active$1) !== this ||\n              this.overlay && !within(target, this.$el) ||\n              within(target, this.panel))\n              {\n                return;\n              }\n\n              once(\n              document,\n              `${pointerUp$1} ${pointerCancel} scroll`,\n              ({ defaultPrevented, type, target: newTarget }) => {\n                if (\n                !defaultPrevented &&\n                type === pointerUp$1 &&\n                target === newTarget)\n                {\n                  this.hide();\n                }\n              },\n              true);\n\n            }),\n            { self: true });\n\n          }\n\n          if (this.escClose) {\n            once(\n            this.$el,\n            'hide',\n            on(document, 'keydown', (e) => {\n              if (e.keyCode === 27 && last(active$1) === this) {\n                this.hide();\n              }\n            }),\n            { self: true });\n\n          }\n        }\n      },\n\n      {\n        name: 'shown',\n\n        self: true,\n\n        handler() {\n          if (!isFocusable(this.$el)) {\n            attr(this.$el, 'tabindex', '-1');\n          }\n\n          if (!$(':focus', this.$el)) {\n            this.$el.focus();\n          }\n        }\n      },\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          if (includes(active$1, this)) {\n            active$1.splice(active$1.indexOf(this), 1);\n          }\n\n          css(this.$el, 'zIndex', '');\n\n          if (!active$1.some((modal) => modal.clsPage === this.clsPage)) {\n            removeClass(document.documentElement, this.clsPage);\n          }\n        }\n      }],\n\n\n      methods: {\n        toggle() {\n          return this.isToggled() ? this.hide() : this.show();\n        },\n\n        show() {\n          if (this.container && parent(this.$el) !== this.container) {\n            append(this.container, this.$el);\n            return new Promise((resolve) => requestAnimationFrame(() => this.show().then(resolve)));\n\n          }\n\n          return this.toggleElement(this.$el, true, animate);\n        },\n\n        hide() {\n          return this.toggleElement(this.$el, false, animate);\n        }\n      }\n    };\n\n    function animate(el, show, { transitionElement, _toggle }) {\n      return new Promise((resolve, reject) => once(el, 'show hide', () => {\n        el._reject == null ? void 0 : el._reject();\n        el._reject = reject;\n\n        _toggle(el, show);\n\n        const off = once(\n        transitionElement,\n        'transitionstart',\n        () => {\n          once(transitionElement, 'transitionend transitioncancel', resolve, {\n            self: true\n          });\n          clearTimeout(timer);\n        },\n        { self: true });\n\n\n        const timer = setTimeout(() => {\n          off();\n          resolve();\n        }, toMs(css(transitionElement, 'transitionDuration')));\n      })).\n      then(() => delete el._reject);\n    }\n\n    function toMs(time) {\n      return time ? endsWith(time, 'ms') ? toFloat(time) : toFloat(time) * 1000 : 0;\n    }\n\n    function preventOverscroll(el) {\n      if (CSS.supports('overscroll-behavior', 'contain')) {\n        const elements = [\n        el,\n        ...filterChildren(el, (child) => /auto|scroll/.test(css(child, 'overflow')))];\n\n        css(elements, 'overscrollBehavior', 'contain');\n        return () => css(elements, 'overscrollBehavior', '');\n      }\n\n      let startClientY;\n\n      const events = [\n      on(\n      el,\n      'touchstart',\n      ({ targetTouches }) => {\n        if (targetTouches.length === 1) {\n          startClientY = targetTouches[0].clientY;\n        }\n      },\n      { passive: true }),\n\n\n      on(\n      el,\n      'touchmove',\n      (e) => {\n        if (e.targetTouches.length !== 1) {\n          return;\n        }\n\n        let [scrollParent] = scrollParents(e.target, /auto|scroll/);\n        if (!within(scrollParent, el)) {\n          scrollParent = el;\n        }\n\n        const clientY = e.targetTouches[0].clientY - startClientY;\n        const { scrollTop, scrollHeight, clientHeight } = scrollParent;\n\n        if (\n        clientHeight >= scrollHeight ||\n        scrollTop === 0 && clientY > 0 ||\n        scrollHeight - scrollTop <= clientHeight && clientY < 0)\n        {\n          e.cancelable && e.preventDefault();\n        }\n      },\n      { passive: false })];\n\n\n\n      return () => events.forEach((fn) => fn());\n    }\n\n    let prevented;\n    function preventBackgroundScroll() {\n      if (prevented) {\n        return noop;\n      }\n      prevented = true;\n\n      const { scrollingElement } = document;\n      css(scrollingElement, {\n        overflowY: 'hidden',\n        touchAction: 'none',\n        paddingRight: width(window) - scrollingElement.clientWidth\n      });\n      return () => {\n        prevented = false;\n        css(scrollingElement, { overflowY: '', touchAction: '', paddingRight: '' });\n      };\n    }\n\n    function filterChildren(el, fn) {\n      const children = [];\n      apply(el, (node) => {\n        if (fn(node)) {\n          children.push(node);\n        }\n      });\n      return children;\n    }\n\n    function isSameSiteAnchor(a) {\n      return ['origin', 'pathname', 'search'].every((part) => a[part] === location[part]);\n    }\n\n    let active;\n\n    var drop = {\n      mixins: [Container, Lazyload, Position, Togglable],\n\n      args: 'pos',\n\n      props: {\n        mode: 'list',\n        toggle: Boolean,\n        boundary: Boolean,\n        boundaryX: Boolean,\n        boundaryY: Boolean,\n        target: Boolean,\n        targetX: Boolean,\n        targetY: Boolean,\n        stretch: Boolean,\n        delayShow: Number,\n        delayHide: Number,\n        autoUpdate: Boolean,\n        clsDrop: String,\n        animateOut: Boolean,\n        bgScroll: Boolean\n      },\n\n      data: {\n        mode: ['click', 'hover'],\n        toggle: '- *',\n        boundary: false,\n        boundaryX: false,\n        boundaryY: false,\n        target: false,\n        targetX: false,\n        targetY: false,\n        stretch: false,\n        delayShow: 0,\n        delayHide: 800,\n        autoUpdate: true,\n        clsDrop: false,\n        animateOut: false,\n        bgScroll: true,\n        animation: ['uk-animation-fade'],\n        cls: 'uk-open',\n        container: false\n      },\n\n      computed: {\n        boundary({ boundary, boundaryX, boundaryY }, $el) {\n          return [\n          query(boundaryX || boundary, $el) || window,\n          query(boundaryY || boundary, $el) || window];\n\n        },\n\n        target({ target, targetX, targetY }, $el) {\n          targetX = targetX || target || this.targetEl;\n          targetY = targetY || target || this.targetEl;\n\n          return [\n          targetX === true ? window : query(targetX, $el),\n          targetY === true ? window : query(targetY, $el)];\n\n        }\n      },\n\n      created() {\n        this.tracker = new MouseTracker();\n      },\n\n      beforeConnect() {\n        this.clsDrop = this.$props.clsDrop || `uk-${this.$options.name}`;\n      },\n\n      connected() {\n        addClass(this.$el, this.clsDrop);\n\n        if (this.toggle && !this.targetEl) {\n          this.targetEl = this.$create('toggle', query(this.toggle, this.$el), {\n            target: this.$el,\n            mode: this.mode\n          }).$el;\n          attr(this.targetEl, 'aria-haspopup', true);\n          this.lazyload(this.targetEl);\n        }\n\n        this._style = (({ width, height }) => ({ width, height }))(this.$el.style);\n      },\n\n      disconnected() {\n        if (this.isActive()) {\n          this.hide(false);\n          active = null;\n        }\n        css(this.$el, this._style);\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return `.${this.clsDrop}-close`;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.hide(false);\n        }\n      },\n\n      {\n        name: 'click',\n\n        delegate() {\n          return 'a[href*=\"#\"]';\n        },\n\n        handler({ defaultPrevented, current }) {\n          const { hash } = current;\n          if (\n          !defaultPrevented &&\n          hash &&\n          isSameSiteAnchor(current) &&\n          !within(hash, this.$el))\n          {\n            this.hide(false);\n          }\n        }\n      },\n\n      {\n        name: 'beforescroll',\n\n        handler() {\n          this.hide(false);\n        }\n      },\n\n      {\n        name: 'toggle',\n\n        self: true,\n\n        handler(e, toggle) {\n          e.preventDefault();\n\n          if (this.isToggled()) {\n            this.hide(false);\n          } else {\n            this.show(toggle == null ? void 0 : toggle.$el, false);\n          }\n        }\n      },\n\n      {\n        name: 'toggleshow',\n\n        self: true,\n\n        handler(e, toggle) {\n          e.preventDefault();\n          this.show(toggle == null ? void 0 : toggle.$el);\n        }\n      },\n\n      {\n        name: 'togglehide',\n\n        self: true,\n\n        handler(e) {\n          e.preventDefault();\n          if (!matches(this.$el, ':focus,:hover')) {\n            this.hide();\n          }\n        }\n      },\n\n      {\n        name: `${pointerEnter} focusin`,\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (!isTouch(e)) {\n            this.clearTimers();\n          }\n        }\n      },\n\n      {\n        name: `${pointerLeave} focusout`,\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (!isTouch(e) && e.relatedTarget) {\n            this.hide();\n          }\n        }\n      },\n\n      {\n        name: 'toggled',\n\n        self: true,\n\n        handler(e, toggled) {\n          if (!toggled) {\n            return;\n          }\n\n          this.clearTimers();\n          this.position();\n        }\n      },\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          active = this;\n\n          this.tracker.init();\n\n          const update = () => this.$emit();\n          const handlers = [\n          on(\n          document,\n          pointerDown$1,\n          ({ target }) => !within(target, this.$el) &&\n          once(\n          document,\n          `${pointerUp$1} ${pointerCancel} scroll`,\n          ({ defaultPrevented, type, target: newTarget }) => {\n            if (\n            !defaultPrevented &&\n            type === pointerUp$1 &&\n            target === newTarget &&\n            !(this.targetEl && within(target, this.targetEl)))\n            {\n              this.hide(false);\n            }\n          },\n          true)),\n\n\n\n          on(document, 'keydown', (e) => {\n            if (e.keyCode === 27) {\n              this.hide(false);\n            }\n          }),\n\n          on(window, 'resize', update),\n\n          (() => {\n            const observer = observeResize(\n            scrollParents(this.$el).concat(this.target),\n            update);\n\n            return () => observer.disconnect();\n          })(),\n\n          ...(this.autoUpdate ?\n          [\n          on([document, scrollParents(this.$el)], 'scroll', update, {\n            passive: true\n          })] :\n\n          []),\n\n          ...(this.bgScroll ?\n          [] :\n          [preventOverscroll(this.$el), preventBackgroundScroll()])];\n\n\n          once(this.$el, 'hide', () => handlers.forEach((handler) => handler()), {\n            self: true\n          });\n        }\n      },\n\n      {\n        name: 'beforehide',\n\n        self: true,\n\n        handler() {\n          this.clearTimers();\n        }\n      },\n\n      {\n        name: 'hide',\n\n        handler({ target }) {\n          if (this.$el !== target) {\n            active =\n            active === null && within(target, this.$el) && this.isToggled() ?\n            this :\n            active;\n            return;\n          }\n\n          active = this.isActive() ? null : active;\n          this.tracker.cancel();\n        }\n      }],\n\n\n      update: {\n        write() {\n          if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {\n            this.position();\n          }\n        }\n      },\n\n      methods: {\n        show(target = this.targetEl, delay = true) {\n          if (this.isToggled() && target && this.targetEl && target !== this.targetEl) {\n            this.hide(false, false);\n          }\n\n          this.targetEl = target;\n\n          this.clearTimers();\n\n          if (this.isActive()) {\n            return;\n          }\n\n          if (active) {\n            if (delay && active.isDelaying) {\n              this.showTimer = setTimeout(() => matches(target, ':hover') && this.show(), 10);\n              return;\n            }\n\n            let prev;\n            while (active && prev !== active && !within(this.$el, active.$el)) {\n              prev = active;\n              active.hide(false, false);\n            }\n          }\n\n          if (this.container && parent(this.$el) !== this.container) {\n            append(this.container, this.$el);\n          }\n\n          this.showTimer = setTimeout(\n          () => this.toggleElement(this.$el, true),\n          delay && this.delayShow || 0);\n\n        },\n\n        hide(delay = true, animate = true) {\n          const hide = () => this.toggleElement(this.$el, false, this.animateOut && animate);\n\n          this.clearTimers();\n\n          this.isDelaying = getPositionedElements(this.$el).some((el) => this.tracker.movesTo(el));\n\n\n          if (delay && this.isDelaying) {\n            this.hideTimer = setTimeout(this.hide, 50);\n          } else if (delay && this.delayHide) {\n            this.hideTimer = setTimeout(hide, this.delayHide);\n          } else {\n            hide();\n          }\n        },\n\n        clearTimers() {\n          clearTimeout(this.showTimer);\n          clearTimeout(this.hideTimer);\n          this.showTimer = null;\n          this.hideTimer = null;\n          this.isDelaying = false;\n        },\n\n        isActive() {\n          return active === this;\n        },\n\n        position() {\n          removeClass(this.$el, `${this.clsDrop}-stack`);\n          css(this.$el, this._style);\n\n          // Ensure none positioned element does not generate scrollbars\n          this.$el.hidden = true;\n\n          const viewports = this.target.map((target) => getViewport$1(this.$el, target));\n          const viewportOffset = this.getViewportOffset(this.$el);\n\n          const dirs = [\n          [0, ['x', 'width', 'left', 'right']],\n          [1, ['y', 'height', 'top', 'bottom']]];\n\n\n          for (const [i, [axis, prop]] of dirs) {\n            if (this.axis !== axis && includes([axis, true], this.stretch)) {\n              css(this.$el, {\n                [prop]: Math.min(\n                offset(this.boundary[i])[prop],\n                viewports[i][prop] - 2 * viewportOffset),\n\n                [`overflow-${axis}`]: 'auto'\n              });\n            }\n          }\n\n          const maxWidth = viewports[0].width - 2 * viewportOffset;\n\n          if (this.$el.offsetWidth > maxWidth) {\n            addClass(this.$el, `${this.clsDrop}-stack`);\n          }\n\n          css(this.$el, 'maxWidth', maxWidth);\n\n          this.$el.hidden = false;\n\n          this.positionAt(this.$el, this.target, this.boundary);\n\n          for (const [i, [axis, prop, start, end]] of dirs) {\n            if (this.axis === axis && includes([axis, true], this.stretch)) {\n              const positionOffset = Math.abs(this.getPositionOffset(this.$el));\n              const targetOffset = offset(this.target[i]);\n              const elOffset = offset(this.$el);\n\n              css(this.$el, {\n                [prop]:\n                (targetOffset[start] > elOffset[start] ?\n                targetOffset[start] -\n                Math.max(\n                offset(this.boundary[i])[start],\n                viewports[i][start] + viewportOffset) :\n\n                Math.min(\n                offset(this.boundary[i])[end],\n                viewports[i][end] - viewportOffset) -\n                targetOffset[end]) - positionOffset,\n                [`overflow-${axis}`]: 'auto'\n              });\n\n              this.positionAt(this.$el, this.target, this.boundary);\n            }\n          }\n        }\n      }\n    };\n\n    function getPositionedElements(el) {\n      const result = [];\n      apply(el, (el) => css(el, 'position') !== 'static' && result.push(el));\n      return result;\n    }\n\n    function getViewport$1(el, target) {\n      return offsetViewport(scrollParents(target).find((parent) => within(el, parent)));\n    }\n\n    var formCustom = {\n      mixins: [Class],\n\n      args: 'target',\n\n      props: {\n        target: Boolean\n      },\n\n      data: {\n        target: false\n      },\n\n      computed: {\n        input(_, $el) {\n          return $(selInput, $el);\n        },\n\n        state() {\n          return this.input.nextElementSibling;\n        },\n\n        target({ target }, $el) {\n          return (\n            target && (\n            target === true && parent(this.input) === $el && this.input.nextElementSibling ||\n            $(target, $el)));\n\n        }\n      },\n\n      update() {var _input$files;\n        const { target, input } = this;\n\n        if (!target) {\n          return;\n        }\n\n        let option;\n        const prop = isInput(target) ? 'value' : 'textContent';\n        const prev = target[prop];\n        const value = (_input$files = input.files) != null && _input$files[0] ?\n        input.files[0].name :\n        matches(input, 'select') && (\n        option = $$('option', input).filter((el) => el.selected)[0]) // eslint-disable-line prefer-destructuring\n        ? option.textContent :\n        input.value;\n\n        if (prev !== value) {\n          target[prop] = value;\n        }\n      },\n\n      events: [\n      {\n        name: 'change',\n\n        handler() {\n          this.$emit();\n        }\n      },\n\n      {\n        name: 'reset',\n\n        el() {\n          return closest(this.$el, 'form');\n        },\n\n        handler() {\n          this.$emit();\n        }\n      }]\n\n    };\n\n    var Margin = {\n      mixins: [Resize],\n\n      props: {\n        margin: String,\n        firstColumn: Boolean\n      },\n\n      data: {\n        margin: 'uk-margin-small-top',\n        firstColumn: 'uk-first-column'\n      },\n\n      resizeTargets() {\n        return [this.$el, ...toArray(this.$el.children)];\n      },\n\n      connected() {\n        this.registerObserver(\n        observeMutation(this.$el, () => this.$reset(), {\n          childList: true,\n          attributes: true,\n          attributeFilter: ['style']\n        }));\n\n      },\n\n      update: {\n        read() {\n          const rows = getRows(this.$el.children);\n\n          return {\n            rows,\n            columns: getColumns(rows)\n          };\n        },\n\n        write({ columns, rows }) {\n          for (const row of rows) {\n            for (const column of row) {\n              toggleClass(column, this.margin, rows[0] !== row);\n              toggleClass(column, this.firstColumn, columns[0].includes(column));\n            }\n          }\n        },\n\n        events: ['resize']\n      }\n    };\n\n    function getRows(items) {\n      return sortBy(items, 'top', 'bottom');\n    }\n\n    function getColumns(rows) {\n      const columns = [];\n\n      for (const row of rows) {\n        const sorted = sortBy(row, 'left', 'right');\n        for (let j = 0; j < sorted.length; j++) {\n          columns[j] = columns[j] ? columns[j].concat(sorted[j]) : sorted[j];\n        }\n      }\n\n      return isRtl ? columns.reverse() : columns;\n    }\n\n    function sortBy(items, startProp, endProp) {\n      const sorted = [[]];\n\n      for (const el of items) {\n        if (!isVisible(el)) {\n          continue;\n        }\n\n        let dim = getOffset(el);\n\n        for (let i = sorted.length - 1; i >= 0; i--) {\n          const current = sorted[i];\n\n          if (!current[0]) {\n            current.push(el);\n            break;\n          }\n\n          let startDim;\n          if (current[0].offsetParent === el.offsetParent) {\n            startDim = getOffset(current[0]);\n          } else {\n            dim = getOffset(el, true);\n            startDim = getOffset(current[0], true);\n          }\n\n          if (dim[startProp] >= startDim[endProp] - 1 && dim[startProp] !== startDim[startProp]) {\n            sorted.push([el]);\n            break;\n          }\n\n          if (dim[endProp] - 1 > startDim[startProp] || dim[startProp] === startDim[startProp]) {\n            current.push(el);\n            break;\n          }\n\n          if (i === 0) {\n            sorted.unshift([el]);\n            break;\n          }\n        }\n      }\n\n      return sorted;\n    }\n\n    function getOffset(element, offset = false) {\n      let { offsetTop, offsetLeft, offsetHeight, offsetWidth } = element;\n\n      if (offset) {\n        [offsetTop, offsetLeft] = offsetPosition(element);\n      }\n\n      return {\n        top: offsetTop,\n        left: offsetLeft,\n        bottom: offsetTop + offsetHeight,\n        right: offsetLeft + offsetWidth\n      };\n    }\n\n    var Scroll = {\n      connected() {\n        registerScrollListener(this._uid, () => this.$emit('scroll'));\n      },\n\n      disconnected() {\n        unregisterScrollListener(this._uid);\n      }\n    };\n\n    const scrollListeners = new Map();\n    let unbindScrollListener;\n    function registerScrollListener(id, listener) {\n      unbindScrollListener =\n      unbindScrollListener ||\n      on(window, 'scroll', () => scrollListeners.forEach((listener) => listener()), {\n        passive: true,\n        capture: true\n      });\n\n      scrollListeners.set(id, listener);\n    }\n\n    function unregisterScrollListener(id) {\n      scrollListeners.delete(id);\n      if (unbindScrollListener && !scrollListeners.size) {\n        unbindScrollListener();\n        unbindScrollListener = null;\n      }\n    }\n\n    var grid = {\n      extends: Margin,\n\n      mixins: [Class],\n\n      name: 'grid',\n\n      props: {\n        masonry: Boolean,\n        parallax: Number\n      },\n\n      data: {\n        margin: 'uk-grid-margin',\n        clsStack: 'uk-grid-stack',\n        masonry: false,\n        parallax: 0\n      },\n\n      connected() {\n        this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');\n        this.parallax && registerScrollListener(this._uid, () => this.$emit('scroll'));\n      },\n\n      disconnected() {\n        unregisterScrollListener(this._uid);\n      },\n\n      update: [\n      {\n        write({ columns }) {\n          toggleClass(this.$el, this.clsStack, columns.length < 2);\n        },\n\n        events: ['resize']\n      },\n\n      {\n        read(data) {\n          let { columns, rows } = data;\n\n          // Filter component makes elements positioned absolute\n          if (\n          !columns.length ||\n          !this.masonry && !this.parallax ||\n          positionedAbsolute(this.$el))\n          {\n            data.translates = false;\n            return false;\n          }\n\n          let translates = false;\n\n          const nodes = children(this.$el);\n          const columnHeights = columns.map((column) => sumBy(column, 'offsetHeight'));\n          const margin = getMarginTop(nodes, this.margin) * (rows.length - 1);\n          const elHeight = Math.max(...columnHeights) + margin;\n\n          if (this.masonry) {\n            columns = columns.map((column) => sortBy$1(column, 'offsetTop'));\n            translates = getTranslates(rows, columns);\n          }\n\n          let padding = Math.abs(this.parallax);\n          if (padding) {\n            padding = columnHeights.reduce(\n            (newPadding, hgt, i) => Math.max(\n            newPadding,\n            hgt + margin + (i % 2 ? padding : padding / 8) - elHeight),\n\n            0);\n\n          }\n\n          return { padding, columns, translates, height: translates ? elHeight : '' };\n        },\n\n        write({ height, padding }) {\n          css(this.$el, 'paddingBottom', padding || '');\n          height !== false && css(this.$el, 'height', height);\n        },\n\n        events: ['resize']\n      },\n\n      {\n        read() {\n          if (this.parallax && positionedAbsolute(this.$el)) {\n            return false;\n          }\n\n          return {\n            scrolled: this.parallax ?\n            scrolledOver(this.$el) * Math.abs(this.parallax) :\n            false\n          };\n        },\n\n        write({ columns, scrolled, translates }) {\n          if (scrolled === false && !translates) {\n            return;\n          }\n\n          columns.forEach((column, i) => column.forEach((el, j) => css(\n          el,\n          'transform',\n          !scrolled && !translates ?\n          '' :\n          `translateY(${\n      (translates && -translates[i][j]) + (\n      scrolled ? i % 2 ? scrolled : scrolled / 8 : 0)\n      }px)`)));\n\n\n\n        },\n\n        events: ['scroll', 'resize']\n      }]\n\n    };\n\n    function positionedAbsolute(el) {\n      return children(el).some((el) => css(el, 'position') === 'absolute');\n    }\n\n    function getTranslates(rows, columns) {\n      const rowHeights = rows.map((row) => Math.max(...row.map((el) => el.offsetHeight)));\n\n      return columns.map((elements) => {\n        let prev = 0;\n        return elements.map(\n        (element, row) => prev += row ? rowHeights[row - 1] - elements[row - 1].offsetHeight : 0);\n\n      });\n    }\n\n    function getMarginTop(nodes, cls) {\n      const [node] = nodes.filter((el) => hasClass(el, cls));\n\n      return toFloat(node ? css(node, 'marginTop') : css(nodes[0], 'paddingLeft'));\n    }\n\n    var heightMatch = {\n      mixins: [Resize],\n\n      args: 'target',\n\n      props: {\n        target: String,\n        row: Boolean\n      },\n\n      data: {\n        target: '> *',\n        row: true\n      },\n\n      computed: {\n        elements: {\n          get({ target }, $el) {\n            return $$(target, $el);\n          },\n\n          watch() {\n            this.$reset();\n          }\n        }\n      },\n\n      resizeTargets() {\n        return [this.$el, ...this.elements];\n      },\n\n      update: {\n        read() {\n          return {\n            rows: (this.row ? getRows(this.elements) : [this.elements]).map(match$1)\n          };\n        },\n\n        write({ rows }) {\n          for (const { heights, elements } of rows) {\n            elements.forEach((el, i) => css(el, 'minHeight', heights[i]));\n          }\n        },\n\n        events: ['resize']\n      }\n    };\n\n    function match$1(elements) {\n      if (elements.length < 2) {\n        return { heights: [''], elements };\n      }\n\n      css(elements, 'minHeight', '');\n      let heights = elements.map(getHeight);\n      const max = Math.max(...heights);\n\n      return {\n        heights: elements.map((el, i) => heights[i].toFixed(2) === max.toFixed(2) ? '' : max),\n        elements\n      };\n    }\n\n    function getHeight(element) {\n      let style = false;\n      if (!isVisible(element)) {\n        style = element.style.display;\n        css(element, 'display', 'block', 'important');\n      }\n\n      const height = dimensions$1(element).height - boxModelAdjust(element, 'height', 'content-box');\n\n      if (style !== false) {\n        css(element, 'display', style);\n      }\n\n      return height;\n    }\n\n    var heightViewport = {\n      mixins: [Resize],\n\n      props: {\n        expand: Boolean,\n        offsetTop: Boolean,\n        offsetBottom: Boolean,\n        minHeight: Number\n      },\n\n      data: {\n        expand: false,\n        offsetTop: false,\n        offsetBottom: false,\n        minHeight: 0\n      },\n\n      resizeTargets() {\n        // check for offsetTop change\n        return [this.$el, ...scrollParents(this.$el, /auto|scroll/)];\n      },\n\n      update: {\n        read({ minHeight: prev }) {\n          if (!isVisible(this.$el)) {\n            return false;\n          }\n\n          let minHeight = '';\n          const box = boxModelAdjust(this.$el, 'height', 'content-box');\n\n          const { body, scrollingElement } = document;\n          const [scrollElement] = scrollParents(this.$el, /auto|scroll/);\n          const { height: viewportHeight } = offsetViewport(\n          scrollElement === body ? scrollingElement : scrollElement);\n\n\n          if (this.expand) {\n            minHeight = Math.max(\n            viewportHeight - (\n            dimensions$1(scrollElement).height - dimensions$1(this.$el).height) -\n            box,\n            0);\n\n          } else {\n            const isScrollingElement =\n            scrollingElement === scrollElement || body === scrollElement;\n\n            // on mobile devices (iOS and Android) window.innerHeight !== 100vh\n            minHeight = `calc(${isScrollingElement ? '100vh' : `${viewportHeight}px`}`;\n\n            if (this.offsetTop) {\n              if (isScrollingElement) {\n                const top = offsetPosition(this.$el)[0] - offsetPosition(scrollElement)[0];\n                minHeight += top > 0 && top < viewportHeight / 2 ? ` - ${top}px` : '';\n              } else {\n                minHeight += ` - ${css(scrollElement, 'paddingTop')}`;\n              }\n            }\n\n            if (this.offsetBottom === true) {\n              minHeight += ` - ${dimensions$1(this.$el.nextElementSibling).height}px`;\n            } else if (isNumeric(this.offsetBottom)) {\n              minHeight += ` - ${this.offsetBottom}vh`;\n            } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {\n              minHeight += ` - ${toFloat(this.offsetBottom)}px`;\n            } else if (isString(this.offsetBottom)) {\n              minHeight += ` - ${dimensions$1(query(this.offsetBottom, this.$el)).height}px`;\n            }\n\n            minHeight += `${box ? ` - ${box}px` : ''})`;\n          }\n\n          return { minHeight, prev };\n        },\n\n        write({ minHeight }) {\n          css(this.$el, { minHeight });\n\n          if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {\n            css(this.$el, 'minHeight', this.minHeight);\n          }\n        },\n\n        events: ['resize']\n      }\n    };\n\n    var SVG = {\n      args: 'src',\n\n      props: {\n        id: Boolean,\n        icon: String,\n        src: String,\n        style: String,\n        width: Number,\n        height: Number,\n        ratio: Number,\n        class: String,\n        strokeAnimation: Boolean,\n        attributes: 'list'\n      },\n\n      data: {\n        ratio: 1,\n        include: ['style', 'class'],\n        class: '',\n        strokeAnimation: false\n      },\n\n      beforeConnect() {\n        this.class += ' uk-svg';\n      },\n\n      connected() {\n        if (!this.icon && includes(this.src, '#')) {\n          [this.src, this.icon] = this.src.split('#');\n        }\n\n        this.svg = this.getSvg().then((el) => {\n          if (this._connected) {\n            const svg = insertSVG(el, this.$el);\n\n            if (this.svgEl && svg !== this.svgEl) {\n              remove$1(this.svgEl);\n            }\n\n            this.applyAttributes(svg, el);\n\n            return this.svgEl = svg;\n          }\n        }, noop);\n\n        if (this.strokeAnimation) {\n          this.svg.then((el) => {\n            if (this._connected) {\n              applyAnimation(el);\n              this.registerObserver(\n              observeIntersection(el, (records, observer) => {\n                applyAnimation(el);\n                observer.disconnect();\n              }));\n\n            }\n          });\n        }\n      },\n\n      disconnected() {\n        this.svg.then((svg) => {\n          if (this._connected) {\n            return;\n          }\n\n          if (isVoidElement(this.$el)) {\n            this.$el.hidden = false;\n          }\n\n          remove$1(svg);\n          this.svgEl = null;\n        });\n\n        this.svg = null;\n      },\n\n      methods: {\n        async getSvg() {\n          if (isTag(this.$el, 'img') && !this.$el.complete && this.$el.loading === 'lazy') {\n            return new Promise((resolve) => once(this.$el, 'load', () => resolve(this.getSvg())));\n\n          }\n\n          return parseSVG(await loadSVG(this.src), this.icon) || Promise.reject('SVG not found.');\n        },\n\n        applyAttributes(el, ref) {\n          for (const prop in this.$options.props) {\n            if (includes(this.include, prop) && prop in this) {\n              attr(el, prop, this[prop]);\n            }\n          }\n\n          for (const attribute in this.attributes) {\n            const [prop, value] = this.attributes[attribute].split(':', 2);\n            attr(el, prop, value);\n          }\n\n          if (!this.id) {\n            removeAttr(el, 'id');\n          }\n\n          const props = ['width', 'height'];\n          let dimensions = props.map((prop) => this[prop]);\n\n          if (!dimensions.some((val) => val)) {\n            dimensions = props.map((prop) => attr(ref, prop));\n          }\n\n          const viewBox = attr(ref, 'viewBox');\n          if (viewBox && !dimensions.some((val) => val)) {\n            dimensions = viewBox.split(' ').slice(2);\n          }\n\n          dimensions.forEach((val, i) => attr(el, props[i], toFloat(val) * this.ratio || null));\n        }\n      }\n    };\n\n    const loadSVG = memoize(async (src) => {\n      if (src) {\n        if (startsWith(src, 'data:')) {\n          return decodeURIComponent(src.split(',')[1]);\n        } else {\n          return (await fetch(src)).text();\n        }\n      } else {\n        return Promise.reject();\n      }\n    });\n\n    function parseSVG(svg, icon) {var _svg;\n      if (icon && includes(svg, '<symbol')) {\n        svg = parseSymbols(svg, icon) || svg;\n      }\n\n      svg = $(svg.substr(svg.indexOf('<svg')));\n      return ((_svg = svg) == null ? void 0 : _svg.hasChildNodes()) && svg;\n    }\n\n    const symbolRe = /<symbol([^]*?id=(['\"])(.+?)\\2[^]*?<\\/)symbol>/g;\n    const symbols = {};\n\n    function parseSymbols(svg, icon) {\n      if (!symbols[svg]) {\n        symbols[svg] = {};\n\n        symbolRe.lastIndex = 0;\n\n        let match;\n        while (match = symbolRe.exec(svg)) {\n          symbols[svg][match[3]] = `<svg xmlns=\"http://www.w3.org/2000/svg\"${match[1]}svg>`;\n        }\n      }\n\n      return symbols[svg][icon];\n    }\n\n    function applyAnimation(el) {\n      const length = getMaxPathLength(el);\n\n      if (length) {\n        el.style.setProperty('--uk-animation-stroke', length);\n      }\n    }\n\n    function getMaxPathLength(el) {\n      return Math.ceil(\n      Math.max(\n      0,\n      ...$$('[stroke]', el).map((stroke) => {\n        try {\n          return stroke.getTotalLength();\n        } catch (e) {\n          return 0;\n        }\n      })));\n\n\n    }\n\n    function insertSVG(el, root) {\n      if (isVoidElement(root) || isTag(root, 'canvas')) {\n        root.hidden = true;\n\n        const next = root.nextElementSibling;\n        return equals(el, next) ? next : after(root, el);\n      }\n\n      const last = root.lastElementChild;\n      return equals(el, last) ? last : append(root, el);\n    }\n\n    function equals(el, other) {\n      return isTag(el, 'svg') && isTag(other, 'svg') && el.innerHTML === other.innerHTML;\n    }\n\n    var closeIcon = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"13\\\" y2=\\\"13\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"13\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"13\\\"/></svg>\";\n\n    var closeLarge = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"19\\\" y2=\\\"19\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" x1=\\\"19\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"19\\\"/></svg>\";\n\n    var marker = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"11\\\"/><rect x=\\\"4\\\" y=\\\"9\\\" width=\\\"11\\\" height=\\\"1\\\"/></svg>\";\n\n    var navParentIcon = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"12\\\" height=\\\"12\\\" viewBox=\\\"0 0 12 12\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"1 3.5 6 8.5 11 3.5\\\"/></svg>\";\n\n    var navParentIconLarge = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"1 4 7 10 13 4\\\"/></svg>\";\n\n    var navbarParentIcon = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"12\\\" height=\\\"12\\\" viewBox=\\\"0 0 12 12\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"1 3.5 6 8.5 11 3.5\\\"/></svg>\";\n\n    var navbarToggleIcon = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><style>.uk-navbar-toggle-animate svg>[class*=line-]{transition:.2s ease-in-out;transition-property:transform,opacity;transform-origin:center;opacity:1}.uk-navbar-toggle svg>.line-3{opacity:0}.uk-navbar-toggle-animate[aria-expanded=true] svg>.line-3{opacity:1}.uk-navbar-toggle-animate[aria-expanded=true] svg>.line-2{transform:rotate(45deg)}.uk-navbar-toggle-animate[aria-expanded=true] svg>.line-3{transform:rotate(-45deg)}.uk-navbar-toggle-animate[aria-expanded=true] svg>.line-1,.uk-navbar-toggle-animate[aria-expanded=true] svg>.line-4{opacity:0}.uk-navbar-toggle-animate[aria-expanded=true] svg>.line-1{transform:translateY(6px) scaleX(0)}.uk-navbar-toggle-animate[aria-expanded=true] svg>.line-4{transform:translateY(-6px) scaleX(0)}</style><rect class=\\\"line-1\\\" y=\\\"3\\\" width=\\\"20\\\" height=\\\"2\\\"/><rect class=\\\"line-2\\\" y=\\\"9\\\" width=\\\"20\\\" height=\\\"2\\\"/><rect class=\\\"line-3\\\" y=\\\"9\\\" width=\\\"20\\\" height=\\\"2\\\"/><rect class=\\\"line-4\\\" y=\\\"15\\\" width=\\\"20\\\" height=\\\"2\\\"/></svg>\";\n\n    var overlayIcon = \"<svg width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"19\\\" y=\\\"0\\\" width=\\\"1\\\" height=\\\"40\\\"/><rect x=\\\"0\\\" y=\\\"19\\\" width=\\\"40\\\" height=\\\"1\\\"/></svg>\";\n\n    var paginationNext = \"<svg width=\\\"7\\\" height=\\\"12\\\" viewBox=\\\"0 0 7 12\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"1 1 6 6 1 11\\\"/></svg>\";\n\n    var paginationPrevious = \"<svg width=\\\"7\\\" height=\\\"12\\\" viewBox=\\\"0 0 7 12\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"6 1 1 6 6 11\\\"/></svg>\";\n\n    var searchIcon = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9\\\" cy=\\\"9\\\" r=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M14,14 L18,18 L14,14 Z\\\"/></svg>\";\n\n    var searchLarge = \"<svg width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.8\\\" cx=\\\"17.5\\\" cy=\\\"17.5\\\" r=\\\"16.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.8\\\" x1=\\\"38\\\" y1=\\\"39\\\" x2=\\\"29\\\" y2=\\\"30\\\"/></svg>\";\n\n    var searchNavbar = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10.5\\\" cy=\\\"10.5\\\" r=\\\"9.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"23\\\" y1=\\\"23\\\" x2=\\\"17\\\" y2=\\\"17\\\"/></svg>\";\n\n    var slidenavNext = \"<svg width=\\\"14\\\" height=\\\"24\\\" viewBox=\\\"0 0 14 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" points=\\\"1.225,23 12.775,12 1.225,1 \\\"/></svg>\";\n\n    var slidenavNextLarge = \"<svg width=\\\"25\\\" height=\\\"40\\\" viewBox=\\\"0 0 25 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" points=\\\"4.002,38.547 22.527,20.024 4,1.5 \\\"/></svg>\";\n\n    var slidenavPrevious = \"<svg width=\\\"14\\\" height=\\\"24\\\" viewBox=\\\"0 0 14 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" points=\\\"12.775,1 1.225,12 12.775,23 \\\"/></svg>\";\n\n    var slidenavPreviousLarge = \"<svg width=\\\"25\\\" height=\\\"40\\\" viewBox=\\\"0 0 25 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" points=\\\"20.527,1.5 2,20.024 20.525,38.547 \\\"/></svg>\";\n\n    var spinner = \"<svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"15\\\" cy=\\\"15\\\" r=\\\"14\\\"/></svg>\";\n\n    var totop = \"<svg width=\\\"18\\\" height=\\\"10\\\" viewBox=\\\"0 0 18 10\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"1 9 9 1 17 9 \\\"/></svg>\";\n\n    const icons = {\n      spinner,\n      totop,\n      marker,\n      'close-icon': closeIcon,\n      'close-large': closeLarge,\n      'nav-parent-icon': navParentIcon,\n      'nav-parent-icon-large': navParentIconLarge,\n      'navbar-parent-icon': navbarParentIcon,\n      'navbar-toggle-icon': navbarToggleIcon,\n      'overlay-icon': overlayIcon,\n      'pagination-next': paginationNext,\n      'pagination-previous': paginationPrevious,\n      'search-icon': searchIcon,\n      'search-large': searchLarge,\n      'search-navbar': searchNavbar,\n      'slidenav-next': slidenavNext,\n      'slidenav-next-large': slidenavNextLarge,\n      'slidenav-previous': slidenavPrevious,\n      'slidenav-previous-large': slidenavPreviousLarge\n    };\n\n    const Icon = {\n      install: install$3,\n\n      extends: SVG,\n\n      args: 'icon',\n\n      props: ['icon'],\n\n      data: { include: [] },\n\n      isIcon: true,\n\n      beforeConnect() {\n        addClass(this.$el, 'uk-icon');\n      },\n\n      methods: {\n        async getSvg() {\n          const icon = getIcon(this.icon);\n\n          if (!icon) {\n            throw 'Icon not found.';\n          }\n\n          return icon;\n        }\n      }\n    };\n\n    const IconComponent = {\n      args: false,\n\n      extends: Icon,\n\n      data: (vm) => ({\n        icon: hyphenate(vm.constructor.options.name)\n      }),\n\n      beforeConnect() {\n        addClass(this.$el, this.$options.id);\n      }\n    };\n\n    const NavParentIcon = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        const icon = this.$props.icon;\n        this.icon = closest(this.$el, '.uk-nav-primary') ? `${icon}-large` : icon;\n      }\n    };\n\n    const Slidenav = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        addClass(this.$el, 'uk-slidenav');\n        const icon = this.$props.icon;\n        this.icon = hasClass(this.$el, 'uk-slidenav-large') ? `${icon}-large` : icon;\n      }\n    };\n\n    const Search = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        this.icon =\n        hasClass(this.$el, 'uk-search-icon') && parents(this.$el, '.uk-search-large').length ?\n        'search-large' :\n        parents(this.$el, '.uk-search-navbar').length ?\n        'search-navbar' :\n        this.$props.icon;\n      }\n    };\n\n    const Close = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        this.icon = `close-${hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon'}`;\n      }\n    };\n\n    const Spinner = {\n      extends: IconComponent,\n\n      methods: {\n        async getSvg() {\n          const icon = await Icon.methods.getSvg.call(this);\n\n          if (this.ratio !== 1) {\n            css($('circle', icon), 'strokeWidth', 1 / this.ratio);\n          }\n\n          return icon;\n        }\n      }\n    };\n\n    const parsed = {};\n    function install$3(UIkit) {\n      UIkit.icon.add = (name, svg) => {\n        const added = isString(name) ? { [name]: svg } : name;\n        each(added, (svg, name) => {\n          icons[name] = svg;\n          delete parsed[name];\n        });\n\n        if (UIkit._initialized) {\n          apply(document.body, (el) => each(UIkit.getComponents(el), (cmp) => {\n            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();\n          }));\n\n        }\n      };\n    }\n\n    function getIcon(icon) {\n      if (!icons[icon]) {\n        return null;\n      }\n\n      if (!parsed[icon]) {\n        parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());\n      }\n\n      return parsed[icon].cloneNode(true);\n    }\n\n    function applyRtl(icon) {\n      return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;\n    }\n\n    const nativeLazyLoad = inBrowser && 'loading' in HTMLImageElement.prototype;\n\n    var img = {\n      args: 'dataSrc',\n\n      props: {\n        dataSrc: String,\n        sources: String,\n        margin: String,\n        target: String,\n        loading: String\n      },\n\n      data: {\n        dataSrc: '',\n        sources: false,\n        margin: '50%',\n        target: false,\n        loading: 'lazy'\n      },\n\n      connected() {\n        if (this.loading !== 'lazy') {\n          this.load();\n          return;\n        }\n\n        const target = [this.$el, ...queryAll(this.$props.target, this.$el)];\n\n        if (nativeLazyLoad && isImg(this.$el)) {\n          this.$el.loading = 'lazy';\n          setSrcAttrs(this.$el);\n\n          if (target.length === 1) {\n            return;\n          }\n        }\n\n        ensureSrcAttribute(this.$el);\n\n        this.registerObserver(\n        observeIntersection(\n        target,\n        (entries, observer) => {\n          this.load();\n          observer.disconnect();\n        },\n        { rootMargin: this.margin }));\n\n\n      },\n\n      disconnected() {\n        if (this._data.image) {\n          this._data.image.onload = '';\n        }\n      },\n\n      methods: {\n        load() {\n          if (this._data.image) {\n            return this._data.image;\n          }\n\n          const image = isImg(this.$el) ?\n          this.$el :\n          getImageFromElement(this.$el, this.dataSrc, this.sources);\n\n          removeAttr(image, 'loading');\n          setSrcAttrs(this.$el, image.currentSrc);\n          return this._data.image = image;\n        }\n      }\n    };\n\n    function setSrcAttrs(el, src) {\n      if (isImg(el)) {\n        const parentNode = parent(el);\n        const elements = isPicture(parentNode) ? children(parentNode) : [el];\n        elements.forEach((el) => setSourceProps(el, el));\n      } else if (src) {\n        const change = !includes(el.style.backgroundImage, src);\n        if (change) {\n          css(el, 'backgroundImage', `url(${escape(src)})`);\n          trigger(el, createEvent('load', false));\n        }\n      }\n    }\n\n    const srcProps = ['data-src', 'data-srcset', 'sizes'];\n    function setSourceProps(sourceEl, targetEl) {\n      srcProps.forEach((prop) => {\n        const value = data(sourceEl, prop);\n        if (value) {\n          attr(targetEl, prop.replace(/^(data-)+/, ''), value);\n        }\n      });\n    }\n\n    function getImageFromElement(el, src, sources) {\n      const img = new Image();\n\n      wrapInPicture(img, sources);\n      setSourceProps(el, img);\n      img.onload = () => {\n        setSrcAttrs(el, img.currentSrc);\n      };\n      attr(img, 'src', src);\n      return img;\n    }\n\n    function wrapInPicture(img, sources) {\n      sources = parseSources(sources);\n\n      if (sources.length) {\n        const picture = fragment('<picture>');\n        for (const attrs of sources) {\n          const source = fragment('<source>');\n          attr(source, attrs);\n          append(picture, source);\n        }\n        append(picture, img);\n      }\n    }\n\n    function parseSources(sources) {\n      if (!sources) {\n        return [];\n      }\n\n      if (startsWith(sources, '[')) {\n        try {\n          sources = JSON.parse(sources);\n        } catch (e) {\n          sources = [];\n        }\n      } else {\n        sources = parseOptions(sources);\n      }\n\n      if (!isArray(sources)) {\n        sources = [sources];\n      }\n\n      return sources.filter((source) => !isEmpty(source));\n    }\n\n    function ensureSrcAttribute(el) {\n      if (isImg(el) && !hasAttr(el, 'src')) {\n        attr(el, 'src', 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>');\n      }\n    }\n\n    function isPicture(el) {\n      return isTag(el, 'picture');\n    }\n\n    function isImg(el) {\n      return isTag(el, 'img');\n    }\n\n    var Media = {\n      props: {\n        media: Boolean\n      },\n\n      data: {\n        media: false\n      },\n\n      connected() {\n        const media = toMedia(this.media, this.$el);\n        this.matchMedia = true;\n        if (media) {\n          this.mediaObj = window.matchMedia(media);\n          const handler = () => {\n            this.matchMedia = this.mediaObj.matches;\n            trigger(this.$el, createEvent('mediachange', false, true, [this.mediaObj]));\n          };\n          this.offMediaObj = on(this.mediaObj, 'change', () => {\n            handler();\n            this.$emit('resize');\n          });\n          handler();\n        }\n      },\n\n      disconnected() {var _this$offMediaObj;\n        (_this$offMediaObj = this.offMediaObj) == null ? void 0 : _this$offMediaObj.call(this);\n      }\n    };\n\n    function toMedia(value, element) {\n      if (isString(value)) {\n        if (startsWith(value, '@')) {\n          value = toFloat(css(element, `--uk-breakpoint-${value.substr(1)}`));\n        } else if (isNaN(value)) {\n          return value;\n        }\n      }\n\n      return value && isNumeric(value) ? `(min-width: ${value}px)` : '';\n    }\n\n    var leader = {\n      mixins: [Class, Media, Resize],\n\n      props: {\n        fill: String\n      },\n\n      data: {\n        fill: '',\n        clsWrapper: 'uk-leader-fill',\n        clsHide: 'uk-leader-hide',\n        attrFill: 'data-fill'\n      },\n\n      computed: {\n        fill({ fill }) {\n          return fill || css(this.$el, '--uk-leader-fill-content');\n        }\n      },\n\n      connected() {\n        [this.wrapper] = wrapInner(this.$el, `<span class=\"${this.clsWrapper}\">`);\n      },\n\n      disconnected() {\n        unwrap(this.wrapper.childNodes);\n      },\n\n      update: {\n        read() {\n          const width = Math.trunc(this.$el.offsetWidth / 2);\n\n          return {\n            width,\n            fill: this.fill,\n            hide: !this.matchMedia\n          };\n        },\n\n        write({ width, fill, hide }) {\n          toggleClass(this.wrapper, this.clsHide, hide);\n          attr(this.wrapper, this.attrFill, new Array(width).join(fill));\n        },\n\n        events: ['resize']\n      }\n    };\n\n    var modal = {\n      install: install$2,\n\n      mixins: [Modal],\n\n      data: {\n        clsPage: 'uk-modal-page',\n        selPanel: '.uk-modal-dialog',\n        selClose:\n        '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full'\n      },\n\n      events: [\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          if (hasClass(this.panel, 'uk-margin-auto-vertical')) {\n            addClass(this.$el, 'uk-flex');\n          } else {\n            css(this.$el, 'display', 'block');\n          }\n\n          height(this.$el); // force reflow\n        }\n      },\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          css(this.$el, 'display', '');\n          removeClass(this.$el, 'uk-flex');\n        }\n      }]\n\n    };\n\n    function install$2({ modal }) {\n      modal.dialog = function (content, options) {\n        const dialog = modal(\n        `<div class=\"uk-modal\"> <div class=\"uk-modal-dialog\">${content}</div> </div>`,\n        options);\n\n\n        dialog.show();\n\n        on(\n        dialog.$el,\n        'hidden',\n        async () => {\n          await Promise.resolve();\n          dialog.$destroy(true);\n        },\n        { self: true });\n\n\n        return dialog;\n      };\n\n      modal.alert = function (message, options) {\n        return openDialog(\n        ({ labels }) => `<div class=\"uk-modal-body\">${\n    isString(message) ? message : html(message)\n    }</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-primary uk-modal-close\" autofocus>${\n    labels.ok\n    }</button> </div>`,\n        options,\n        (deferred) => deferred.resolve());\n\n      };\n\n      modal.confirm = function (message, options) {\n        return openDialog(\n        ({ labels }) => `<form> <div class=\"uk-modal-body\">${isString(message) ? message : html(message)}</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">${\n    labels.cancel\n    }</button> <button class=\"uk-button uk-button-primary\" autofocus>${labels.ok}</button> </div> </form>`,\n        options,\n        (deferred) => deferred.reject());\n\n      };\n\n      modal.prompt = function (message, value, options) {\n        return openDialog(\n        ({ labels }) => `<form class=\"uk-form-stacked\"> <div class=\"uk-modal-body\"> <label>${isString(message) ? message : html(message)}</label> <input class=\"uk-input\" value=\"${value || ''}\" autofocus> </div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">${\n    labels.cancel\n    }</button> <button class=\"uk-button uk-button-primary\">${labels.ok}</button> </div> </form>`,\n        options,\n        (deferred) => deferred.resolve(null),\n        (dialog) => $('input', dialog.$el).value);\n\n      };\n\n      modal.labels = {\n        ok: 'Ok',\n        cancel: 'Cancel'\n      };\n\n      function openDialog(tmpl, options, hideFn, submitFn) {\n        options = { bgClose: false, escClose: true, labels: modal.labels, ...options };\n\n        const dialog = modal.dialog(tmpl(options), options);\n        const deferred = new Deferred();\n\n        let resolved = false;\n\n        on(dialog.$el, 'submit', 'form', (e) => {\n          e.preventDefault();\n          deferred.resolve(submitFn == null ? void 0 : submitFn(dialog));\n          resolved = true;\n          dialog.hide();\n        });\n\n        on(dialog.$el, 'hide', () => !resolved && hideFn(deferred));\n\n        deferred.promise.dialog = dialog;\n\n        return deferred.promise;\n      }\n    }\n\n    var nav = {\n      extends: Accordion,\n\n      data: {\n        targets: '> .uk-parent',\n        toggle: '> a',\n        content: '> ul'\n      }\n    };\n\n    var navbar = {\n      mixins: [Class, Container],\n\n      props: {\n        dropdown: String,\n        align: String,\n        clsDrop: String,\n        boundary: Boolean,\n        dropbar: Boolean,\n        dropbarAnchor: Boolean,\n        duration: Number,\n        mode: Boolean,\n        offset: Boolean,\n        stretch: Boolean,\n        delayShow: Boolean,\n        delayHide: Boolean,\n        target: Boolean,\n        targetX: Boolean,\n        targetY: Boolean,\n        animation: Boolean,\n        animateOut: Boolean\n      },\n\n      data: {\n        dropdown: '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle',\n        align: isRtl ? 'right' : 'left',\n        clsDrop: 'uk-navbar-dropdown',\n        boundary: true,\n        dropbar: false,\n        dropbarAnchor: false,\n        duration: 200,\n        container: false\n      },\n\n      computed: {\n        dropbarAnchor({ dropbarAnchor }, $el) {\n          return query(dropbarAnchor, $el) || $el;\n        },\n\n        dropbar: {\n          get({ dropbar }) {\n            if (!dropbar) {\n              return null;\n            }\n\n            dropbar =\n            this._dropbar ||\n            query(dropbar, this.$el) ||\n            $('+ .uk-navbar-dropbar', this.$el);\n\n            return dropbar ? dropbar : this._dropbar = $('<div></div>');\n          },\n\n          watch(dropbar) {\n            addClass(dropbar, 'uk-dropbar', 'uk-dropbar-top', 'uk-navbar-dropbar');\n          },\n\n          immediate: true\n        },\n\n        dropContainer(_, $el) {\n          return this.container || $el;\n        },\n\n        dropdowns: {\n          get({ clsDrop }, $el) {\n            const dropdowns = $$(`.${clsDrop}`, $el);\n\n            if (this.dropContainer !== $el) {\n              for (const el of $$(`.${clsDrop}`, this.dropContainer)) {var _this$getDropdown;\n                const target = (_this$getDropdown = this.getDropdown(el)) == null ? void 0 : _this$getDropdown.targetEl;\n                if (!includes(dropdowns, el) && target && within(target, this.$el)) {\n                  dropdowns.push(el);\n                }\n              }\n            }\n\n            return dropdowns;\n          },\n\n          watch(dropdowns) {\n            this.$create(\n            'drop',\n            dropdowns.filter((el) => !this.getDropdown(el)),\n            {\n              ...this.$props,\n              flip: false,\n              shift: true,\n              pos: `bottom-${this.align}`,\n              boundary: this.boundary === true ? this.$el : this.boundary\n            });\n\n          },\n\n          immediate: true\n        },\n\n        toggles: {\n          get({ dropdown }, $el) {\n            return $$(dropdown, $el);\n          },\n\n          watch() {\n            const justify = hasClass(this.$el, 'uk-navbar-justify');\n            for (const container of $$(\n            '.uk-navbar-nav, .uk-navbar-left, .uk-navbar-right',\n            this.$el))\n            {\n              css(container, 'flexGrow', justify ? $$(this.dropdown, container).length : '');\n            }\n          },\n\n          immediate: true\n        }\n      },\n\n      disconnected() {\n        this.dropbar && remove$1(this.dropbar);\n        delete this._dropbar;\n      },\n\n      events: [\n      {\n        name: 'mouseover focusin',\n\n        delegate() {\n          return this.dropdown;\n        },\n\n        handler({ current }) {\n          const active = this.getActive();\n          if (\n          active &&\n          includes(active.mode, 'hover') &&\n          active.targetEl &&\n          !within(active.targetEl, current) &&\n          !active.isDelaying)\n          {\n            active.hide(false);\n          }\n        }\n      },\n\n      {\n        name: 'keydown',\n\n        delegate() {\n          return this.dropdown;\n        },\n\n        handler(e) {\n          const { current, keyCode } = e;\n          const active = this.getActive();\n\n          if (keyCode === keyMap.DOWN && hasAttr(current, 'aria-expanded')) {\n            e.preventDefault();\n\n            if (!active || active.targetEl !== current) {\n              current.click();\n              once(this.dropContainer, 'show', ({ target }) => focusFirstFocusableElement(target));\n\n            } else {\n              focusFirstFocusableElement(active.$el);\n            }\n          }\n\n          handleNavItemNavigation(e, this.toggles, active);\n        }\n      },\n\n      {\n        name: 'keydown',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        delegate() {\n          return `.${this.clsDrop}`;\n        },\n\n        handler(e) {\n          const { current, keyCode } = e;\n\n          if (!includes(this.dropdowns, current)) {\n            return;\n          }\n\n          const active = this.getActive();\n          const elements = $$(selFocusable, current);\n          const i = findIndex(elements, (el) => matches(el, ':focus'));\n\n          if (keyCode === keyMap.UP) {\n            e.preventDefault();\n            if (i > 0) {\n              elements[i - 1].focus();\n            }\n          }\n\n          if (keyCode === keyMap.DOWN) {\n            e.preventDefault();\n            if (i < elements.length - 1) {\n              elements[i + 1].focus();\n            }\n          }\n\n          if (keyCode === keyMap.ESC) {var _active$targetEl;\n            (_active$targetEl = active.targetEl) == null ? void 0 : _active$targetEl.focus();\n          }\n\n          handleNavItemNavigation(e, this.toggles, active);\n        }\n      },\n\n      {\n        name: 'mouseleave',\n\n        el() {\n          return this.dropbar;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler() {\n          const active = this.getActive();\n\n          if (\n          active &&\n          includes(active.mode, 'hover') &&\n          !this.dropdowns.some((el) => matches(el, ':hover')))\n          {\n            active.hide();\n          }\n        }\n      },\n\n      {\n        name: 'beforeshow',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler({ target }) {\n          if (!this.isDropbarDrop(target)) {\n            return;\n          }\n\n          if (this.dropbar.previousElementSibling !== this.dropbarAnchor) {\n            after(this.dropbarAnchor, this.dropbar);\n          }\n\n          addClass(target, `${this.clsDrop}-dropbar`);\n        }\n      },\n\n      {\n        name: 'show',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler({ target }) {\n          if (!this.isDropbarDrop(target)) {\n            return;\n          }\n\n          const drop = this.getDropdown(target);\n          this._observer = observeResize([drop.$el, ...drop.target], () => {\n            const targetOffsets = parents(target, `.${this.clsDrop}`).\n            concat(target).\n            map((el) => offset(el));\n            const minTop = Math.min(...targetOffsets.map(({ top }) => top));\n            const maxBottom = Math.max(...targetOffsets.map(({ bottom }) => bottom));\n            const dropbarOffset = offset(this.dropbar);\n            css(this.dropbar, 'top', this.dropbar.offsetTop - (dropbarOffset.top - minTop));\n            this.transitionTo(\n            maxBottom - minTop + toFloat(css(target, 'marginBottom')),\n            target);\n\n          });\n        }\n      },\n\n      {\n        name: 'beforehide',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(e) {\n          const active = this.getActive();\n\n          if (\n          matches(this.dropbar, ':hover') &&\n          active.$el === e.target &&\n          !this.toggles.some((el) => active.targetEl !== el && matches(el, ':focus')))\n          {\n            e.preventDefault();\n          }\n        }\n      },\n\n      {\n        name: 'hide',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler({ target }) {var _this$_observer;\n          if (!this.isDropbarDrop(target)) {\n            return;\n          }\n\n          (_this$_observer = this._observer) == null ? void 0 : _this$_observer.disconnect();\n\n          const active = this.getActive();\n\n          if (!active || active.$el === target) {\n            this.transitionTo(0);\n          }\n        }\n      }],\n\n\n      methods: {\n        getActive() {\n          return includes(this.dropdowns, active == null ? void 0 : active.$el) && active;\n        },\n\n        transitionTo(newHeight, el) {\n          const { dropbar } = this;\n          const oldHeight = height(dropbar);\n\n          el = oldHeight < newHeight && el;\n\n          css(el, 'clipPath', `polygon(0 0,100% 0,100% ${oldHeight}px,0 ${oldHeight}px)`);\n\n          height(dropbar, oldHeight);\n\n          Transition.cancel([el, dropbar]);\n          Promise.all([\n          Transition.start(dropbar, { height: newHeight }, this.duration),\n          Transition.start(\n          el,\n          {\n            clipPath: `polygon(0 0,100% 0,100% ${newHeight}px,0 ${newHeight}px)`\n          },\n          this.duration)]).\n\n\n          catch(noop).\n          then(() => css(el, { clipPath: '' }));\n        },\n\n        getDropdown(el) {\n          return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');\n        },\n\n        isDropbarDrop(el) {\n          return this.getDropdown(el) && hasClass(el, this.clsDrop);\n        }\n      }\n    };\n\n    function handleNavItemNavigation(e, toggles, active) {\n      const { current, keyCode } = e;\n      const target = active.targetEl || current;\n      const i = toggles.indexOf(target);\n\n      // Left\n      if (keyCode === keyMap.LEFT && i > 0) {\n        active.hide == null ? void 0 : active.hide(false);\n        toggles[i - 1].focus();\n      }\n\n      // Right\n      if (keyCode === keyMap.RIGHT && i < toggles.length - 1) {\n        active.hide == null ? void 0 : active.hide(false);\n        toggles[i + 1].focus();\n      }\n\n      if (keyCode === keyMap.TAB) {\n        target.focus();\n        active.hide == null ? void 0 : active.hide(false);\n      }\n    }\n\n    function focusFirstFocusableElement(el) {\n      if (!$(':focus', el)) {var _$;\n        (_$ = $(selFocusable, el)) == null ? void 0 : _$.focus();\n      }\n    }\n\n    const keyMap = {\n      TAB: 9,\n      ESC: 27,\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      DOWN: 40\n    };\n\n    var Swipe = {\n      props: {\n        swiping: Boolean\n      },\n\n      data: {\n        swiping: true\n      },\n\n      computed: {\n        swipeTarget(props, $el) {\n          return $el;\n        }\n      },\n\n      connected() {\n        if (!this.swiping) {\n          return;\n        }\n\n        registerEvent(this, {\n          el: this.swipeTarget,\n          name: pointerDown$1,\n          passive: true,\n          handler(e) {\n            if (!isTouch(e)) {\n              return;\n            }\n\n            // Handle Swipe Gesture\n            const pos = getEventPos(e);\n            const target = 'tagName' in e.target ? e.target : parent(e.target);\n            once(document, `${pointerUp$1} ${pointerCancel} scroll`, (e) => {\n              const { x, y } = getEventPos(e);\n\n              // swipe\n              if (\n              e.type !== 'scroll' && target && x && Math.abs(pos.x - x) > 100 ||\n              y && Math.abs(pos.y - y) > 100)\n              {\n                setTimeout(() => {\n                  trigger(target, 'swipe');\n                  trigger(target, `swipe${swipeDirection(pos.x, pos.y, x, y)}`);\n                });\n              }\n            });\n          }\n        });\n      }\n    };\n\n    function swipeDirection(x1, y1, x2, y2) {\n      return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ?\n      x1 - x2 > 0 ?\n      'Left' :\n      'Right' :\n      y1 - y2 > 0 ?\n      'Up' :\n      'Down';\n    }\n\n    var offcanvas = {\n      mixins: [Modal, Swipe],\n\n      args: 'mode',\n\n      props: {\n        mode: String,\n        flip: Boolean,\n        overlay: Boolean\n      },\n\n      data: {\n        mode: 'slide',\n        flip: false,\n        overlay: false,\n        clsPage: 'uk-offcanvas-page',\n        clsContainer: 'uk-offcanvas-container',\n        selPanel: '.uk-offcanvas-bar',\n        clsFlip: 'uk-offcanvas-flip',\n        clsContainerAnimation: 'uk-offcanvas-container-animation',\n        clsSidebarAnimation: 'uk-offcanvas-bar-animation',\n        clsMode: 'uk-offcanvas',\n        clsOverlay: 'uk-offcanvas-overlay',\n        selClose: '.uk-offcanvas-close',\n        container: false\n      },\n\n      computed: {\n        clsFlip({ flip, clsFlip }) {\n          return flip ? clsFlip : '';\n        },\n\n        clsOverlay({ overlay, clsOverlay }) {\n          return overlay ? clsOverlay : '';\n        },\n\n        clsMode({ mode, clsMode }) {\n          return `${clsMode}-${mode}`;\n        },\n\n        clsSidebarAnimation({ mode, clsSidebarAnimation }) {\n          return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;\n        },\n\n        clsContainerAnimation({ mode, clsContainerAnimation }) {\n          return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;\n        },\n\n        transitionElement({ mode }) {\n          return mode === 'reveal' ? parent(this.panel) : this.panel;\n        }\n      },\n\n      update: {\n        read() {\n          if (this.isToggled() && !isVisible(this.$el)) {\n            this.hide();\n          }\n        },\n\n        events: ['resize']\n      },\n\n      events: [\n      {\n        name: 'touchmove',\n\n        self: true,\n        passive: false,\n\n        filter() {\n          return this.overlay;\n        },\n\n        handler(e) {\n          e.cancelable && e.preventDefault();\n        }\n      },\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          if (this.mode === 'reveal' && !hasClass(parent(this.panel), this.clsMode)) {\n            wrapAll(this.panel, '<div>');\n            addClass(parent(this.panel), this.clsMode);\n          }\n\n          const { body, scrollingElement } = document;\n\n          addClass(body, this.clsContainer, this.clsFlip);\n          css(body, 'touch-action', 'pan-y pinch-zoom');\n          css(this.$el, 'display', 'block');\n          css(this.panel, 'maxWidth', scrollingElement.clientWidth);\n          addClass(this.$el, this.clsOverlay);\n          addClass(\n          this.panel,\n          this.clsSidebarAnimation,\n          this.mode === 'reveal' ? '' : this.clsMode);\n\n\n          height(body); // force reflow\n          addClass(body, this.clsContainerAnimation);\n\n          this.clsContainerAnimation && suppressUserScale();\n        }\n      },\n\n      {\n        name: 'hide',\n\n        self: true,\n\n        handler() {\n          removeClass(document.body, this.clsContainerAnimation);\n          css(document.body, 'touch-action', '');\n        }\n      },\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          this.clsContainerAnimation && resumeUserScale();\n\n          if (this.mode === 'reveal') {\n            unwrap(this.panel);\n          }\n\n          removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);\n          removeClass(this.$el, this.clsOverlay);\n          css(this.$el, 'display', '');\n          css(this.panel, 'maxWidth', '');\n          removeClass(document.body, this.clsContainer, this.clsFlip);\n        }\n      },\n\n      {\n        name: 'swipeLeft swipeRight',\n\n        handler(e) {\n          if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {\n            this.hide();\n          }\n        }\n      }]\n\n    };\n\n    // Chrome in responsive mode zooms page upon opening offcanvas\n    function suppressUserScale() {\n      getViewport().content += ',user-scalable=0';\n    }\n\n    function resumeUserScale() {\n      const viewport = getViewport();\n      viewport.content = viewport.content.replace(/,user-scalable=0$/, '');\n    }\n\n    function getViewport() {\n      return (\n        $('meta[name=\"viewport\"]', document.head) || append(document.head, '<meta name=\"viewport\">'));\n\n    }\n\n    var overflowAuto = {\n      mixins: [Class, Resize],\n\n      props: {\n        selContainer: String,\n        selContent: String,\n        minHeight: Number\n      },\n\n      data: {\n        selContainer: '.uk-modal',\n        selContent: '.uk-modal-dialog',\n        minHeight: 150\n      },\n\n      computed: {\n        container({ selContainer }, $el) {\n          return closest($el, selContainer);\n        },\n\n        content({ selContent }, $el) {\n          return closest($el, selContent);\n        }\n      },\n\n      resizeTargets() {\n        return [this.container, this.content];\n      },\n\n      update: {\n        read() {\n          if (!this.content || !this.container || !isVisible(this.$el)) {\n            return false;\n          }\n\n          return {\n            max: Math.max(\n            this.minHeight,\n            height(this.container) - (dimensions$1(this.content).height - height(this.$el)))\n\n          };\n        },\n\n        write({ max }) {\n          css(this.$el, { minHeight: this.minHeight, maxHeight: max });\n        },\n\n        events: ['resize']\n      }\n    };\n\n    var responsive = {\n      mixins: [Resize],\n\n      props: ['width', 'height'],\n\n      resizeTargets() {\n        return [this.$el, parent(this.$el)];\n      },\n\n      connected() {\n        addClass(this.$el, 'uk-responsive-width');\n      },\n\n      update: {\n        read() {\n          return isVisible(this.$el) && this.width && this.height ?\n          { width: width(parent(this.$el)), height: this.height } :\n          false;\n        },\n\n        write(dim) {\n          height(\n          this.$el,\n          Dimensions.contain(\n          {\n            height: this.height,\n            width: this.width\n          },\n          dim).\n          height);\n\n        },\n\n        events: ['resize']\n      }\n    };\n\n    var scroll = {\n      props: {\n        offset: Number\n      },\n\n      data: {\n        offset: 0\n      },\n\n      connected() {\n        registerClick(this);\n      },\n\n      disconnected() {\n        unregisterClick(this);\n      },\n\n      methods: {\n        async scrollTo(el) {\n          el = el && $(el) || document.body;\n\n          if (trigger(this.$el, 'beforescroll', [this, el])) {\n            await scrollIntoView(el, { offset: this.offset });\n            trigger(this.$el, 'scrolled', [this, el]);\n          }\n        }\n      }\n    };\n\n    const components$2 = new Set();\n    function registerClick(cmp) {\n      if (!components$2.size) {\n        on(document, 'click', clickHandler);\n      }\n\n      components$2.add(cmp);\n    }\n\n    function unregisterClick(cmp) {\n      components$2.delete(cmp);\n\n      if (!components$2.size) {\n        off(document, 'click', clickHandler);\n      }\n    }\n\n    function clickHandler(e) {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      for (const component of components$2) {\n        if (within(e.target, component.$el) && isSameSiteLink(component.$el)) {\n          e.preventDefault();\n          component.scrollTo(getTargetElement(component.$el));\n        }\n      }\n    }\n\n    function isSameSiteLink(el) {\n      return ['origin', 'pathname', 'search'].every((part) => location[part] === el[part]);\n    }\n\n    function getTargetElement(el) {\n      if (isSameSiteLink(el)) {\n        return document.getElementById(decodeURIComponent(el.hash).substring(1));\n      }\n    }\n\n    var scrollspy = {\n      mixins: [Scroll],\n\n      args: 'cls',\n\n      props: {\n        cls: String,\n        target: String,\n        hidden: Boolean,\n        margin: String,\n        repeat: Boolean,\n        delay: Number\n      },\n\n      data: () => ({\n        cls: '',\n        target: false,\n        hidden: true,\n        margin: '-1px',\n        repeat: false,\n        delay: 0,\n        inViewClass: 'uk-scrollspy-inview'\n      }),\n\n      computed: {\n        elements: {\n          get({ target }, $el) {\n            return target ? $$(target, $el) : [$el];\n          },\n\n          watch(elements, prev) {\n            if (this.hidden) {\n              // use `opacity:0` instead of `visibility:hidden` to make content focusable with keyboard\n              css(filter$1(elements, `:not(.${this.inViewClass})`), 'opacity', 0);\n            }\n\n            if (!isEqual(elements, prev)) {\n              this.$reset();\n            }\n          },\n\n          immediate: true\n        }\n      },\n\n      connected() {\n        this._data.elements = new Map();\n        this.registerObserver(\n        observeIntersection(\n        this.elements,\n        (records) => {\n          const elements = this._data.elements;\n          for (const { target: el, isIntersecting } of records) {\n            if (!elements.has(el)) {\n              elements.set(el, {\n                cls: data(el, 'uk-scrollspy-class') || this.cls\n              });\n            }\n\n            const state = elements.get(el);\n            if (!this.repeat && state.show) {\n              continue;\n            }\n\n            state.show = isIntersecting;\n          }\n\n          this.$emit();\n        },\n        { rootMargin: this.margin },\n        false));\n\n\n      },\n\n      disconnected() {\n        for (const [el, state] of this._data.elements.entries()) {\n          removeClass(el, this.inViewClass, (state == null ? void 0 : state.cls) || '');\n        }\n      },\n\n      update: [\n      {\n        write(data) {\n          for (const [el, state] of data.elements.entries()) {\n            if (state.show && !state.inview && !state.queued) {\n              state.queued = true;\n\n              data.promise = (data.promise || Promise.resolve()).\n              then(() => new Promise((resolve) => setTimeout(resolve, this.delay))).\n              then(() => {\n                this.toggle(el, true);\n                setTimeout(() => {\n                  state.queued = false;\n                  this.$emit();\n                }, 300);\n              });\n            } else if (!state.show && state.inview && !state.queued && this.repeat) {\n              this.toggle(el, false);\n            }\n          }\n        }\n      }],\n\n\n      methods: {\n        toggle(el, inview) {\n          const state = this._data.elements.get(el);\n\n          if (!state) {\n            return;\n          }\n\n          state.off == null ? void 0 : state.off();\n\n          css(el, 'opacity', !inview && this.hidden ? 0 : '');\n\n          toggleClass(el, this.inViewClass, inview);\n          toggleClass(el, state.cls);\n\n          if (/\\buk-animation-/.test(state.cls)) {\n            const removeAnimationClasses = () => removeClasses(el, 'uk-animation-[\\\\w-]+');\n            if (inview) {\n              state.off = once(el, 'animationcancel animationend', removeAnimationClasses);\n            } else {\n              removeAnimationClasses();\n            }\n          }\n\n          trigger(el, inview ? 'inview' : 'outview');\n\n          state.inview = inview;\n\n          // change to `visibility: hidden` does not trigger observers\n          this.$update(el);\n        }\n      }\n    };\n\n    var scrollspyNav = {\n      mixins: [Scroll],\n\n      props: {\n        cls: String,\n        closest: String,\n        scroll: Boolean,\n        overflow: Boolean,\n        offset: Number\n      },\n\n      data: {\n        cls: 'uk-active',\n        closest: false,\n        scroll: false,\n        overflow: true,\n        offset: 0\n      },\n\n      computed: {\n        links: {\n          get(_, $el) {\n            return $$('a[href*=\"#\"]', $el).filter((el) => el.hash && isSameSiteAnchor(el));\n          },\n\n          watch(links) {\n            if (this.scroll) {\n              this.$create('scroll', links, { offset: this.offset || 0 });\n            }\n          },\n\n          immediate: true\n        },\n\n        elements({ closest: selector }) {\n          return closest(this.links, selector || '*');\n        }\n      },\n\n      update: [\n      {\n        read() {\n          const targets = this.links.map(getTargetElement).filter(Boolean);\n\n          const { length } = targets;\n\n          if (!length || !isVisible(this.$el)) {\n            return false;\n          }\n\n          const [scrollElement] = scrollParents(targets, /auto|scroll/, true);\n          const { scrollTop, scrollHeight } = scrollElement;\n          const viewport = offsetViewport(scrollElement);\n          const max = scrollHeight - viewport.height;\n          let active = false;\n\n          if (scrollTop === max) {\n            active = length - 1;\n          } else {\n            for (let i = 0; i < targets.length; i++) {\n              if (offset(targets[i]).top - viewport.top - this.offset > 0) {\n                break;\n              }\n              active = +i;\n            }\n\n            if (active === false && this.overflow) {\n              active = 0;\n            }\n          }\n\n          return { active };\n        },\n\n        write({ active }) {\n          const changed = active !== false && !hasClass(this.elements[active], this.cls);\n\n          this.links.forEach((el) => el.blur());\n          for (let i = 0; i < this.elements.length; i++) {\n            toggleClass(this.elements[i], this.cls, +i === active);\n          }\n\n          if (changed) {\n            trigger(this.$el, 'active', [active, this.elements[active]]);\n          }\n        },\n\n        events: ['scroll', 'resize']\n      }]\n\n    };\n\n    var sticky = {\n      mixins: [Class, Media, Resize, Scroll],\n\n      props: {\n        position: String,\n        top: null,\n        bottom: null,\n        start: null,\n        end: null,\n        offset: String,\n        overflowFlip: Boolean,\n        animation: String,\n        clsActive: String,\n        clsInactive: String,\n        clsFixed: String,\n        clsBelow: String,\n        selTarget: String,\n        showOnUp: Boolean,\n        targetOffset: Number\n      },\n\n      data: {\n        position: 'top',\n        top: false,\n        bottom: false,\n        start: false,\n        end: false,\n        offset: 0,\n        overflowFlip: false,\n        animation: '',\n        clsActive: 'uk-active',\n        clsInactive: '',\n        clsFixed: 'uk-sticky-fixed',\n        clsBelow: 'uk-sticky-below',\n        selTarget: '',\n        showOnUp: false,\n        targetOffset: false\n      },\n\n      computed: {\n        selTarget({ selTarget }, $el) {\n          return selTarget && $(selTarget, $el) || $el;\n        }\n      },\n\n      resizeTargets() {\n        return document.documentElement;\n      },\n\n      connected() {\n        this.start = coerce(this.start || this.top);\n        this.end = coerce(this.end || this.bottom);\n\n        this.placeholder =\n        $('+ .uk-sticky-placeholder', this.$el) ||\n        $('<div class=\"uk-sticky-placeholder\"></div>');\n        this.isFixed = false;\n        this.setActive(false);\n\n        this.registerObserver(observeResize(this.$el, () => !this.isFixed && this.$emit('resize')));\n      },\n\n      disconnected() {\n        if (this.isFixed) {\n          this.hide();\n          removeClass(this.selTarget, this.clsInactive);\n        }\n        reset(this.$el);\n\n        remove$1(this.placeholder);\n        this.placeholder = null;\n      },\n\n      events: [\n      {\n        name: 'resize',\n\n        el() {\n          return [window, window.visualViewport];\n        },\n\n        handler() {\n          this.$emit('resizeViewport');\n        }\n      },\n      {\n        name: 'load hashchange popstate',\n\n        el() {\n          return window;\n        },\n\n        filter() {\n          return this.targetOffset !== false;\n        },\n\n        handler() {\n          const { scrollingElement } = document;\n\n          if (!location.hash || scrollingElement.scrollTop === 0) {\n            return;\n          }\n\n          setTimeout(() => {\n            const targetOffset = offset($(location.hash));\n            const elOffset = offset(this.$el);\n\n            if (this.isFixed && intersectRect(targetOffset, elOffset)) {\n              scrollingElement.scrollTop =\n              targetOffset.top -\n              elOffset.height -\n              toPx(this.targetOffset, 'height', this.placeholder) -\n              toPx(this.offset, 'height', this.placeholder);\n            }\n          });\n        }\n      }],\n\n\n      update: [\n      {\n        read({ height: height$1, width, margin, sticky }, types) {\n          this.inactive = !this.matchMedia || !isVisible(this.$el);\n\n          if (this.inactive) {\n            return;\n          }\n\n          const hide = this.isFixed && types.has('resize') && !sticky;\n          if (hide) {\n            css(this.selTarget, 'transition', '0s');\n            this.hide();\n          }\n\n          if (!this.active) {\n            ({ height: height$1, width } = offset(this.$el));\n            margin = css(this.$el, 'margin');\n          }\n\n          if (hide) {\n            this.show();\n            requestAnimationFrame(() => css(this.selTarget, 'transition', ''));\n          }\n\n          const viewport = toPx('100vh', 'height');\n          const dynamicViewport = height(window);\n          const maxScrollHeight = document.scrollingElement.scrollHeight - viewport;\n\n          let position = this.position;\n          if (this.overflowFlip && height$1 > viewport) {\n            position = position === 'top' ? 'bottom' : 'top';\n          }\n\n          const referenceElement = this.isFixed ? this.placeholder : this.$el;\n          let offset$1 = toPx(this.offset, 'height', sticky ? this.$el : referenceElement);\n          if (position === 'bottom' && (height$1 < dynamicViewport || this.overflowFlip)) {\n            offset$1 += dynamicViewport - height$1;\n          }\n\n          const overflow = this.overflowFlip ? 0 : Math.max(0, height$1 + offset$1 - viewport);\n          const topOffset = offset(referenceElement).top;\n          const elHeight = offset(this.$el).height;\n\n          const start =\n          (this.start === false ?\n          topOffset :\n          parseProp(this.start, this.$el, topOffset)) - offset$1;\n          const end =\n          this.end === false ?\n          maxScrollHeight :\n          Math.min(\n          maxScrollHeight,\n          parseProp(this.end, this.$el, topOffset + height$1, true) -\n          elHeight -\n          offset$1 +\n          overflow);\n\n\n          sticky =\n          maxScrollHeight &&\n          !this.showOnUp &&\n          start + offset$1 === topOffset &&\n          end ===\n          Math.min(\n          maxScrollHeight,\n          parseProp('!*', this.$el, 0, true) - elHeight - offset$1 + overflow);\n\n\n          return {\n            start,\n            end,\n            offset: offset$1,\n            overflow,\n            topOffset,\n            height: height$1,\n            elHeight,\n            width,\n            margin,\n            top: offsetPosition(referenceElement)[0],\n            sticky\n          };\n        },\n\n        write({ height, width, margin, offset, sticky }) {\n          if (this.inactive || sticky || !this.isFixed) {\n            reset(this.$el);\n          }\n\n          if (this.inactive) {\n            return;\n          }\n\n          if (sticky) {\n            height = width = margin = 0;\n            css(this.$el, { position: 'sticky', top: offset });\n          }\n\n          const { placeholder } = this;\n\n          css(placeholder, { height, width, margin });\n\n          if (!within(placeholder, document)) {\n            placeholder.hidden = true;\n          }\n          (sticky ? before : after)(this.$el, placeholder);\n        },\n\n        events: ['resize', 'resizeViewport']\n      },\n\n      {\n        read({\n          scroll: prevScroll = 0,\n          dir: prevDir = 'down',\n          overflow,\n          overflowScroll = 0,\n          start,\n          end\n        }) {\n          const scroll = document.scrollingElement.scrollTop;\n          const dir = prevScroll <= scroll ? 'down' : 'up';\n\n          return {\n            dir,\n            prevDir,\n            scroll,\n            prevScroll,\n            offsetParentTop: offset(\n            (this.isFixed ? this.placeholder : this.$el).offsetParent).\n            top,\n            overflowScroll: clamp(\n            overflowScroll + clamp(scroll, start, end) - clamp(prevScroll, start, end),\n            0,\n            overflow)\n\n          };\n        },\n\n        write(data, types) {\n          const isScrollUpdate = types.has('scroll');\n          const {\n            initTimestamp = 0,\n            dir,\n            prevDir,\n            scroll,\n            prevScroll = 0,\n            top,\n            start,\n            topOffset,\n            height\n          } = data;\n\n          if (\n          scroll < 0 ||\n          scroll === prevScroll && isScrollUpdate ||\n          this.showOnUp && !isScrollUpdate && !this.isFixed)\n          {\n            return;\n          }\n\n          const now = Date.now();\n          if (now - initTimestamp > 300 || dir !== prevDir) {\n            data.initScroll = scroll;\n            data.initTimestamp = now;\n          }\n\n          if (\n          this.showOnUp &&\n          !this.isFixed &&\n          Math.abs(data.initScroll - scroll) <= 30 &&\n          Math.abs(prevScroll - scroll) <= 10)\n          {\n            return;\n          }\n\n          if (\n          this.inactive ||\n          scroll < start ||\n          this.showOnUp && (\n          scroll <= start ||\n          dir === 'down' && isScrollUpdate ||\n          dir === 'up' && !this.isFixed && scroll <= topOffset + height))\n          {\n            if (!this.isFixed) {\n              if (Animation.inProgress(this.$el) && top > scroll) {\n                Animation.cancel(this.$el);\n                this.hide();\n              }\n\n              return;\n            }\n\n            if (this.animation && scroll > topOffset) {\n              Animation.cancel(this.$el);\n              Animation.out(this.$el, this.animation).then(() => this.hide(), noop);\n            } else {\n              this.hide();\n            }\n          } else if (this.isFixed) {\n            this.update();\n          } else if (this.animation && scroll > topOffset) {\n            Animation.cancel(this.$el);\n            this.show();\n            Animation.in(this.$el, this.animation).catch(noop);\n          } else {\n            this.show();\n          }\n        },\n\n        events: ['resize', 'resizeViewport', 'scroll']\n      }],\n\n\n      methods: {\n        show() {\n          this.isFixed = true;\n          this.update();\n          this.placeholder.hidden = false;\n        },\n\n        hide() {\n          const { offset, sticky } = this._data;\n          this.setActive(false);\n          removeClass(this.$el, this.clsFixed, this.clsBelow);\n          if (sticky) {\n            css(this.$el, 'top', offset);\n          } else {\n            css(this.$el, {\n              position: '',\n              top: '',\n              width: '',\n              marginTop: ''\n            });\n          }\n          this.placeholder.hidden = true;\n          this.isFixed = false;\n        },\n\n        update() {\n          let {\n            width,\n            scroll = 0,\n            overflow,\n            overflowScroll = 0,\n            start,\n            end,\n            offset,\n            topOffset,\n            height,\n            elHeight,\n            offsetParentTop,\n            sticky\n          } = this._data;\n          const active = start !== 0 || scroll > start;\n\n          if (!sticky) {\n            let position = 'fixed';\n\n            if (scroll > end) {\n              offset += end - offsetParentTop;\n              position = 'absolute';\n            }\n\n            css(this.$el, { position, width });\n            css(this.$el, 'marginTop', 0, 'important');\n          }\n\n          if (overflow) {\n            offset -= overflowScroll;\n          }\n\n          css(this.$el, 'top', offset);\n\n          this.setActive(active);\n          toggleClass(\n          this.$el,\n          this.clsBelow,\n          scroll > topOffset + (sticky ? Math.min(height, elHeight) : height));\n\n          addClass(this.$el, this.clsFixed);\n        },\n\n        setActive(active) {\n          const prev = this.active;\n          this.active = active;\n          if (active) {\n            replaceClass(this.selTarget, this.clsInactive, this.clsActive);\n            prev !== active && trigger(this.$el, 'active');\n          } else {\n            replaceClass(this.selTarget, this.clsActive, this.clsInactive);\n            prev !== active && trigger(this.$el, 'inactive');\n          }\n        }\n      }\n    };\n\n    function parseProp(value, el, propOffset, padding) {\n      if (!value) {\n        return 0;\n      }\n\n      if (isNumeric(value) || isString(value) && value.match(/^-?\\d/)) {\n        return propOffset + toPx(value, 'height', el, true);\n      } else {\n        const refElement = value === true ? parent(el) : query(value, el);\n        return (\n          offset(refElement).bottom - (\n          padding && refElement && within(el, refElement) ?\n          toFloat(css(refElement, 'paddingBottom')) :\n          0));\n\n      }\n    }\n\n    function coerce(value) {\n      if (value === 'true') {\n        return true;\n      } else if (value === 'false') {\n        return false;\n      }\n      return value;\n    }\n\n    function reset(el) {\n      css(el, { position: '', top: '', marginTop: '', width: '' });\n    }\n\n    var Switcher = {\n      mixins: [Lazyload, Swipe, Togglable],\n\n      args: 'connect',\n\n      props: {\n        connect: String,\n        toggle: String,\n        itemNav: String,\n        active: Number\n      },\n\n      data: {\n        connect: '~.uk-switcher',\n        toggle: '> * > :first-child',\n        itemNav: false,\n        active: 0,\n        cls: 'uk-active',\n        attrItem: 'uk-switcher-item'\n      },\n\n      computed: {\n        connects: {\n          get({ connect }, $el) {\n            return queryAll(connect, $el);\n          },\n\n          watch(connects) {\n            if (this.swiping) {\n              css(connects, 'touchAction', 'pan-y pinch-zoom');\n            }\n          },\n\n          document: true,\n          immediate: true\n        },\n\n        connectChildren: {\n          get() {\n            return this.connects.map((el) => children(el)).flat();\n          },\n\n          watch() {\n            const index = this.index();\n            for (const el of this.connects) {\n              children(el).forEach((child, i) => toggleClass(child, this.cls, i === index));\n              this.lazyload(this.$el, children(el));\n            }\n          },\n\n          immediate: true\n        },\n\n        toggles: {\n          get({ toggle }, $el) {\n            return $$(toggle, $el).filter(\n            (el) => !matches(el, '.uk-disabled *, .uk-disabled, [disabled]'));\n\n          },\n\n          watch(toggles) {\n            const active = this.index();\n            this.show(~active ? active : toggles[this.active] || toggles[0]);\n          },\n\n          immediate: true\n        },\n\n        children() {\n          return children(this.$el).filter((child) => this.toggles.some((toggle) => within(toggle, child)));\n\n        },\n\n        swipeTarget() {\n          return this.connects;\n        }\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.toggle;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(e.current);\n        }\n      },\n\n      {\n        name: 'click',\n\n        el() {\n          return this.connects.concat(this.itemNav ? queryAll(this.itemNav, this.$el) : []);\n        },\n\n        delegate() {\n          return `[${this.attrItem}],[data-${this.attrItem}]`;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(data(e.current, this.attrItem));\n        }\n      },\n\n      {\n        name: 'swipeRight swipeLeft',\n\n        filter() {\n          return this.swiping;\n        },\n\n        el() {\n          return this.connects;\n        },\n\n        handler({ type }) {\n          this.show(endsWith(type, 'Left') ? 'next' : 'previous');\n        }\n      }],\n\n\n      methods: {\n        index() {\n          return findIndex(this.children, (el) => hasClass(el, this.cls));\n        },\n\n        show(item) {\n          const prev = this.index();\n          const next = getIndex(item, this.toggles, prev);\n          const active = getIndex(this.children[next], children(this.$el));\n          children(this.$el).forEach((child, i) => {\n            toggleClass(child, this.cls, active === i);\n            attr(this.toggles[i], 'aria-expanded', active === i);\n          });\n\n          const animate = prev >= 0 && prev !== next;\n          this.connects.forEach(async ({ children }) => {\n            await this.toggleElement(\n            toNodes(children).filter((child) => hasClass(child, this.cls)),\n            false,\n            animate);\n\n            await this.toggleElement(children[active], true, animate);\n          });\n        }\n      }\n    };\n\n    var tab = {\n      mixins: [Class],\n\n      extends: Switcher,\n\n      props: {\n        media: Boolean\n      },\n\n      data: {\n        media: 960,\n        attrItem: 'uk-tab-item'\n      },\n\n      connected() {\n        const cls = hasClass(this.$el, 'uk-tab-left') ?\n        'uk-tab-left' :\n        hasClass(this.$el, 'uk-tab-right') ?\n        'uk-tab-right' :\n        false;\n\n        if (cls) {\n          this.$create('toggle', this.$el, { cls, mode: 'media', media: this.media });\n        }\n      }\n    };\n\n    const KEY_SPACE = 32;\n\n    var toggle = {\n      mixins: [Lazyload, Media, Togglable],\n\n      args: 'target',\n\n      props: {\n        href: String,\n        target: null,\n        mode: 'list',\n        queued: Boolean\n      },\n\n      data: {\n        href: false,\n        target: false,\n        mode: 'click',\n        queued: true\n      },\n\n      computed: {\n        target: {\n          get({ href, target }, $el) {\n            target = queryAll(target || href, $el);\n            return target.length && target || [$el];\n          },\n\n          watch() {\n            this.updateAria();\n            this.lazyload(this.$el, this.target);\n          },\n\n          document: true,\n          immediate: true\n        }\n      },\n\n      connected() {\n        if (!includes(this.mode, 'media') && !isFocusable(this.$el)) {\n          attr(this.$el, 'tabindex', '0');\n        }\n      },\n\n      events: [\n      {\n        name: pointerDown$1,\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          this._preventClick = null;\n\n          if (!isTouch(e) || this._showState) {\n            return;\n          }\n\n          // Clicking a button does not give it focus on all browsers and platforms\n          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus\n          trigger(this.$el, 'focus');\n          once(\n          document,\n          pointerDown$1,\n          () => trigger(this.$el, 'blur'),\n          true,\n          (e) => !within(e.target, this.$el));\n\n\n          // Prevent initial click to prevent double toggle through focus + click\n          if (includes(this.mode, 'click')) {\n            this._preventClick = true;\n          }\n        }\n      },\n\n      {\n        name: `${pointerEnter} ${pointerLeave} focus blur`,\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (isTouch(e)) {\n            return;\n          }\n\n          const show = includes([pointerEnter, 'focus'], e.type);\n          const expanded = attr(this.$el, 'aria-expanded');\n\n          // Skip hide if still hovered or focused\n          if (\n          !show && (\n          e.type === pointerLeave && matches(this.$el, ':focus') ||\n          e.type === 'blur' && matches(this.$el, ':hover')))\n          {\n            return;\n          }\n\n          // Skip if state does not change e.g. hover + focus received\n          if (this._showState && show && expanded !== this._showState) {\n            // Ensure reset if state has changed through click\n            if (!show) {\n              this._showState = null;\n            }\n            return;\n          }\n\n          this._showState = show ? expanded : null;\n\n          this.toggle(`toggle${show ? 'show' : 'hide'}`);\n        }\n      },\n\n      {\n        name: 'keydown',\n\n        filter() {\n          return includes(this.mode, 'click') && !isTag(this.$el, 'input');\n        },\n\n        handler(e) {\n          if (e.keyCode === KEY_SPACE) {\n            e.preventDefault();\n            this.$el.click();\n          }\n        }\n      },\n\n      {\n        name: 'click',\n\n        filter() {\n          return ['click', 'hover'].some((mode) => includes(this.mode, mode));\n        },\n\n        handler(e) {\n          let link;\n          if (\n          this._preventClick ||\n          closest(e.target, 'a[href=\"#\"], a[href=\"\"]') ||\n          (link = closest(e.target, 'a[href]')) && (\n          attr(this.$el, 'aria-expanded') !== 'true' ||\n          link.hash && matches(this.target, link.hash)))\n          {\n            e.preventDefault();\n          }\n\n          if (!this._preventClick && includes(this.mode, 'click')) {\n            this.toggle();\n          }\n        }\n      },\n\n      {\n        name: 'hide show',\n\n        self: true,\n\n        el() {\n          return this.target;\n        },\n\n        handler({ target, type }) {\n          this.updateAria(target === this.target[0] && type === 'show');\n        }\n      },\n\n      {\n        name: 'mediachange',\n\n        filter() {\n          return includes(this.mode, 'media');\n        },\n\n        el() {\n          return this.target;\n        },\n\n        handler(e, mediaObj) {\n          if (mediaObj.matches ^ this.isToggled(this.target)) {\n            this.toggle();\n          }\n        }\n      }],\n\n\n      methods: {\n        async toggle(type) {\n          if (!trigger(this.target, type || 'toggle', [this])) {\n            return;\n          }\n\n          if (!this.queued) {\n            return this.toggleElement(this.target);\n          }\n\n          const leaving = this.target.filter((el) => hasClass(el, this.clsLeave));\n\n          if (leaving.length) {\n            for (const el of this.target) {\n              const isLeaving = includes(leaving, el);\n              this.toggleElement(el, isLeaving, isLeaving);\n            }\n            return;\n          }\n\n          const toggled = this.target.filter(this.isToggled);\n          await this.toggleElement(toggled, false);\n          await this.toggleElement(\n          this.target.filter((el) => !includes(toggled, el)),\n          true);\n\n        },\n\n        updateAria(toggled) {\n          if (includes(this.mode, 'media')) {\n            return;\n          }\n\n          attr(\n          this.$el,\n          'aria-expanded',\n          isBoolean(toggled) ? toggled : this.isToggled(this.target));\n\n        }\n      }\n    };\n\n    var components$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Accordion: Accordion,\n        Alert: alert,\n        Cover: cover,\n        Drop: drop,\n        Dropdown: drop,\n        FormCustom: formCustom,\n        Grid: grid,\n        HeightMatch: heightMatch,\n        HeightViewport: heightViewport,\n        Icon: Icon,\n        Img: img,\n        Leader: leader,\n        Margin: Margin,\n        Modal: modal,\n        Nav: nav,\n        Navbar: navbar,\n        Offcanvas: offcanvas,\n        OverflowAuto: overflowAuto,\n        Responsive: responsive,\n        Scroll: scroll,\n        Scrollspy: scrollspy,\n        ScrollspyNav: scrollspyNav,\n        Sticky: sticky,\n        Svg: SVG,\n        Switcher: Switcher,\n        Tab: tab,\n        Toggle: toggle,\n        Video: Video,\n        Close: Close,\n        Spinner: Spinner,\n        NavParentIcon: NavParentIcon,\n        SlidenavNext: Slidenav,\n        SlidenavPrevious: Slidenav,\n        SearchIcon: Search,\n        Marker: IconComponent,\n        NavbarParentIcon: IconComponent,\n        NavbarToggleIcon: IconComponent,\n        OverlayIcon: IconComponent,\n        PaginationNext: IconComponent,\n        PaginationPrevious: IconComponent,\n        Totop: IconComponent\n    });\n\n    // register components\n    each(components$1, (component, name) => UIkit.component(name, component));\n\n    boot(UIkit);\n\n    const units = ['days', 'hours', 'minutes', 'seconds'];\n\n    var countdown = {\n      mixins: [Class],\n\n      props: {\n        date: String,\n        clsWrapper: String\n      },\n\n      data: {\n        date: '',\n        clsWrapper: '.uk-countdown-%unit%'\n      },\n\n      connected() {\n        this.date = Date.parse(this.$props.date);\n        this.start();\n      },\n\n      disconnected() {\n        this.stop();\n      },\n\n      events: [\n      {\n        name: 'visibilitychange',\n\n        el() {\n          return document;\n        },\n\n        handler() {\n          if (document.hidden) {\n            this.stop();\n          } else {\n            this.start();\n          }\n        }\n      }],\n\n\n      methods: {\n        start() {\n          this.stop();\n          this.update();\n          this.timer = setInterval(this.update, 1000);\n        },\n\n        stop() {\n          clearInterval(this.timer);\n        },\n\n        update() {\n          const timespan = getTimeSpan(this.date);\n\n          if (!this.date || timespan.total <= 0) {\n            this.stop();\n\n            timespan.days = timespan.hours = timespan.minutes = timespan.seconds = 0;\n          }\n\n          for (const unit of units) {\n            const el = $(this.clsWrapper.replace('%unit%', unit), this.$el);\n\n            if (!el) {\n              continue;\n            }\n\n            let digits = String(Math.trunc(timespan[unit]));\n\n            digits = digits.length < 2 ? `0${digits}` : digits;\n\n            if (el.textContent !== digits) {\n              digits = digits.split('');\n\n              if (digits.length !== el.children.length) {\n                html(el, digits.map(() => '<span></span>').join(''));\n              }\n\n              digits.forEach((digit, i) => el.children[i].textContent = digit);\n            }\n          }\n        }\n      }\n    };\n\n    function getTimeSpan(date) {\n      const total = date - Date.now();\n\n      return {\n        total,\n        seconds: total / 1000 % 60,\n        minutes: total / 1000 / 60 % 60,\n        hours: total / 1000 / 60 / 60 % 24,\n        days: total / 1000 / 60 / 60 / 24\n      };\n    }\n\n    const clsLeave = 'uk-transition-leave';\n    const clsEnter = 'uk-transition-enter';\n\n    function fade(action, target, duration, stagger = 0) {\n      const index = transitionIndex(target, true);\n      const propsIn = { opacity: 1 };\n      const propsOut = { opacity: 0 };\n\n      const wrapIndexFn = (fn) => () => index === transitionIndex(target) ? fn() : Promise.reject();\n\n      const leaveFn = wrapIndexFn(async () => {\n        addClass(target, clsLeave);\n\n        await Promise.all(\n        getTransitionNodes(target).map(\n        (child, i) => new Promise((resolve) => setTimeout(\n        () => Transition.start(child, propsOut, duration / 2, 'ease').then(\n        resolve),\n\n        i * stagger))));\n\n\n\n\n\n        removeClass(target, clsLeave);\n      });\n\n      const enterFn = wrapIndexFn(async () => {\n        const oldHeight = height(target);\n\n        addClass(target, clsEnter);\n        action();\n\n        css(children(target), { opacity: 0 });\n\n        // Ensure UIkit updates have propagated\n        await awaitFrame$1();\n\n        const nodes = children(target);\n        const newHeight = height(target);\n\n        // Ensure Grid cells do not stretch when height is applied\n        css(target, 'alignContent', 'flex-start');\n        height(target, oldHeight);\n\n        const transitionNodes = getTransitionNodes(target);\n        css(nodes, propsOut);\n\n        const transitions = transitionNodes.map(async (child, i) => {\n          await awaitTimeout(i * stagger);\n          await Transition.start(child, propsIn, duration / 2, 'ease');\n        });\n\n        if (oldHeight !== newHeight) {\n          transitions.push(\n          Transition.start(\n          target,\n          { height: newHeight },\n          duration / 2 + transitionNodes.length * stagger,\n          'ease'));\n\n\n        }\n\n        await Promise.all(transitions).then(() => {\n          removeClass(target, clsEnter);\n          if (index === transitionIndex(target)) {\n            css(target, { height: '', alignContent: '' });\n            css(nodes, { opacity: '' });\n            delete target.dataset.transition;\n          }\n        });\n      });\n\n      return hasClass(target, clsLeave) ?\n      waitTransitionend(target).then(enterFn) :\n      hasClass(target, clsEnter) ?\n      waitTransitionend(target).then(leaveFn).then(enterFn) :\n      leaveFn().then(enterFn);\n    }\n\n    function transitionIndex(target, next) {\n      if (next) {\n        target.dataset.transition = 1 + transitionIndex(target);\n      }\n\n      return toNumber(target.dataset.transition) || 0;\n    }\n\n    function waitTransitionend(target) {\n      return Promise.all(\n      children(target).\n      filter(Transition.inProgress).\n      map(\n      (el) => new Promise((resolve) => once(el, 'transitionend transitioncanceled', resolve))));\n\n\n    }\n\n    function getTransitionNodes(target) {\n      return getRows(children(target)).reduce(\n      (nodes, row) => nodes.concat(\n      sortBy$1(\n      row.filter((el) => isInView(el)),\n      'offsetLeft')),\n\n\n      []);\n\n    }\n\n    function awaitFrame$1() {\n      return new Promise((resolve) => requestAnimationFrame(resolve));\n    }\n\n    function awaitTimeout(timeout) {\n      return new Promise((resolve) => setTimeout(resolve, timeout));\n    }\n\n    async function slide (action, target, duration) {\n      await awaitFrame();\n\n      let nodes = children(target);\n\n      // Get current state\n      const currentProps = nodes.map((el) => getProps(el, true));\n      const targetProps = { ...css(target, ['height', 'padding']), display: 'block' };\n\n      // Cancel previous animations\n      await Promise.all(nodes.concat(target).map(Transition.cancel));\n\n      // Adding, sorting, removing nodes\n      action();\n\n      // Find new nodes\n      nodes = nodes.concat(children(target).filter((el) => !includes(nodes, el)));\n\n      // Wait for update to propagate\n      await Promise.resolve();\n\n      // Force update\n      fastdom.flush();\n\n      // Get new state\n      const targetStyle = attr(target, 'style');\n      const targetPropsTo = css(target, ['height', 'padding']);\n      const [propsTo, propsFrom] = getTransitionProps(target, nodes, currentProps);\n      const attrsTo = nodes.map((el) => ({ style: attr(el, 'style') }));\n\n      // Reset to previous state\n      nodes.forEach((el, i) => propsFrom[i] && css(el, propsFrom[i]));\n      css(target, targetProps);\n\n      // Start transitions on next frame\n      await awaitFrame();\n\n      const transitions = nodes.\n      map((el, i) => parent(el) === target && Transition.start(el, propsTo[i], duration, 'ease')).\n      concat(Transition.start(target, targetPropsTo, duration, 'ease'));\n\n      try {\n        await Promise.all(transitions);\n        nodes.forEach((el, i) => {\n          attr(el, attrsTo[i]);\n          if (parent(el) === target) {\n            css(el, 'display', propsTo[i].opacity === 0 ? 'none' : '');\n          }\n        });\n        attr(target, 'style', targetStyle);\n      } catch (e) {\n        attr(nodes, 'style', '');\n        resetProps(target, targetProps);\n      }\n    }\n\n    function getProps(el, opacity) {\n      const zIndex = css(el, 'zIndex');\n\n      return isVisible(el) ?\n      {\n        display: '',\n        opacity: opacity ? css(el, 'opacity') : '0',\n        pointerEvents: 'none',\n        position: 'absolute',\n        zIndex: zIndex === 'auto' ? index(el) : zIndex,\n        ...getPositionWithMargin(el)\n      } :\n      false;\n    }\n\n    function getTransitionProps(target, nodes, currentProps) {\n      const propsTo = nodes.map((el, i) => parent(el) && i in currentProps ?\n      currentProps[i] ?\n      isVisible(el) ?\n      getPositionWithMargin(el) :\n      { opacity: 0 } :\n      { opacity: isVisible(el) ? 1 : 0 } :\n      false);\n\n\n      const propsFrom = propsTo.map((props, i) => {\n        const from = parent(nodes[i]) === target && (currentProps[i] || getProps(nodes[i]));\n\n        if (!from) {\n          return false;\n        }\n\n        if (!props) {\n          delete from.opacity;\n        } else if (!('opacity' in props)) {\n          const { opacity } = from;\n\n          if (opacity % 1) {\n            props.opacity = 1;\n          } else {\n            delete from.opacity;\n          }\n        }\n\n        return from;\n      });\n\n      return [propsTo, propsFrom];\n    }\n\n    function resetProps(el, props) {\n      for (const prop in props) {\n        css(el, prop, '');\n      }\n    }\n\n    function getPositionWithMargin(el) {\n      const { height, width } = offset(el);\n\n      return {\n        height,\n        width,\n        transform: '',\n        ...position(el),\n        ...css(el, ['marginTop', 'marginLeft'])\n      };\n    }\n\n    function awaitFrame() {\n      return new Promise((resolve) => requestAnimationFrame(resolve));\n    }\n\n    var Animate = {\n      props: {\n        duration: Number,\n        animation: Boolean\n      },\n\n      data: {\n        duration: 150,\n        animation: 'slide'\n      },\n\n      methods: {\n        animate(action, target = this.$el) {\n          const name = this.animation;\n          const animationFn =\n          name === 'fade' ?\n          fade :\n          name === 'delayed-fade' ?\n          (...args) => fade(...args, 40) :\n          name ?\n          slide :\n          () => {\n            action();\n            return Promise.resolve();\n          };\n\n          return animationFn(action, target, this.duration).catch(noop);\n        }\n      }\n    };\n\n    var filter = {\n      mixins: [Animate],\n\n      args: 'target',\n\n      props: {\n        target: Boolean,\n        selActive: Boolean\n      },\n\n      data: {\n        target: null,\n        selActive: false,\n        attrItem: 'uk-filter-control',\n        cls: 'uk-active',\n        duration: 250\n      },\n\n      computed: {\n        toggles: {\n          get({ attrItem }, $el) {\n            return $$(`[${attrItem}],[data-${attrItem}]`, $el);\n          },\n\n          watch() {\n            this.updateState();\n\n            if (this.selActive !== false) {\n              const actives = $$(this.selActive, this.$el);\n              this.toggles.forEach((el) => toggleClass(el, this.cls, includes(actives, el)));\n            }\n          },\n\n          immediate: true\n        },\n\n        children: {\n          get({ target }, $el) {\n            return $$(`${target} > *`, $el);\n          },\n\n          watch(list, old) {\n            if (old && !isEqualList(list, old)) {\n              this.updateState();\n            }\n          },\n\n          immediate: true\n        }\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return `[${this.attrItem}],[data-${this.attrItem}]`;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.apply(e.current);\n        }\n      }],\n\n\n      methods: {\n        apply(el) {\n          const prevState = this.getState();\n          const newState = mergeState(el, this.attrItem, this.getState());\n\n          if (!isEqualState(prevState, newState)) {\n            this.setState(newState);\n          }\n        },\n\n        getState() {\n          return this.toggles.\n          filter((item) => hasClass(item, this.cls)).\n          reduce((state, el) => mergeState(el, this.attrItem, state), {\n            filter: { '': '' },\n            sort: []\n          });\n        },\n\n        async setState(state, animate = true) {\n          state = { filter: { '': '' }, sort: [], ...state };\n\n          trigger(this.$el, 'beforeFilter', [this, state]);\n\n          this.toggles.forEach((el) => toggleClass(el, this.cls, !!matchFilter(el, this.attrItem, state)));\n\n\n          await Promise.all(\n          $$(this.target, this.$el).map((target) => {\n            const filterFn = () => {\n              applyState(state, target, children(target));\n              this.$update(this.$el);\n            };\n            return animate ? this.animate(filterFn, target) : filterFn();\n          }));\n\n\n          trigger(this.$el, 'afterFilter', [this]);\n        },\n\n        updateState() {\n          fastdom.write(() => this.setState(this.getState(), false));\n        }\n      }\n    };\n\n    function getFilter(el, attr) {\n      return parseOptions(data(el, attr), ['filter']);\n    }\n\n    function isEqualState(stateA, stateB) {\n      return ['filter', 'sort'].every((prop) => isEqual(stateA[prop], stateB[prop]));\n    }\n\n    function applyState(state, target, children) {\n      const selector = getSelector(state);\n\n      children.forEach((el) => css(el, 'display', selector && !matches(el, selector) ? 'none' : ''));\n\n      const [sort, order] = state.sort;\n\n      if (sort) {\n        const sorted = sortItems(children, sort, order);\n        if (!isEqual(sorted, children)) {\n          append(target, sorted);\n        }\n      }\n    }\n\n    function mergeState(el, attr, state) {\n      const { filter, group, sort, order = 'asc' } = getFilter(el, attr);\n\n      if (filter || isUndefined(sort)) {\n        if (group) {\n          if (filter) {\n            delete state.filter[''];\n            state.filter[group] = filter;\n          } else {\n            delete state.filter[group];\n\n            if (isEmpty(state.filter) || '' in state.filter) {\n              state.filter = { '': filter || '' };\n            }\n          }\n        } else {\n          state.filter = { '': filter || '' };\n        }\n      }\n\n      if (!isUndefined(sort)) {\n        state.sort = [sort, order];\n      }\n\n      return state;\n    }\n\n    function matchFilter(\n    el,\n    attr,\n    { filter: stateFilter = { '': '' }, sort: [stateSort, stateOrder] })\n    {\n      const { filter = '', group = '', sort, order = 'asc' } = getFilter(el, attr);\n\n      return isUndefined(sort) ?\n      group in stateFilter && filter === stateFilter[group] ||\n      !filter && group && !(group in stateFilter) && !stateFilter[''] :\n      stateSort === sort && stateOrder === order;\n    }\n\n    function isEqualList(listA, listB) {\n      return listA.length === listB.length && listA.every((el) => listB.includes(el));\n    }\n\n    function getSelector({ filter }) {\n      let selector = '';\n      each(filter, (value) => selector += value || '');\n      return selector;\n    }\n\n    function sortItems(nodes, sort, order) {\n      return [...nodes].sort(\n      (a, b) => data(a, sort).localeCompare(data(b, sort), undefined, { numeric: true }) * (\n      order === 'asc' || -1));\n\n    }\n\n    var Animations$2 = {\n      slide: {\n        show(dir) {\n          return [{ transform: translate(dir * -100) }, { transform: translate() }];\n        },\n\n        percent(current) {\n          return translated(current);\n        },\n\n        translate(percent, dir) {\n          return [\n          { transform: translate(dir * -100 * percent) },\n          { transform: translate(dir * 100 * (1 - percent)) }];\n\n        }\n      }\n    };\n\n    function translated(el) {\n      return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;\n    }\n\n    function translate(value = 0, unit = '%') {\n      value += value ? unit : '';\n      return `translate3d(${value}, 0, 0)`;\n    }\n\n    function scale3d(value) {\n      return `scale3d(${value}, ${value}, 1)`;\n    }\n\n    var Animations$1 = {\n      ...Animations$2,\n      fade: {\n        show() {\n          return [{ opacity: 0 }, { opacity: 1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [{ opacity: 1 - percent }, { opacity: percent }];\n        }\n      },\n\n      scale: {\n        show() {\n          return [\n          { opacity: 0, transform: scale3d(1 - 0.2) },\n          { opacity: 1, transform: scale3d(1) }];\n\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [\n          { opacity: 1 - percent, transform: scale3d(1 - 0.2 * percent) },\n          { opacity: percent, transform: scale3d(1 - 0.2 + 0.2 * percent) }];\n\n        }\n      }\n    };\n\n    function Transitioner$1(prev, next, dir, { animation, easing }) {\n      const { percent, translate, show = noop } = animation;\n      const props = show(dir);\n      const deferred = new Deferred();\n\n      return {\n        dir,\n\n        show(duration, percent = 0, linear) {\n          const timing = linear ? 'linear' : easing;\n          duration -= Math.round(duration * clamp(percent, -1, 1));\n\n          this.translate(percent);\n\n          triggerUpdate$1(next, 'itemin', { percent, duration, timing, dir });\n          triggerUpdate$1(prev, 'itemout', { percent: 1 - percent, duration, timing, dir });\n\n          Promise.all([\n          Transition.start(next, props[1], duration, timing),\n          Transition.start(prev, props[0], duration, timing)]).\n          then(() => {\n            this.reset();\n            deferred.resolve();\n          }, noop);\n\n          return deferred.promise;\n        },\n\n        cancel() {\n          Transition.cancel([next, prev]);\n        },\n\n        reset() {\n          for (const prop in props[0]) {\n            css([next, prev], prop, '');\n          }\n        },\n\n        forward(duration, percent = this.percent()) {\n          Transition.cancel([next, prev]);\n          return this.show(duration, percent, true);\n        },\n\n        translate(percent) {\n          this.reset();\n\n          const props = translate(percent, dir);\n          css(next, props[1]);\n          css(prev, props[0]);\n          triggerUpdate$1(next, 'itemtranslatein', { percent, dir });\n          triggerUpdate$1(prev, 'itemtranslateout', { percent: 1 - percent, dir });\n        },\n\n        percent() {\n          return percent(prev || next, next, dir);\n        },\n\n        getDistance() {\n          return prev == null ? void 0 : prev.offsetWidth;\n        }\n      };\n    }\n\n    function triggerUpdate$1(el, type, data) {\n      trigger(el, createEvent(type, false, false, data));\n    }\n\n    var SliderAutoplay = {\n      props: {\n        autoplay: Boolean,\n        autoplayInterval: Number,\n        pauseOnHover: Boolean\n      },\n\n      data: {\n        autoplay: false,\n        autoplayInterval: 7000,\n        pauseOnHover: true\n      },\n\n      connected() {\n        this.autoplay && this.startAutoplay();\n      },\n\n      disconnected() {\n        this.stopAutoplay();\n      },\n\n      update() {\n        attr(this.slides, 'tabindex', '-1');\n      },\n\n      events: [\n      {\n        name: 'visibilitychange',\n\n        el() {\n          return document;\n        },\n\n        filter() {\n          return this.autoplay;\n        },\n\n        handler() {\n          if (document.hidden) {\n            this.stopAutoplay();\n          } else {\n            this.startAutoplay();\n          }\n        }\n      }],\n\n\n      methods: {\n        startAutoplay() {\n          this.stopAutoplay();\n\n          this.interval = setInterval(\n          () => (!this.draggable || !$(':focus', this.$el)) && (\n          !this.pauseOnHover || !matches(this.$el, ':hover')) &&\n          !this.stack.length &&\n          this.show('next'),\n          this.autoplayInterval);\n\n        },\n\n        stopAutoplay() {\n          this.interval && clearInterval(this.interval);\n        }\n      }\n    };\n\n    const pointerOptions = { passive: false, capture: true };\n    const pointerUpOptions = { passive: true, capture: true };\n    const pointerDown = 'touchstart mousedown';\n    const pointerMove = 'touchmove mousemove';\n    const pointerUp = 'touchend touchcancel mouseup click input scroll';\n\n    var SliderDrag = {\n      props: {\n        draggable: Boolean\n      },\n\n      data: {\n        draggable: true,\n        threshold: 10\n      },\n\n      created() {\n        for (const key of ['start', 'move', 'end']) {\n          const fn = this[key];\n          this[key] = (e) => {\n            const pos = getEventPos(e).x * (isRtl ? -1 : 1);\n\n            this.prevPos = pos === this.pos ? this.prevPos : this.pos;\n            this.pos = pos;\n\n            fn(e);\n          };\n        }\n      },\n\n      events: [\n      {\n        name: pointerDown,\n\n        passive: true,\n\n        delegate() {\n          return `${this.selList} > *`;\n        },\n\n        handler(e) {\n          if (\n          !this.draggable ||\n          !isTouch(e) && hasSelectableText(e.target) ||\n          closest(e.target, selInput) ||\n          e.button > 0 ||\n          this.length < 2)\n          {\n            return;\n          }\n\n          this.start(e);\n        }\n      },\n\n      {\n        name: 'dragstart',\n\n        handler(e) {\n          e.preventDefault();\n        }\n      },\n\n      {\n        // iOS workaround for slider stopping if swiping fast\n        name: pointerMove,\n        el() {\n          return this.list;\n        },\n        handler: noop,\n        ...pointerOptions\n      }],\n\n\n      methods: {\n        start() {\n          this.drag = this.pos;\n\n          if (this._transitioner) {\n            this.percent = this._transitioner.percent();\n            this.drag += this._transitioner.getDistance() * this.percent * this.dir;\n\n            this._transitioner.cancel();\n            this._transitioner.translate(this.percent);\n\n            this.dragging = true;\n\n            this.stack = [];\n          } else {\n            this.prevIndex = this.index;\n          }\n\n          on(document, pointerMove, this.move, pointerOptions);\n\n          // 'input' event is triggered by video controls\n          on(document, pointerUp, this.end, pointerUpOptions);\n\n          css(this.list, 'userSelect', 'none');\n        },\n\n        move(e) {\n          const distance = this.pos - this.drag;\n\n          if (\n          distance === 0 ||\n          this.prevPos === this.pos ||\n          !this.dragging && Math.abs(distance) < this.threshold)\n          {\n            return;\n          }\n\n          // prevent click event\n          css(this.list, 'pointerEvents', 'none');\n\n          e.cancelable && e.preventDefault();\n\n          this.dragging = true;\n          this.dir = distance < 0 ? 1 : -1;\n\n          const { slides } = this;\n          let { prevIndex } = this;\n          let dis = Math.abs(distance);\n          let nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n          let width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n          while (nextIndex !== prevIndex && dis > width) {\n            this.drag -= width * this.dir;\n\n            prevIndex = nextIndex;\n            dis -= width;\n            nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n            width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n          }\n\n          this.percent = dis / width;\n\n          const prev = slides[prevIndex];\n          const next = slides[nextIndex];\n          const changed = this.index !== nextIndex;\n          const edge = prevIndex === nextIndex;\n\n          let itemShown;\n\n          [this.index, this.prevIndex].\n          filter((i) => !includes([nextIndex, prevIndex], i)).\n          forEach((i) => {\n            trigger(slides[i], 'itemhidden', [this]);\n\n            if (edge) {\n              itemShown = true;\n              this.prevIndex = prevIndex;\n            }\n          });\n\n          if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {\n            trigger(slides[this.index], 'itemshown', [this]);\n          }\n\n          if (changed) {\n            this.prevIndex = prevIndex;\n            this.index = nextIndex;\n\n            !edge && trigger(prev, 'beforeitemhide', [this]);\n            trigger(next, 'beforeitemshow', [this]);\n          }\n\n          this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);\n\n          if (changed) {\n            !edge && trigger(prev, 'itemhide', [this]);\n            trigger(next, 'itemshow', [this]);\n          }\n        },\n\n        end() {\n          off(document, pointerMove, this.move, pointerOptions);\n          off(document, pointerUp, this.end, pointerUpOptions);\n\n          if (this.dragging) {\n            this.dragging = null;\n\n            if (this.index === this.prevIndex) {\n              this.percent = 1 - this.percent;\n              this.dir *= -1;\n              this._show(false, this.index, true);\n              this._transitioner = null;\n            } else {\n              const dirChange =\n              (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 ===\n              this.prevPos > this.pos;\n              this.index = dirChange ? this.index : this.prevIndex;\n\n              if (dirChange) {\n                this.percent = 1 - this.percent;\n              }\n\n              this.show(\n              this.dir > 0 && !dirChange || this.dir < 0 && dirChange ?\n              'next' :\n              'previous',\n              true);\n\n            }\n          }\n\n          css(this.list, { userSelect: '', pointerEvents: '' });\n\n          this.drag = this.percent = null;\n        }\n      }\n    };\n\n    function hasSelectableText(el) {\n      return (\n        css(el, 'userSelect') !== 'none' &&\n        toNodes(el.childNodes).some((el) => el.nodeType === 3 && el.textContent.trim()));\n\n    }\n\n    var SliderNav = {\n      data: {\n        selNav: false\n      },\n\n      computed: {\n        nav({ selNav }, $el) {\n          return $(selNav, $el);\n        },\n\n        selNavItem({ attrItem }) {\n          return `[${attrItem}],[data-${attrItem}]`;\n        },\n\n        navItems(_, $el) {\n          return $$(this.selNavItem, $el);\n        }\n      },\n\n      update: {\n        write() {\n          if (this.nav && this.length !== this.nav.children.length) {\n            html(\n            this.nav,\n            this.slides.\n            map((_, i) => `<li ${this.attrItem}=\"${i}\"><a href></a></li>`).\n            join(''));\n\n          }\n\n          this.navItems.concat(this.nav).forEach((el) => el && (el.hidden = !this.maxIndex));\n\n          this.updateNav();\n        },\n\n        events: ['resize']\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.selNavItem;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(data(e.current, this.attrItem));\n        }\n      },\n\n      {\n        name: 'itemshow',\n        handler: 'updateNav'\n      }],\n\n\n      methods: {\n        updateNav() {\n          const i = this.getValidIndex();\n          for (const el of this.navItems) {\n            const cmd = data(el, this.attrItem);\n\n            toggleClass(el, this.clsActive, toNumber(cmd) === i);\n            toggleClass(\n            el,\n            'uk-invisible',\n            this.finite && (\n            cmd === 'previous' && i === 0 || cmd === 'next' && i >= this.maxIndex));\n\n          }\n        }\n      }\n    };\n\n    var Slider = {\n      mixins: [SliderAutoplay, SliderDrag, SliderNav, Resize],\n\n      props: {\n        clsActivated: Boolean,\n        easing: String,\n        index: Number,\n        finite: Boolean,\n        velocity: Number\n      },\n\n      data: () => ({\n        easing: 'ease',\n        finite: false,\n        velocity: 1,\n        index: 0,\n        prevIndex: -1,\n        stack: [],\n        percent: 0,\n        clsActive: 'uk-active',\n        clsActivated: false,\n        Transitioner: false,\n        transitionOptions: {}\n      }),\n\n      connected() {\n        this.prevIndex = -1;\n        this.index = this.getValidIndex(this.$props.index);\n        this.stack = [];\n      },\n\n      disconnected() {\n        removeClass(this.slides, this.clsActive);\n      },\n\n      computed: {\n        duration({ velocity }, $el) {\n          return speedUp($el.offsetWidth / velocity);\n        },\n\n        list({ selList }, $el) {\n          return $(selList, $el);\n        },\n\n        maxIndex() {\n          return this.length - 1;\n        },\n\n        slides: {\n          get() {\n            return children(this.list);\n          },\n\n          watch() {\n            this.$emit('resize');\n          }\n        },\n\n        length() {\n          return this.slides.length;\n        }\n      },\n\n      methods: {\n        show(index, force = false) {\n          if (this.dragging || !this.length) {\n            return;\n          }\n\n          const { stack } = this;\n          const queueIndex = force ? 0 : stack.length;\n          const reset = () => {\n            stack.splice(queueIndex, 1);\n\n            if (stack.length) {\n              this.show(stack.shift(), true);\n            }\n          };\n\n          stack[force ? 'unshift' : 'push'](index);\n\n          if (!force && stack.length > 1) {\n            if (stack.length === 2) {\n              this._transitioner.forward(Math.min(this.duration, 200));\n            }\n\n            return;\n          }\n\n          const prevIndex = this.getIndex(this.index);\n          const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];\n          const nextIndex = this.getIndex(index, this.index);\n          const next = this.slides[nextIndex];\n\n          if (prev === next) {\n            reset();\n            return;\n          }\n\n          this.dir = getDirection(index, prevIndex);\n          this.prevIndex = prevIndex;\n          this.index = nextIndex;\n\n          if (\n          prev && !trigger(prev, 'beforeitemhide', [this]) ||\n          !trigger(next, 'beforeitemshow', [this, prev]))\n          {\n            this.index = this.prevIndex;\n            reset();\n            return;\n          }\n\n          const promise = this._show(prev, next, force).then(() => {\n            prev && trigger(prev, 'itemhidden', [this]);\n            trigger(next, 'itemshown', [this]);\n\n            return new Promise((resolve) => {\n              requestAnimationFrame(() => {\n                stack.shift();\n                if (stack.length) {\n                  this.show(stack.shift(), true);\n                } else {\n                  this._transitioner = null;\n                }\n                resolve();\n              });\n            });\n          });\n\n          prev && trigger(prev, 'itemhide', [this]);\n          trigger(next, 'itemshow', [this]);\n\n          return promise;\n        },\n\n        getIndex(index = this.index, prev = this.index) {\n          return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);\n        },\n\n        getValidIndex(index = this.index, prevIndex = this.prevIndex) {\n          return this.getIndex(index, prevIndex);\n        },\n\n        _show(prev, next, force) {\n          this._transitioner = this._getTransitioner(prev, next, this.dir, {\n            easing: force ?\n            next.offsetWidth < 600 ?\n            'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */ :\n            'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */ :\n            this.easing,\n            ...this.transitionOptions\n          });\n\n          if (!force && !prev) {\n            this._translate(1);\n            return Promise.resolve();\n          }\n\n          const { length } = this.stack;\n          return this._transitioner[length > 1 ? 'forward' : 'show'](\n          length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration,\n          this.percent);\n\n        },\n\n        _getDistance(prev, next) {\n          return this._getTransitioner(prev, prev !== next && next).getDistance();\n        },\n\n        _translate(percent, prev = this.prevIndex, next = this.index) {\n          const transitioner = this._getTransitioner(prev !== next ? prev : false, next);\n          transitioner.translate(percent);\n          return transitioner;\n        },\n\n        _getTransitioner(\n        prev = this.prevIndex,\n        next = this.index,\n        dir = this.dir || 1,\n        options = this.transitionOptions)\n        {\n          return new this.Transitioner(\n          isNumber(prev) ? this.slides[prev] : prev,\n          isNumber(next) ? this.slides[next] : next,\n          dir * (isRtl ? -1 : 1),\n          options);\n\n        }\n      }\n    };\n\n    function getDirection(index, prevIndex) {\n      return index === 'next' ? 1 : index === 'previous' ? -1 : index < prevIndex ? -1 : 1;\n    }\n\n    function speedUp(x) {\n      return 0.5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)\n    }\n\n    var Slideshow = {\n      mixins: [Slider],\n\n      props: {\n        animation: String\n      },\n\n      data: {\n        animation: 'slide',\n        clsActivated: 'uk-transition-active',\n        Animations: Animations$2,\n        Transitioner: Transitioner$1\n      },\n\n      computed: {\n        animation({ animation, Animations }) {\n          return { ...(Animations[animation] || Animations.slide), name: animation };\n        },\n\n        transitionOptions() {\n          return { animation: this.animation };\n        }\n      },\n\n      events: {\n        beforeitemshow({ target }) {\n          addClass(target, this.clsActive);\n        },\n\n        itemshown({ target }) {\n          addClass(target, this.clsActivated);\n        },\n\n        itemhidden({ target }) {\n          removeClass(target, this.clsActive, this.clsActivated);\n        }\n      }\n    };\n\n    var LightboxPanel = {\n      mixins: [Container, Modal, Togglable, Slideshow],\n\n      functional: true,\n\n      props: {\n        delayControls: Number,\n        preload: Number,\n        videoAutoplay: Boolean,\n        template: String\n      },\n\n      data: () => ({\n        preload: 1,\n        videoAutoplay: false,\n        delayControls: 3000,\n        items: [],\n        cls: 'uk-open',\n        clsPage: 'uk-lightbox-page',\n        selList: '.uk-lightbox-items',\n        attrItem: 'uk-lightbox-item',\n        selClose: '.uk-close-large',\n        selCaption: '.uk-lightbox-caption',\n        pauseOnHover: false,\n        velocity: 2,\n        Animations: Animations$1,\n        template: `<div class=\"uk-lightbox uk-overflow-hidden\"> <ul class=\"uk-lightbox-items\"></ul> <div class=\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\"> <button class=\"uk-lightbox-toolbar-icon uk-close-large\" type=\"button\" uk-close></button> </div> <a class=\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\" href uk-slidenav-previous uk-lightbox-item=\"previous\"></a> <a class=\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\" href uk-slidenav-next uk-lightbox-item=\"next\"></a> <div class=\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\"></div> </div>`\n      }),\n\n      created() {\n        const $el = $(this.template);\n        const list = $(this.selList, $el);\n        this.items.forEach(() => append(list, '<li>'));\n\n        this.$mount(append(this.container, $el));\n      },\n\n      computed: {\n        caption({ selCaption }, $el) {\n          return $(selCaption, $el);\n        }\n      },\n\n      events: [\n      {\n        name: `${pointerMove$1} ${pointerDown$1} keydown`,\n\n        handler: 'showControls'\n      },\n\n      {\n        name: 'click',\n\n        self: true,\n\n        delegate() {\n          return `${this.selList} > *`;\n        },\n\n        handler(e) {\n          if (!e.defaultPrevented) {\n            this.hide();\n          }\n        }\n      },\n\n      {\n        name: 'shown',\n\n        self: true,\n\n        handler() {\n          this.showControls();\n        }\n      },\n\n      {\n        name: 'hide',\n\n        self: true,\n\n        handler() {\n          this.hideControls();\n\n          removeClass(this.slides, this.clsActive);\n          Transition.stop(this.slides);\n        }\n      },\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          this.$destroy(true);\n        }\n      },\n\n      {\n        name: 'keyup',\n\n        el() {\n          return document;\n        },\n\n        handler(e) {\n          if (!this.isToggled(this.$el) || !this.draggable) {\n            return;\n          }\n\n          switch (e.keyCode) {\n            case 37:\n              this.show('previous');\n              break;\n            case 39:\n              this.show('next');\n              break;}\n\n        }\n      },\n\n      {\n        name: 'beforeitemshow',\n\n        handler(e) {\n          if (this.isToggled()) {\n            return;\n          }\n\n          this.draggable = false;\n\n          e.preventDefault();\n\n          this.toggleElement(this.$el, true, false);\n\n          this.animation = Animations$1['scale'];\n          removeClass(e.target, this.clsActive);\n          this.stack.splice(1, 0, this.index);\n        }\n      },\n\n      {\n        name: 'itemshow',\n\n        handler() {\n          html(this.caption, this.getItem().caption || '');\n\n          for (let j = -this.preload; j <= this.preload; j++) {\n            this.loadItem(this.index + j);\n          }\n        }\n      },\n\n      {\n        name: 'itemshown',\n\n        handler() {\n          this.draggable = this.$props.draggable;\n        }\n      },\n\n      {\n        name: 'itemload',\n\n        async handler(_, item) {\n          const { source: src, type, alt = '', poster, attrs = {} } = item;\n\n          this.setItem(item, '<span uk-spinner></span>');\n\n          if (!src) {\n            return;\n          }\n\n          let matches;\n          const iframeAttrs = {\n            allowfullscreen: '',\n            style: 'max-width: 100%; box-sizing: border-box;',\n            'uk-responsive': '',\n            'uk-video': `${this.videoAutoplay}`\n          };\n\n          // Image\n          if (\n          type === 'image' ||\n          src.match(/\\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\\?)/i))\n          {\n            try {\n              const { width, height } = await getImage(src, attrs.srcset, attrs.size);\n              this.setItem(item, createEl('img', { src, width, height, alt, ...attrs }));\n            } catch (e) {\n              this.setError(item);\n            }\n\n            // Video\n          } else if (type === 'video' || src.match(/\\.(mp4|webm|ogv)($|\\?)/i)) {\n            const video = createEl('video', {\n              src,\n              poster,\n              controls: '',\n              playsinline: '',\n              'uk-video': `${this.videoAutoplay}`\n            });\n\n            on(video, 'loadedmetadata', () => {\n              attr(video, {\n                width: video.videoWidth,\n                height: video.videoHeight,\n                ...attrs\n              });\n              this.setItem(item, video);\n            });\n            on(video, 'error', () => this.setError(item));\n\n            // Iframe\n          } else if (type === 'iframe' || src.match(/\\.(html|php)($|\\?)/i)) {\n            this.setItem(\n            item,\n            createEl('iframe', {\n              src,\n              allowfullscreen: '',\n              class: 'uk-lightbox-iframe',\n              ...attrs\n            }));\n\n\n            // YouTube\n          } else if (\n          matches = src.match(\n          /\\/\\/(?:.*?youtube(-nocookie)?\\..*?[?&]v=|youtu\\.be\\/)([\\w-]{11})[&?]?(.*)?/))\n\n          {\n            this.setItem(\n            item,\n            createEl('iframe', {\n              src: `https://www.youtube${matches[1] || ''}.com/embed/${matches[2]}${\n          matches[3] ? `?${matches[3]}` : ''\n          }`,\n              width: 1920,\n              height: 1080,\n              ...iframeAttrs,\n              ...attrs\n            }));\n\n\n            // Vimeo\n          } else if (matches = src.match(/\\/\\/.*?vimeo\\.[a-z]+\\/(\\d+)[&?]?(.*)?/)) {\n            try {\n              const { height, width } = await (\n              await fetch(\n              `https://vimeo.com/api/oembed.json?maxwidth=1920&url=${encodeURI(\n          src)\n          }`,\n              {\n                credentials: 'omit'\n              })).\n\n              json();\n\n              this.setItem(\n              item,\n              createEl('iframe', {\n                src: `https://player.vimeo.com/video/${matches[1]}${\n            matches[2] ? `?${matches[2]}` : ''\n            }`,\n                width,\n                height,\n                ...iframeAttrs,\n                ...attrs\n              }));\n\n            } catch (e) {\n              this.setError(item);\n            }\n          }\n        }\n      }],\n\n\n      methods: {\n        loadItem(index = this.index) {\n          const item = this.getItem(index);\n\n          if (!this.getSlide(item).childElementCount) {\n            trigger(this.$el, 'itemload', [item]);\n          }\n        },\n\n        getItem(index = this.index) {\n          return this.items[getIndex(index, this.slides)];\n        },\n\n        setItem(item, content) {\n          trigger(this.$el, 'itemloaded', [this, html(this.getSlide(item), content)]);\n        },\n\n        getSlide(item) {\n          return this.slides[this.items.indexOf(item)];\n        },\n\n        setError(item) {\n          this.setItem(item, '<span uk-icon=\"icon: bolt; ratio: 2\"></span>');\n        },\n\n        showControls() {\n          clearTimeout(this.controlsTimer);\n          this.controlsTimer = setTimeout(this.hideControls, this.delayControls);\n\n          addClass(this.$el, 'uk-active', 'uk-transition-active');\n        },\n\n        hideControls() {\n          removeClass(this.$el, 'uk-active', 'uk-transition-active');\n        }\n      }\n    };\n\n    function createEl(tag, attrs) {\n      const el = fragment(`<${tag}>`);\n      attr(el, attrs);\n      return el;\n    }\n\n    var lightbox = {\n      install: install$1,\n\n      props: { toggle: String },\n\n      data: { toggle: 'a' },\n\n      computed: {\n        toggles: {\n          get({ toggle }, $el) {\n            return $$(toggle, $el);\n          },\n\n          watch() {\n            this.hide();\n          }\n        }\n      },\n\n      disconnected() {\n        this.hide();\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return `${this.toggle}:not(.uk-disabled)`;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(e.current);\n        }\n      }],\n\n\n      methods: {\n        show(index) {\n          const items = uniqueBy(this.toggles.map(toItem), 'source');\n\n          if (isElement(index)) {\n            const { source } = toItem(index);\n            index = findIndex(items, ({ source: src }) => source === src);\n          }\n\n          this.panel = this.panel || this.$create('lightboxPanel', { ...this.$props, items });\n\n          on(this.panel.$el, 'hidden', () => this.panel = null);\n\n          return this.panel.show(index);\n        },\n\n        hide() {var _this$panel;\n          return (_this$panel = this.panel) == null ? void 0 : _this$panel.hide();\n        }\n      }\n    };\n\n    function install$1(UIkit, Lightbox) {\n      if (!UIkit.lightboxPanel) {\n        UIkit.component('lightboxPanel', LightboxPanel);\n      }\n\n      assign(Lightbox.props, UIkit.component('lightboxPanel').options.props);\n    }\n\n    function toItem(el) {\n      const item = {};\n\n      for (const attr of ['href', 'caption', 'type', 'poster', 'alt', 'attrs']) {\n        item[attr === 'href' ? 'source' : attr] = data(el, attr);\n      }\n\n      item.attrs = parseOptions(item.attrs);\n\n      return item;\n    }\n\n    var notification = {\n      mixins: [Container],\n\n      functional: true,\n\n      args: ['message', 'status'],\n\n      data: {\n        message: '',\n        status: '',\n        timeout: 5000,\n        group: null,\n        pos: 'top-center',\n        clsContainer: 'uk-notification',\n        clsClose: 'uk-notification-close',\n        clsMsg: 'uk-notification-message'\n      },\n\n      install,\n\n      computed: {\n        marginProp({ pos }) {\n          return `margin${startsWith(pos, 'top') ? 'Top' : 'Bottom'}`;\n        },\n\n        startProps() {\n          return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight };\n        }\n      },\n\n      created() {\n        const container =\n        $(`.${this.clsContainer}-${this.pos}`, this.container) ||\n        append(\n        this.container,\n        `<div class=\"${this.clsContainer} ${this.clsContainer}-${this.pos}\" style=\"display: block\"></div>`);\n\n\n        this.$mount(\n        append(\n        container,\n        `<div class=\"${this.clsMsg}${\n    this.status ? ` ${this.clsMsg}-${this.status}` : ''\n    }\" role=\"alert\"> <a href class=\"${this.clsClose}\" data-uk-close></a> <div>${this.message}</div> </div>`));\n\n\n      },\n\n      async connected() {\n        const margin = toFloat(css(this.$el, this.marginProp));\n        await Transition.start(css(this.$el, this.startProps), {\n          opacity: 1,\n          [this.marginProp]: margin\n        });\n\n        if (this.timeout) {\n          this.timer = setTimeout(this.close, this.timeout);\n        }\n      },\n\n      events: {\n        click(e) {\n          if (closest(e.target, 'a[href=\"#\"],a[href=\"\"]')) {\n            e.preventDefault();\n          }\n          this.close();\n        },\n\n        [pointerEnter]() {\n          if (this.timer) {\n            clearTimeout(this.timer);\n          }\n        },\n\n        [pointerLeave]() {\n          if (this.timeout) {\n            this.timer = setTimeout(this.close, this.timeout);\n          }\n        }\n      },\n\n      methods: {\n        async close(immediate) {\n          const removeFn = (el) => {\n            const container = parent(el);\n\n            trigger(el, 'close', [this]);\n            remove$1(el);\n\n            if (!(container != null && container.hasChildNodes())) {\n              remove$1(container);\n            }\n          };\n\n          if (this.timer) {\n            clearTimeout(this.timer);\n          }\n\n          if (!immediate) {\n            await Transition.start(this.$el, this.startProps);\n          }\n\n          removeFn(this.$el);\n        }\n      }\n    };\n\n    function install(UIkit) {\n      UIkit.notification.closeAll = function (group, immediate) {\n        apply(document.body, (el) => {\n          const notification = UIkit.getComponent(el, 'notification');\n          if (notification && (!group || group === notification.group)) {\n            notification.close(immediate);\n          }\n        });\n      };\n    }\n\n    const props = {\n      x: transformFn,\n      y: transformFn,\n      rotate: transformFn,\n      scale: transformFn,\n      color: colorFn,\n      backgroundColor: colorFn,\n      borderColor: colorFn,\n      blur: filterFn,\n      hue: filterFn,\n      fopacity: filterFn,\n      grayscale: filterFn,\n      invert: filterFn,\n      saturate: filterFn,\n      sepia: filterFn,\n      opacity: cssPropFn,\n      stroke: strokeFn,\n      bgx: backgroundFn,\n      bgy: backgroundFn\n    };\n\n    const { keys } = Object;\n\n    var Parallax = {\n      mixins: [Media],\n\n      props: fillObject(keys(props), 'list'),\n\n      data: fillObject(keys(props), undefined),\n\n      computed: {\n        props(properties, $el) {\n          const stops = {};\n          for (const prop in properties) {\n            if (prop in props && !isUndefined(properties[prop])) {\n              stops[prop] = properties[prop].slice();\n            }\n          }\n          const result = {};\n          for (const prop in stops) {\n            result[prop] = props[prop](prop, $el, stops[prop], stops);\n          }\n          return result;\n        }\n      },\n\n      events: {\n        load() {\n          this.$emit();\n        }\n      },\n\n      methods: {\n        reset() {\n          for (const prop in this.getCss(0)) {\n            css(this.$el, prop, '');\n          }\n        },\n\n        getCss(percent) {\n          const css = { transform: '', filter: '' };\n          for (const prop in this.props) {\n            this.props[prop](css, percent);\n          }\n          css.willChange = Object.keys(css).\n          filter((key) => css[key] !== '').\n          join(',');\n          return css;\n        }\n      }\n    };\n\n    function transformFn(prop, el, stops) {\n      let unit = getUnit(stops) || { x: 'px', y: 'px', rotate: 'deg' }[prop] || '';\n      let transformFn;\n\n      if (prop === 'x' || prop === 'y') {\n        prop = `translate${ucfirst(prop)}`;\n        transformFn = (stop) => toFloat(toFloat(stop).toFixed(unit === 'px' ? 0 : 6));\n      } else if (prop === 'scale') {\n        unit = '';\n        transformFn = (stop) => getUnit([stop]) ? toPx(stop, 'width', el, true) / el.offsetWidth : stop;\n      }\n\n      if (stops.length === 1) {\n        stops.unshift(prop === 'scale' ? 1 : 0);\n      }\n\n      stops = parseStops(stops, transformFn);\n\n      return (css, percent) => {\n        css.transform += ` ${prop}(${getValue(stops, percent)}${unit})`;\n      };\n    }\n\n    function colorFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(getCssValue(el, prop, ''));\n      }\n\n      stops = parseStops(stops, (stop) => parseColor(el, stop));\n\n      return (css, percent) => {\n        const [start, end, p] = getStop(stops, percent);\n        const value = start.\n        map((value, i) => {\n          value += p * (end[i] - value);\n          return i === 3 ? toFloat(value) : parseInt(value, 10);\n        }).\n        join(',');\n        css[prop] = `rgba(${value})`;\n      };\n    }\n\n    function parseColor(el, color) {\n      return getCssValue(el, 'color', color).\n      split(/[(),]/g).\n      slice(1, -1).\n      concat(1).\n      slice(0, 4).\n      map(toFloat);\n    }\n\n    function filterFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      const unit = getUnit(stops) || { blur: 'px', hue: 'deg' }[prop] || '%';\n      prop = { fopacity: 'opacity', hue: 'hue-rotate' }[prop] || prop;\n      stops = parseStops(stops);\n\n      return (css, percent) => {\n        const value = getValue(stops, percent);\n        css.filter += ` ${prop}(${value + unit})`;\n      };\n    }\n\n    function cssPropFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(getCssValue(el, prop, ''));\n      }\n\n      stops = parseStops(stops);\n\n      return (css, percent) => {\n        css[prop] = getValue(stops, percent);\n      };\n    }\n\n    function strokeFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      const unit = getUnit(stops);\n      const length = getMaxPathLength(el);\n      stops = parseStops(stops.reverse(), (stop) => {\n        stop = toFloat(stop);\n        return unit === '%' ? stop * length / 100 : stop;\n      });\n\n      if (!stops.some(([value]) => value)) {\n        return noop;\n      }\n\n      css(el, 'strokeDasharray', length);\n\n      return (css, percent) => {\n        css.strokeDashoffset = getValue(stops, percent);\n      };\n    }\n\n    function backgroundFn(prop, el, stops, props) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      const attr = prop === 'bgy' ? 'height' : 'width';\n      props[prop] = parseStops(stops, (stop) => toPx(stop, attr, el));\n\n      const bgProps = ['bgx', 'bgy'].filter((prop) => prop in props);\n      if (bgProps.length === 2 && prop === 'bgx') {\n        return noop;\n      }\n\n      if (getCssValue(el, 'backgroundSize', '') === 'cover') {\n        return backgroundCoverFn(prop, el, stops, props);\n      }\n\n      const positions = {};\n      for (const prop of bgProps) {\n        positions[prop] = getBackgroundPos(el, prop);\n      }\n\n      return setBackgroundPosFn(bgProps, positions, props);\n    }\n\n    function backgroundCoverFn(prop, el, stops, props) {\n      const dimImage = getBackgroundImageDimensions(el);\n\n      if (!dimImage.width) {\n        return noop;\n      }\n\n      const dimEl = {\n        width: el.offsetWidth,\n        height: el.offsetHeight\n      };\n\n      const bgProps = ['bgx', 'bgy'].filter((prop) => prop in props);\n\n      const positions = {};\n      for (const prop of bgProps) {\n        const values = props[prop].map(([value]) => value);\n        const min = Math.min(...values);\n        const max = Math.max(...values);\n        const down = values.indexOf(min) < values.indexOf(max);\n        const diff = max - min;\n\n        positions[prop] = `${(down ? -diff : 0) - (down ? min : max)}px`;\n        dimEl[prop === 'bgy' ? 'height' : 'width'] += diff;\n      }\n\n      const dim = Dimensions.cover(dimImage, dimEl);\n\n      for (const prop of bgProps) {\n        const attr = prop === 'bgy' ? 'height' : 'width';\n        const overflow = dim[attr] - dimEl[attr];\n        positions[prop] = `max(${getBackgroundPos(el, prop)},-${overflow}px) + ${positions[prop]}`;\n      }\n\n      const fn = setBackgroundPosFn(bgProps, positions, props);\n      return (css, percent) => {\n        fn(css, percent);\n        css.backgroundSize = `${dim.width}px ${dim.height}px`;\n        css.backgroundRepeat = 'no-repeat';\n      };\n    }\n\n    function getBackgroundPos(el, prop) {\n      return getCssValue(el, `background-position-${prop.substr(-1)}`, '');\n    }\n\n    function setBackgroundPosFn(bgProps, positions, props) {\n      return function (css, percent) {\n        for (const prop of bgProps) {\n          const value = getValue(props[prop], percent);\n          css[`background-position-${prop.substr(-1)}`] = `calc(${positions[prop]} + ${value}px)`;\n        }\n      };\n    }\n\n    const dimensions = {};\n    function getBackgroundImageDimensions(el) {\n      const src = css(el, 'backgroundImage').replace(/^none|url\\([\"']?(.+?)[\"']?\\)$/, '$1');\n\n      if (dimensions[src]) {\n        return dimensions[src];\n      }\n\n      const image = new Image();\n      if (src) {\n        image.src = src;\n\n        if (!image.naturalWidth) {\n          image.onload = () => {\n            dimensions[src] = toDimensions(image);\n            trigger(el, createEvent('load', false));\n          };\n          return toDimensions(image);\n        }\n      }\n\n      return dimensions[src] = toDimensions(image);\n    }\n\n    function toDimensions(image) {\n      return {\n        width: image.naturalWidth,\n        height: image.naturalHeight\n      };\n    }\n\n    function parseStops(stops, fn = toFloat) {\n      const result = [];\n      const { length } = stops;\n      let nullIndex = 0;\n      for (let i = 0; i < length; i++) {\n        let [value, percent] = isString(stops[i]) ? stops[i].trim().split(' ') : [stops[i]];\n        value = fn(value);\n        percent = percent ? toFloat(percent) / 100 : null;\n\n        if (i === 0) {\n          if (percent === null) {\n            percent = 0;\n          } else if (percent) {\n            result.push([value, 0]);\n          }\n        } else if (i === length - 1) {\n          if (percent === null) {\n            percent = 1;\n          } else if (percent !== 1) {\n            result.push([value, percent]);\n            percent = 1;\n          }\n        }\n\n        result.push([value, percent]);\n\n        if (percent === null) {\n          nullIndex++;\n        } else if (nullIndex) {\n          const leftPercent = result[i - nullIndex - 1][1];\n          const p = (percent - leftPercent) / (nullIndex + 1);\n          for (let j = nullIndex; j > 0; j--) {\n            result[i - j][1] = leftPercent + p * (nullIndex - j + 1);\n          }\n\n          nullIndex = 0;\n        }\n      }\n\n      return result;\n    }\n\n    function getStop(stops, percent) {\n      const index = findIndex(stops.slice(1), ([, targetPercent]) => percent <= targetPercent) + 1;\n      return [\n      stops[index - 1][0],\n      stops[index][0],\n      (percent - stops[index - 1][1]) / (stops[index][1] - stops[index - 1][1])];\n\n    }\n\n    function getValue(stops, percent) {\n      const [start, end, p] = getStop(stops, percent);\n      return isNumber(start) ? start + Math.abs(start - end) * p * (start < end ? 1 : -1) : +end;\n    }\n\n    const unitRe = /^-?\\d+(\\S+)?/;\n    function getUnit(stops, defaultUnit) {\n      for (const stop of stops) {\n        const match = stop.match == null ? void 0 : stop.match(unitRe);\n        if (match) {\n          return match[1];\n        }\n      }\n      return defaultUnit;\n    }\n\n    function getCssValue(el, prop, value) {\n      const prev = el.style[prop];\n      const val = css(css(el, prop, value), prop);\n      el.style[prop] = prev;\n      return val;\n    }\n\n    function fillObject(keys, value) {\n      return keys.reduce((data, prop) => {\n        data[prop] = value;\n        return data;\n      }, {});\n    }\n\n    var parallax = {\n      mixins: [Parallax, Resize, Scroll],\n\n      props: {\n        target: String,\n        viewport: Number, // Deprecated\n        easing: Number,\n        start: String,\n        end: String\n      },\n\n      data: {\n        target: false,\n        viewport: 1,\n        easing: 1,\n        start: 0,\n        end: 0\n      },\n\n      computed: {\n        target({ target }, $el) {\n          return getOffsetElement(target && query(target, $el) || $el);\n        },\n\n        start({ start }) {\n          return toPx(start, 'height', this.target, true);\n        },\n\n        end({ end, viewport }) {\n          return toPx(\n          end || (viewport = (1 - viewport) * 100) && `${viewport}vh+${viewport}%`,\n          'height',\n          this.target,\n          true);\n\n        }\n      },\n\n      resizeTargets() {\n        return [this.$el, this.target];\n      },\n\n      update: {\n        read({ percent }, types) {\n          if (!types.has('scroll')) {\n            percent = false;\n          }\n\n          if (!isVisible(this.$el)) {\n            return false;\n          }\n\n          if (!this.matchMedia) {\n            return;\n          }\n\n          const prev = percent;\n          percent = ease(scrolledOver(this.target, this.start, this.end), this.easing);\n\n          return {\n            percent,\n            style: prev === percent ? false : this.getCss(percent)\n          };\n        },\n\n        write({ style }) {\n          if (!this.matchMedia) {\n            this.reset();\n            return;\n          }\n\n          style && css(this.$el, style);\n        },\n\n        events: ['scroll', 'resize']\n      }\n    };\n\n    /*\n     * Inspired by https://gist.github.com/gre/1650294?permalink_comment_id=3477425#gistcomment-3477425\n     *\n     * linear: 0\n     * easeInSine: 0.5\n     * easeOutSine: -0.5\n     * easeInQuad: 1\n     * easeOutQuad: -1\n     * easeInCubic: 2\n     * easeOutCubic: -2\n     * easeInQuart: 3\n     * easeOutQuart: -3\n     * easeInQuint: 4\n     * easeOutQuint: -4\n     */\n    function ease(percent, easing) {\n      return easing >= 0 ? Math.pow(percent, easing + 1) : 1 - Math.pow(1 - percent, 1 - easing);\n    }\n\n    // SVG elements do not inherit from HTMLElement\n    function getOffsetElement(el) {\n      return el ? 'offsetTop' in el ? el : getOffsetElement(parent(el)) : document.documentElement;\n    }\n\n    var SliderReactive = {\n      update: {\n        write() {\n          if (this.stack.length || this.dragging) {\n            return;\n          }\n\n          const index = this.getValidIndex(this.index);\n\n          if (!~this.prevIndex || this.index !== index) {\n            this.show(index);\n          } else {\n            this._translate(1, this.prevIndex, this.index);\n          }\n        },\n\n        events: ['resize']\n      }\n    };\n\n    var SliderPreload = {\n      mixins: [Lazyload],\n\n      connected() {\n        this.lazyload(this.slides, this.getAdjacentSlides);\n      }\n    };\n\n    function Transitioner (prev, next, dir, { center, easing, list }) {\n      const deferred = new Deferred();\n\n      const from = prev ?\n      getLeft(prev, list, center) :\n      getLeft(next, list, center) + dimensions$1(next).width * dir;\n      const to = next ?\n      getLeft(next, list, center) :\n      from + dimensions$1(prev).width * dir * (isRtl ? -1 : 1);\n\n      return {\n        dir,\n\n        show(duration, percent = 0, linear) {\n          const timing = linear ? 'linear' : easing;\n          duration -= Math.round(duration * clamp(percent, -1, 1));\n\n          this.translate(percent);\n\n          percent = prev ? percent : clamp(percent, 0, 1);\n          triggerUpdate(this.getItemIn(), 'itemin', { percent, duration, timing, dir });\n          prev &&\n          triggerUpdate(this.getItemIn(true), 'itemout', {\n            percent: 1 - percent,\n            duration,\n            timing,\n            dir\n          });\n\n          Transition.start(\n          list,\n          { transform: translate(-to * (isRtl ? -1 : 1), 'px') },\n          duration,\n          timing).\n          then(deferred.resolve, noop);\n\n          return deferred.promise;\n        },\n\n        cancel() {\n          Transition.cancel(list);\n        },\n\n        reset() {\n          css(list, 'transform', '');\n        },\n\n        forward(duration, percent = this.percent()) {\n          Transition.cancel(list);\n          return this.show(duration, percent, true);\n        },\n\n        translate(percent) {\n          const distance = this.getDistance() * dir * (isRtl ? -1 : 1);\n\n          css(\n          list,\n          'transform',\n          translate(\n          clamp(\n          -to + (distance - distance * percent),\n          -getWidth(list),\n          dimensions$1(list).width) * (\n          isRtl ? -1 : 1),\n          'px'));\n\n\n\n          const actives = this.getActives();\n          const itemIn = this.getItemIn();\n          const itemOut = this.getItemIn(true);\n\n          percent = prev ? clamp(percent, -1, 1) : 0;\n\n          for (const slide of children(list)) {\n            const isActive = includes(actives, slide);\n            const isIn = slide === itemIn;\n            const isOut = slide === itemOut;\n            const translateIn =\n            isIn ||\n            !isOut && (\n            isActive ||\n            dir * (isRtl ? -1 : 1) === -1 ^\n            getElLeft(slide, list) > getElLeft(prev || next));\n\n            triggerUpdate(slide, `itemtranslate${translateIn ? 'in' : 'out'}`, {\n              dir,\n              percent: isOut ? 1 - percent : isIn ? percent : isActive ? 1 : 0\n            });\n          }\n        },\n\n        percent() {\n          return Math.abs(\n          (css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));\n\n        },\n\n        getDistance() {\n          return Math.abs(to - from);\n        },\n\n        getItemIn(out = false) {\n          let actives = this.getActives();\n          let nextActives = inView(list, getLeft(next || prev, list, center));\n\n          if (out) {\n            const temp = actives;\n            actives = nextActives;\n            nextActives = temp;\n          }\n\n          return nextActives[findIndex(nextActives, (el) => !includes(actives, el))];\n        },\n\n        getActives() {\n          return inView(list, getLeft(prev || next, list, center));\n        }\n      };\n    }\n\n    function getLeft(el, list, center) {\n      const left = getElLeft(el, list);\n\n      return center ? left - centerEl(el, list) : Math.min(left, getMax(list));\n    }\n\n    function getMax(list) {\n      return Math.max(0, getWidth(list) - dimensions$1(list).width);\n    }\n\n    function getWidth(list) {\n      return sumBy(children(list), (el) => dimensions$1(el).width);\n    }\n\n    function centerEl(el, list) {\n      return dimensions$1(list).width / 2 - dimensions$1(el).width / 2;\n    }\n\n    function getElLeft(el, list) {\n      return (\n        el &&\n        (position(el).left + (isRtl ? dimensions$1(el).width - dimensions$1(list).width : 0)) * (\n        isRtl ? -1 : 1) ||\n        0);\n\n    }\n\n    function inView(list, listLeft) {\n      listLeft -= 1;\n      const listWidth = dimensions$1(list).width;\n      const listRight = listLeft + listWidth + 2;\n\n      return children(list).filter((slide) => {\n        const slideLeft = getElLeft(slide, list);\n        const slideRight = slideLeft + Math.min(dimensions$1(slide).width, listWidth);\n\n        return slideLeft >= listLeft && slideRight <= listRight;\n      });\n    }\n\n    function triggerUpdate(el, type, data) {\n      trigger(el, createEvent(type, false, false, data));\n    }\n\n    var slider = {\n      mixins: [Class, Slider, SliderReactive, SliderPreload],\n\n      props: {\n        center: Boolean,\n        sets: Boolean\n      },\n\n      data: {\n        center: false,\n        sets: false,\n        attrItem: 'uk-slider-item',\n        selList: '.uk-slider-items',\n        selNav: '.uk-slider-nav',\n        clsContainer: 'uk-slider-container',\n        Transitioner\n      },\n\n      computed: {\n        avgWidth() {\n          return getWidth(this.list) / this.length;\n        },\n\n        finite({ finite }) {\n          return finite || isFinite(this.list, this.center);\n        },\n\n        maxIndex() {\n          if (!this.finite || this.center && !this.sets) {\n            return this.length - 1;\n          }\n\n          if (this.center) {\n            return last(this.sets);\n          }\n\n          let lft = 0;\n          const max = getMax(this.list);\n          const index = findIndex(this.slides, (el) => {\n            if (lft >= max) {\n              return true;\n            }\n\n            lft += dimensions$1(el).width;\n          });\n\n          return ~index ? index : this.length - 1;\n        },\n\n        sets({ sets: enabled }) {\n          if (!enabled) {\n            return;\n          }\n\n          let left = 0;\n          const sets = [];\n          const width = dimensions$1(this.list).width;\n          for (let i = 0; i < this.length; i++) {\n            const slideWidth = dimensions$1(this.slides[i]).width;\n\n            if (left + slideWidth > width) {\n              left = 0;\n            }\n\n            if (this.center) {\n              if (\n              left < width / 2 &&\n              left + slideWidth + dimensions$1(this.slides[+i + 1]).width / 2 > width / 2)\n              {\n                sets.push(+i);\n                left = width / 2 - slideWidth / 2;\n              }\n            } else if (left === 0) {\n              sets.push(Math.min(+i, this.maxIndex));\n            }\n\n            left += slideWidth;\n          }\n\n          if (sets.length) {\n            return sets;\n          }\n        },\n\n        transitionOptions() {\n          return {\n            center: this.center,\n            list: this.list\n          };\n        }\n      },\n\n      connected() {\n        toggleClass(this.$el, this.clsContainer, !$(`.${this.clsContainer}`, this.$el));\n      },\n\n      update: {\n        write() {\n          for (const el of this.navItems) {\n            const index = toNumber(data(el, this.attrItem));\n            if (index !== false) {\n              el.hidden =\n              !this.maxIndex ||\n              index > this.maxIndex ||\n              this.sets && !includes(this.sets, index);\n            }\n          }\n\n          if (this.length && !this.dragging && !this.stack.length) {\n            this.reorder();\n            this._translate(1);\n          }\n\n          this.updateActiveClasses();\n        },\n\n        events: ['resize']\n      },\n\n      events: {\n        beforeitemshow(e) {\n          if (\n          !this.dragging &&\n          this.sets &&\n          this.stack.length < 2 &&\n          !includes(this.sets, this.index))\n          {\n            this.index = this.getValidIndex();\n          }\n\n          const diff = Math.abs(\n          this.index -\n          this.prevIndex + (\n          this.dir > 0 && this.index < this.prevIndex ||\n          this.dir < 0 && this.index > this.prevIndex ?\n          (this.maxIndex + 1) * this.dir :\n          0));\n\n\n          if (!this.dragging && diff > 1) {\n            for (let i = 0; i < diff; i++) {\n              this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');\n            }\n\n            e.preventDefault();\n            return;\n          }\n\n          const index =\n          this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;\n          this.duration =\n          speedUp(this.avgWidth / this.velocity) * (\n          dimensions$1(this.slides[index]).width / this.avgWidth);\n\n          this.reorder();\n        },\n\n        itemshow() {\n          if (~this.prevIndex) {\n            addClass(this._getTransitioner().getItemIn(), this.clsActive);\n          }\n        },\n\n        itemshown() {\n          this.updateActiveClasses();\n        }\n      },\n\n      methods: {\n        reorder() {\n          if (this.finite) {\n            css(this.slides, 'order', '');\n            return;\n          }\n\n          const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;\n\n          this.slides.forEach((slide, i) => css(\n          slide,\n          'order',\n          this.dir > 0 && i < index ? 1 : this.dir < 0 && i >= this.index ? -1 : ''));\n\n\n\n          if (!this.center) {\n            return;\n          }\n\n          const next = this.slides[index];\n          let width = dimensions$1(this.list).width / 2 - dimensions$1(next).width / 2;\n          let j = 0;\n\n          while (width > 0) {\n            const slideIndex = this.getIndex(--j + index, index);\n            const slide = this.slides[slideIndex];\n\n            css(slide, 'order', slideIndex > index ? -2 : -1);\n            width -= dimensions$1(slide).width;\n          }\n        },\n\n        updateActiveClasses() {\n          const actives = this._getTransitioner(this.index).getActives();\n          const activeClasses = [\n          this.clsActive,\n          (!this.sets || includes(this.sets, toFloat(this.index))) && this.clsActivated ||\n          ''];\n\n          for (const slide of this.slides) {\n            toggleClass(slide, activeClasses, includes(actives, slide));\n          }\n        },\n\n        getValidIndex(index = this.index, prevIndex = this.prevIndex) {\n          index = this.getIndex(index, prevIndex);\n\n          if (!this.sets) {\n            return index;\n          }\n\n          let prev;\n\n          do {\n            if (includes(this.sets, index)) {\n              return index;\n            }\n\n            prev = index;\n            index = this.getIndex(index + this.dir, prevIndex);\n          } while (index !== prev);\n\n          return index;\n        },\n\n        getAdjacentSlides() {\n          const { width } = dimensions$1(this.list);\n          const left = -width;\n          const right = width * 2;\n          const slideWidth = dimensions$1(this.slides[this.index]).width;\n          const slideLeft = this.center ? width / 2 - slideWidth / 2 : 0;\n          const slides = new Set();\n          for (const i of [-1, 1]) {\n            let currentLeft = slideLeft + (i > 0 ? slideWidth : 0);\n            let j = 0;\n            do {\n              const slide = this.slides[this.getIndex(this.index + i + j++ * i)];\n              currentLeft += dimensions$1(slide).width * i;\n              slides.add(slide);\n            } while (this.length > j && currentLeft > left && currentLeft < right);\n          }\n          return Array.from(slides);\n        }\n      }\n    };\n\n    function isFinite(list, center) {\n      const { length } = list;\n\n      if (length < 2) {\n        return true;\n      }\n\n      const { width: listWidth } = dimensions$1(list);\n      if (!center) {\n        return Math.ceil(getWidth(list)) < Math.trunc(listWidth + getMaxElWidth(list));\n      }\n\n      const slides = children(list);\n      const listHalf = Math.trunc(listWidth / 2);\n      for (const index in slides) {\n        const slide = slides[index];\n        const slideWidth = dimensions$1(slide).width;\n        const slidesInView = new Set([slide]);\n\n        let diff = 0;\n        for (const i of [-1, 1]) {\n          let left = slideWidth / 2;\n\n          let j = 0;\n\n          while (left < listHalf) {\n            const nextSlide = slides[getIndex(+index + i + j++ * i, slides)];\n\n            if (slidesInView.has(nextSlide)) {\n              return true;\n            }\n\n            left += dimensions$1(nextSlide).width;\n            slidesInView.add(nextSlide);\n          }\n          diff = Math.max(\n          diff,\n          slideWidth / 2 +\n          dimensions$1(slides[getIndex(+index + i, slides)]).width / 2 - (\n          left - listHalf));\n\n        }\n\n        if (\n        diff > sumBy(\n        slides.filter((slide) => !slidesInView.has(slide)),\n        (slide) => dimensions$1(slide).width))\n\n        {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getMaxElWidth(list) {\n      return Math.max(0, ...children(list).map((el) => dimensions$1(el).width));\n    }\n\n    var sliderParallax = {\n      mixins: [Parallax],\n\n      data: {\n        selItem: '!li'\n      },\n\n      beforeConnect() {\n        this.item = query(this.selItem, this.$el);\n      },\n\n      disconnected() {\n        this.item = null;\n      },\n\n      events: [\n      {\n        name: 'itemin itemout',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler({ type, detail: { percent, duration, timing, dir } }) {\n          fastdom.read(() => {\n            if (!this.matchMedia) {\n              return;\n            }\n\n            const propsFrom = this.getCss(getCurrentPercent(type, dir, percent));\n            const propsTo = this.getCss(isIn(type) ? 0.5 : dir > 0 ? 1 : 0);\n            fastdom.write(() => {\n              css(this.$el, propsFrom);\n              Transition.start(this.$el, propsTo, duration, timing).catch(noop);\n            });\n          });\n        }\n      },\n\n      {\n        name: 'transitioncanceled transitionend',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler() {\n          Transition.cancel(this.$el);\n        }\n      },\n\n      {\n        name: 'itemtranslatein itemtranslateout',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler({ type, detail: { percent, dir } }) {\n          fastdom.read(() => {\n            if (!this.matchMedia) {\n              this.reset();\n              return;\n            }\n\n            const props = this.getCss(getCurrentPercent(type, dir, percent));\n            fastdom.write(() => css(this.$el, props));\n          });\n        }\n      }]\n\n    };\n\n    function isIn(type) {\n      return endsWith(type, 'in');\n    }\n\n    function getCurrentPercent(type, dir, percent) {\n      percent /= 2;\n\n      return isIn(type) ^ dir < 0 ? percent : 1 - percent;\n    }\n\n    var Animations = {\n      ...Animations$2,\n      fade: {\n        show() {\n          return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [{ opacity: 1 - percent, zIndex: 0 }, { zIndex: -1 }];\n        }\n      },\n\n      scale: {\n        show() {\n          return [{ opacity: 0, transform: scale3d(1 + 0.5), zIndex: 0 }, { zIndex: -1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [\n          { opacity: 1 - percent, transform: scale3d(1 + 0.5 * percent), zIndex: 0 },\n          { zIndex: -1 }];\n\n        }\n      },\n\n      pull: {\n        show(dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(30), zIndex: -1 },\n          { transform: translate(), zIndex: 0 }] :\n\n          [\n          { transform: translate(-100), zIndex: 0 },\n          { transform: translate(), zIndex: -1 }];\n\n        },\n\n        percent(current, next, dir) {\n          return dir < 0 ? 1 - translated(next) : translated(current);\n        },\n\n        translate(percent, dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(30 * percent), zIndex: -1 },\n          { transform: translate(-100 * (1 - percent)), zIndex: 0 }] :\n\n          [\n          { transform: translate(-percent * 100), zIndex: 0 },\n          { transform: translate(30 * (1 - percent)), zIndex: -1 }];\n\n        }\n      },\n\n      push: {\n        show(dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(100), zIndex: 0 },\n          { transform: translate(), zIndex: -1 }] :\n\n          [\n          { transform: translate(-30), zIndex: -1 },\n          { transform: translate(), zIndex: 0 }];\n\n        },\n\n        percent(current, next, dir) {\n          return dir > 0 ? 1 - translated(next) : translated(current);\n        },\n\n        translate(percent, dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(percent * 100), zIndex: 0 },\n          { transform: translate(-30 * (1 - percent)), zIndex: -1 }] :\n\n          [\n          { transform: translate(-30 * percent), zIndex: -1 },\n          { transform: translate(100 * (1 - percent)), zIndex: 0 }];\n\n        }\n      }\n    };\n\n    var slideshow = {\n      mixins: [Class, Slideshow, SliderReactive, SliderPreload],\n\n      props: {\n        ratio: String,\n        minHeight: Number,\n        maxHeight: Number\n      },\n\n      data: {\n        ratio: '16:9',\n        minHeight: false,\n        maxHeight: false,\n        selList: '.uk-slideshow-items',\n        attrItem: 'uk-slideshow-item',\n        selNav: '.uk-slideshow-nav',\n        Animations\n      },\n\n      update: {\n        read() {\n          if (!this.list) {\n            return false;\n          }\n\n          let [width, height] = this.ratio.split(':').map(Number);\n\n          height = height * this.list.offsetWidth / width || 0;\n\n          if (this.minHeight) {\n            height = Math.max(this.minHeight, height);\n          }\n\n          if (this.maxHeight) {\n            height = Math.min(this.maxHeight, height);\n          }\n\n          return { height: height - boxModelAdjust(this.list, 'height', 'content-box') };\n        },\n\n        write({ height }) {\n          height > 0 && css(this.list, 'minHeight', height);\n        },\n\n        events: ['resize']\n      },\n\n      methods: {\n        getAdjacentSlides() {\n          return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]);\n        }\n      }\n    };\n\n    var sortable = {\n      mixins: [Class, Animate],\n\n      props: {\n        group: String,\n        threshold: Number,\n        clsItem: String,\n        clsPlaceholder: String,\n        clsDrag: String,\n        clsDragState: String,\n        clsBase: String,\n        clsNoDrag: String,\n        clsEmpty: String,\n        clsCustom: String,\n        handle: String\n      },\n\n      data: {\n        group: false,\n        threshold: 5,\n        clsItem: 'uk-sortable-item',\n        clsPlaceholder: 'uk-sortable-placeholder',\n        clsDrag: 'uk-sortable-drag',\n        clsDragState: 'uk-drag',\n        clsBase: 'uk-sortable',\n        clsNoDrag: 'uk-sortable-nodrag',\n        clsEmpty: 'uk-sortable-empty',\n        clsCustom: '',\n        handle: false,\n        pos: {}\n      },\n\n      created() {\n        for (const key of ['init', 'start', 'move', 'end']) {\n          const fn = this[key];\n          this[key] = (e) => {\n            assign(this.pos, getEventPos(e));\n            fn(e);\n          };\n        }\n      },\n\n      events: {\n        name: pointerDown$1,\n        passive: false,\n        handler: 'init'\n      },\n\n      computed: {\n        target() {\n          return (this.$el.tBodies || [this.$el])[0];\n        },\n\n        items() {\n          return children(this.target);\n        },\n\n        isEmpty: {\n          get() {\n            return isEmpty(this.items);\n          },\n\n          watch(empty) {\n            toggleClass(this.target, this.clsEmpty, empty);\n          },\n\n          immediate: true\n        },\n\n        handles: {\n          get({ handle }, el) {\n            return handle ? $$(handle, el) : this.items;\n          },\n\n          watch(handles, prev) {\n            css(prev, { touchAction: '', userSelect: '' });\n            css(handles, { touchAction: hasTouch ? 'none' : '', userSelect: 'none' }); // touchAction set to 'none' causes a performance drop in Chrome 80\n          },\n\n          immediate: true\n        }\n      },\n\n      update: {\n        write(data) {\n          if (!this.drag || !parent(this.placeholder)) {\n            return;\n          }\n\n          const {\n            pos: { x, y },\n            origin: { offsetTop, offsetLeft },\n            placeholder\n          } = this;\n\n          css(this.drag, {\n            top: y - offsetTop,\n            left: x - offsetLeft\n          });\n\n          const sortable = this.getSortable(document.elementFromPoint(x, y));\n\n          if (!sortable) {\n            return;\n          }\n\n          const { items } = sortable;\n\n          if (items.some(Transition.inProgress)) {\n            return;\n          }\n\n          const target = findTarget(items, { x, y });\n\n          if (items.length && (!target || target === placeholder)) {\n            return;\n          }\n\n          const previous = this.getSortable(placeholder);\n          const insertTarget = findInsertTarget(\n          sortable.target,\n          target,\n          placeholder,\n          x,\n          y,\n          sortable === previous && data.moved !== target);\n\n\n          if (insertTarget === false) {\n            return;\n          }\n\n          if (insertTarget && placeholder === insertTarget) {\n            return;\n          }\n\n          if (sortable !== previous) {\n            previous.remove(placeholder);\n            data.moved = target;\n          } else {\n            delete data.moved;\n          }\n\n          sortable.insert(placeholder, insertTarget);\n\n          this.touched.add(sortable);\n        },\n\n        events: ['move']\n      },\n\n      methods: {\n        init(e) {\n          const { target, button, defaultPrevented } = e;\n          const [placeholder] = this.items.filter((el) => within(target, el));\n\n          if (\n          !placeholder ||\n          defaultPrevented ||\n          button > 0 ||\n          isInput(target) ||\n          within(target, `.${this.clsNoDrag}`) ||\n          this.handle && !within(target, this.handle))\n          {\n            return;\n          }\n\n          e.preventDefault();\n\n          this.touched = new Set([this]);\n          this.placeholder = placeholder;\n          this.origin = { target, index: index(placeholder), ...this.pos };\n\n          on(document, pointerMove$1, this.move);\n          on(document, pointerUp$1, this.end);\n\n          if (!this.threshold) {\n            this.start(e);\n          }\n        },\n\n        start(e) {\n          this.drag = appendDrag(this.$container, this.placeholder);\n          const { left, top } = this.placeholder.getBoundingClientRect();\n          assign(this.origin, { offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top });\n\n          addClass(this.drag, this.clsDrag, this.clsCustom);\n          addClass(this.placeholder, this.clsPlaceholder);\n          addClass(this.items, this.clsItem);\n          addClass(document.documentElement, this.clsDragState);\n\n          trigger(this.$el, 'start', [this, this.placeholder]);\n\n          trackScroll(this.pos);\n\n          this.move(e);\n        },\n\n        move(e) {\n          if (this.drag) {\n            this.$emit('move');\n          } else if (\n          Math.abs(this.pos.x - this.origin.x) > this.threshold ||\n          Math.abs(this.pos.y - this.origin.y) > this.threshold)\n          {\n            this.start(e);\n          }\n        },\n\n        end() {\n          off(document, pointerMove$1, this.move);\n          off(document, pointerUp$1, this.end);\n\n          if (!this.drag) {\n            return;\n          }\n\n          untrackScroll();\n\n          const sortable = this.getSortable(this.placeholder);\n\n          if (this === sortable) {\n            if (this.origin.index !== index(this.placeholder)) {\n              trigger(this.$el, 'moved', [this, this.placeholder]);\n            }\n          } else {\n            trigger(sortable.$el, 'added', [sortable, this.placeholder]);\n            trigger(this.$el, 'removed', [this, this.placeholder]);\n          }\n\n          trigger(this.$el, 'stop', [this, this.placeholder]);\n\n          remove$1(this.drag);\n          this.drag = null;\n\n          for (const { clsPlaceholder, clsItem } of this.touched) {\n            for (const sortable of this.touched) {\n              removeClass(sortable.items, clsPlaceholder, clsItem);\n            }\n          }\n          this.touched = null;\n          removeClass(document.documentElement, this.clsDragState);\n        },\n\n        insert(element, target) {\n          addClass(this.items, this.clsItem);\n\n          const insert = () => target ? before(target, element) : append(this.target, element);\n\n          this.animate(insert);\n        },\n\n        remove(element) {\n          if (!within(element, this.target)) {\n            return;\n          }\n\n          this.animate(() => remove$1(element));\n        },\n\n        getSortable(element) {\n          do {\n            const sortable = this.$getComponent(element, 'sortable');\n\n            if (\n            sortable && (\n            sortable === this || this.group !== false && sortable.group === this.group))\n            {\n              return sortable;\n            }\n          } while (element = parent(element));\n        }\n      }\n    };\n\n    let trackTimer;\n    function trackScroll(pos) {\n      let last = Date.now();\n      trackTimer = setInterval(() => {\n        let { x, y } = pos;\n        y += document.scrollingElement.scrollTop;\n\n        const dist = (Date.now() - last) * 0.3;\n        last = Date.now();\n\n        scrollParents(document.elementFromPoint(x, pos.y), /auto|scroll/).\n        reverse().\n        some((scrollEl) => {\n          let { scrollTop: scroll, scrollHeight } = scrollEl;\n\n          const { top, bottom, height } = offsetViewport(scrollEl);\n\n          if (top < y && top + 35 > y) {\n            scroll -= dist;\n          } else if (bottom > y && bottom - 35 < y) {\n            scroll += dist;\n          } else {\n            return;\n          }\n\n          if (scroll > 0 && scroll < scrollHeight - height) {\n            scrollEl.scrollTop = scroll;\n            return true;\n          }\n        });\n      }, 15);\n    }\n\n    function untrackScroll() {\n      clearInterval(trackTimer);\n    }\n\n    function appendDrag(container, element) {\n      let clone;\n      if (['li', 'tr'].some((tag) => isTag(element, tag))) {\n        clone = $('<div>');\n        append(clone, element.cloneNode(true).children);\n        for (const attribute of element.getAttributeNames()) {\n          attr(clone, attribute, element.getAttribute(attribute));\n        }\n      } else {\n        clone = element.cloneNode(true);\n      }\n\n      append(container, clone);\n\n      css(clone, 'margin', '0', 'important');\n      css(clone, {\n        boxSizing: 'border-box',\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        padding: css(element, 'padding')\n      });\n\n      height(clone.firstElementChild, height(element.firstElementChild));\n\n      return clone;\n    }\n\n    function findTarget(items, point) {\n      return items[findIndex(items, (item) => pointInRect(point, item.getBoundingClientRect()))];\n    }\n\n    function findInsertTarget(list, target, placeholder, x, y, sameList) {\n      if (!children(list).length) {\n        return;\n      }\n\n      const rect = target.getBoundingClientRect();\n      if (!sameList) {\n        if (!isHorizontal(list, placeholder)) {\n          return y < rect.top + rect.height / 2 ? target : target.nextElementSibling;\n        }\n\n        return target;\n      }\n\n      const placeholderRect = placeholder.getBoundingClientRect();\n      const sameRow = linesIntersect(\n      [rect.top, rect.bottom],\n      [placeholderRect.top, placeholderRect.bottom]);\n\n\n      const pointerPos = sameRow ? x : y;\n      const lengthProp = sameRow ? 'width' : 'height';\n      const startProp = sameRow ? 'left' : 'top';\n      const endProp = sameRow ? 'right' : 'bottom';\n\n      const diff =\n      placeholderRect[lengthProp] < rect[lengthProp] ?\n      rect[lengthProp] - placeholderRect[lengthProp] :\n      0;\n\n      if (placeholderRect[startProp] < rect[startProp]) {\n        if (diff && pointerPos < rect[startProp] + diff) {\n          return false;\n        }\n\n        return target.nextElementSibling;\n      }\n\n      if (diff && pointerPos > rect[endProp] - diff) {\n        return false;\n      }\n\n      return target;\n    }\n\n    function isHorizontal(list, placeholder) {\n      const single = children(list).length === 1;\n\n      if (single) {\n        append(list, placeholder);\n      }\n\n      const items = children(list);\n      const isHorizontal = items.some((el, i) => {\n        const rectA = el.getBoundingClientRect();\n        return items.slice(i + 1).some((el) => {\n          const rectB = el.getBoundingClientRect();\n          return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);\n        });\n      });\n\n      if (single) {\n        remove$1(placeholder);\n      }\n\n      return isHorizontal;\n    }\n\n    function linesIntersect(lineA, lineB) {\n      return lineA[1] > lineB[0] && lineB[1] > lineA[0];\n    }\n\n    var tooltip = {\n      mixins: [Container, Togglable, Position],\n\n      args: 'title',\n\n      props: {\n        delay: Number,\n        title: String\n      },\n\n      data: {\n        pos: 'top',\n        title: '',\n        delay: 0,\n        animation: ['uk-animation-scale-up'],\n        duration: 100,\n        cls: 'uk-active'\n      },\n\n      beforeConnect() {\n        this.id = `uk-tooltip-${this._uid}`;\n        this._hasTitle = hasAttr(this.$el, 'title');\n        attr(this.$el, {\n          title: '',\n          'aria-describedby': this.id\n        });\n        makeFocusable(this.$el);\n      },\n\n      disconnected() {\n        this.hide();\n\n        if (!attr(this.$el, 'title')) {\n          attr(this.$el, 'title', this._hasTitle ? this.title : null);\n        }\n      },\n\n      methods: {\n        show() {\n          if (this.isToggled(this.tooltip || null) || !this.title) {\n            return;\n          }\n\n          this._unbind = once(\n          document,\n          `keydown ${pointerDown$1}`,\n          this.hide,\n          false,\n          (e) => e.type === pointerDown$1 && !within(e.target, this.$el) ||\n          e.type === 'keydown' && e.keyCode === 27);\n\n\n          clearTimeout(this.showTimer);\n          this.showTimer = setTimeout(this._show, this.delay);\n        },\n\n        async hide() {\n          if (matches(this.$el, 'input:focus')) {\n            return;\n          }\n\n          clearTimeout(this.showTimer);\n\n          if (!this.isToggled(this.tooltip || null)) {\n            return;\n          }\n\n          await this.toggleElement(this.tooltip, false, false);\n          remove$1(this.tooltip);\n          this.tooltip = null;\n          this._unbind();\n        },\n\n        _show() {\n          this.tooltip = append(\n          this.container,\n          `<div id=\"${this.id}\" class=\"uk-${this.$options.name}\" role=\"tooltip\"> <div class=\"uk-${this.$options.name}-inner\">${this.title}</div> </div>`);\n\n\n          on(this.tooltip, 'toggled', (e, toggled) => {\n            if (!toggled) {\n              return;\n            }\n\n            this.positionAt(this.tooltip, this.$el);\n\n            const [dir, align] = getAlignment(this.tooltip, this.$el, this.pos);\n\n            this.origin =\n            this.axis === 'y' ?\n            `${flipPosition(dir)}-${align}` :\n            `${align}-${flipPosition(dir)}`;\n          });\n\n          this.toggleElement(this.tooltip, true);\n        }\n      },\n\n      events: {\n        focus: 'show',\n        blur: 'hide',\n\n        [`${pointerEnter} ${pointerLeave}`](e) {\n          if (!isTouch(e)) {\n            this[e.type === pointerEnter ? 'show' : 'hide']();\n          }\n        },\n\n        // Clicking a button does not give it focus on all browsers and platforms\n        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus\n        [pointerDown$1](e) {\n          if (isTouch(e)) {\n            this.show();\n          }\n        }\n      }\n    };\n\n    function makeFocusable(el) {\n      if (!isFocusable(el)) {\n        attr(el, 'tabindex', '0');\n      }\n    }\n\n    function getAlignment(el, target, [dir, align]) {\n      const elOffset = offset(el);\n      const targetOffset = offset(target);\n      const properties = [\n      ['left', 'right'],\n      ['top', 'bottom']];\n\n\n      for (const props of properties) {\n        if (elOffset[props[0]] >= targetOffset[props[1]]) {\n          dir = props[1];\n          break;\n        }\n        if (elOffset[props[1]] <= targetOffset[props[0]]) {\n          dir = props[0];\n          break;\n        }\n      }\n\n      const props = includes(properties[0], dir) ? properties[1] : properties[0];\n      if (elOffset[props[0]] === targetOffset[props[0]]) {\n        align = props[0];\n      } else if (elOffset[props[1]] === targetOffset[props[1]]) {\n        align = props[1];\n      } else {\n        align = 'center';\n      }\n\n      return [dir, align];\n    }\n\n    var upload = {\n      props: {\n        allow: String,\n        clsDragover: String,\n        concurrent: Number,\n        maxSize: Number,\n        method: String,\n        mime: String,\n        msgInvalidMime: String,\n        msgInvalidName: String,\n        msgInvalidSize: String,\n        multiple: Boolean,\n        name: String,\n        params: Object,\n        type: String,\n        url: String\n      },\n\n      data: {\n        allow: false,\n        clsDragover: 'uk-dragover',\n        concurrent: 1,\n        maxSize: 0,\n        method: 'POST',\n        mime: false,\n        msgInvalidMime: 'Invalid File Type: %s',\n        msgInvalidName: 'Invalid File Name: %s',\n        msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',\n        multiple: false,\n        name: 'files[]',\n        params: {},\n        type: '',\n        url: '',\n        abort: noop,\n        beforeAll: noop,\n        beforeSend: noop,\n        complete: noop,\n        completeAll: noop,\n        error: noop,\n        fail: noop,\n        load: noop,\n        loadEnd: noop,\n        loadStart: noop,\n        progress: noop\n      },\n\n      events: {\n        change(e) {\n          if (!matches(e.target, 'input[type=\"file\"]')) {\n            return;\n          }\n\n          e.preventDefault();\n\n          if (e.target.files) {\n            this.upload(e.target.files);\n          }\n\n          e.target.value = '';\n        },\n\n        drop(e) {\n          stop(e);\n\n          const transfer = e.dataTransfer;\n\n          if (!(transfer != null && transfer.files)) {\n            return;\n          }\n\n          removeClass(this.$el, this.clsDragover);\n\n          this.upload(transfer.files);\n        },\n\n        dragenter(e) {\n          stop(e);\n        },\n\n        dragover(e) {\n          stop(e);\n          addClass(this.$el, this.clsDragover);\n        },\n\n        dragleave(e) {\n          stop(e);\n          removeClass(this.$el, this.clsDragover);\n        }\n      },\n\n      methods: {\n        async upload(files) {\n          files = toArray(files);\n\n          if (!files.length) {\n            return;\n          }\n\n          trigger(this.$el, 'upload', [files]);\n\n          for (const file of files) {\n            if (this.maxSize && this.maxSize * 1000 < file.size) {\n              this.fail(this.msgInvalidSize.replace('%s', this.maxSize));\n              return;\n            }\n\n            if (this.allow && !match(this.allow, file.name)) {\n              this.fail(this.msgInvalidName.replace('%s', this.allow));\n              return;\n            }\n\n            if (this.mime && !match(this.mime, file.type)) {\n              this.fail(this.msgInvalidMime.replace('%s', this.mime));\n              return;\n            }\n          }\n\n          if (!this.multiple) {\n            files = files.slice(0, 1);\n          }\n\n          this.beforeAll(this, files);\n\n          const chunks = chunk(files, this.concurrent);\n          const upload = async (files) => {\n            const data = new FormData();\n\n            files.forEach((file) => data.append(this.name, file));\n\n            for (const key in this.params) {\n              data.append(key, this.params[key]);\n            }\n\n            try {\n              const xhr = await ajax(this.url, {\n                data,\n                method: this.method,\n                responseType: this.type,\n                beforeSend: (env) => {\n                  const { xhr } = env;\n                  xhr.upload && on(xhr.upload, 'progress', this.progress);\n                  for (const type of ['loadStart', 'load', 'loadEnd', 'abort']) {\n                    on(xhr, type.toLowerCase(), this[type]);\n                  }\n\n                  return this.beforeSend(env);\n                }\n              });\n\n              this.complete(xhr);\n\n              if (chunks.length) {\n                await upload(chunks.shift());\n              } else {\n                this.completeAll(xhr);\n              }\n            } catch (e) {\n              this.error(e);\n            }\n          };\n\n          await upload(chunks.shift());\n        }\n      }\n    };\n\n    function match(pattern, path) {\n      return path.match(\n      new RegExp(\n      `^${pattern.\n  replace(/\\//g, '\\\\/').\n  replace(/\\*\\*/g, '(\\\\/[^\\\\/]+)*').\n  replace(/\\*/g, '[^\\\\/]+').\n  replace(/((?!\\\\))\\?/g, '$1.')}$`,\n      'i'));\n\n\n    }\n\n    function chunk(files, size) {\n      const chunks = [];\n      for (let i = 0; i < files.length; i += size) {\n        chunks.push(files.slice(i, i + size));\n      }\n      return chunks;\n    }\n\n    function stop(e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    var components = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Countdown: countdown,\n        Filter: filter,\n        Lightbox: lightbox,\n        LightboxPanel: LightboxPanel,\n        Notification: notification,\n        Parallax: parallax,\n        Slider: slider,\n        SliderParallax: sliderParallax,\n        Slideshow: slideshow,\n        SlideshowParallax: sliderParallax,\n        Sortable: sortable,\n        Tooltip: tooltip,\n        Upload: upload\n    });\n\n    each(components, (component, name) => UIkit.component(name, component));\n\n    return UIkit;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvZGlzdC9qcy91aWtpdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUNvRztBQUN4RyxDQUFDLHVCQUF1Qjs7QUFFeEIsWUFBWSwyQkFBMkI7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksU0FBUzs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsRUFBRSxHQUFHLEVBQUU7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUIsSUFBSSxtQkFBbUI7O0FB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O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsNEJBQTRCO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSx5QkFBeUI7OztBQUduQyxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVULGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFF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QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDJCQUEyQjtBQUM1RTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0EsU0FBUzs7QUFFVCxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUUsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBOztBQUVBLFlBQVksY0FBYyxFQUFFLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVuYS8uL25vZGVfbW9kdWxlcy91aWtpdC9kaXN0L2pzL3Vpa2l0LmpzPzJmNDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIFVJa2l0IDMuMTUuMTggfCBodHRwczovL3d3dy5nZXR1aWtpdC5jb20gfCAoYykgMjAxNCAtIDIwMjIgWU9PdGhlbWUgfCBNSVQgTGljZW5zZSAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ3Vpa2l0JywgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5VSWtpdCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCB7IGhhc093blByb3BlcnR5LCB0b1N0cmluZyB9ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IGh5cGhlbmF0ZVJlID0gL1xcQihbQS1aXSkvZztcblxuICAgIGNvbnN0IGh5cGhlbmF0ZSA9IG1lbW9pemUoKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUmUsICctJDEnKS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIGNvbnN0IGNhbWVsaXplUmUgPSAvLShcXHcpL2c7XG5cbiAgICBjb25zdCBjYW1lbGl6ZSA9IG1lbW9pemUoKHN0cikgPT4gc3RyLnJlcGxhY2UoY2FtZWxpemVSZSwgdG9VcHBlcikpO1xuXG4gICAgY29uc3QgdWNmaXJzdCA9IG1lbW9pemUoKHN0cikgPT5cbiAgICBzdHIubGVuZ3RoID8gdG9VcHBlcihudWxsLCBzdHIuY2hhckF0KDApKSArIHN0ci5zbGljZSgxKSA6ICcnKTtcblxuXG4gICAgZnVuY3Rpb24gdG9VcHBlcihfLCBjKSB7XG4gICAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gpIHtcbiAgICAgIHJldHVybiBzdHIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci5zdGFydHNXaXRoID09IG51bGwgPyB2b2lkIDAgOiBzdHIuc3RhcnRzV2l0aChzZWFyY2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoKSB7XG4gICAgICByZXR1cm4gc3RyID09IG51bGwgPyB2b2lkIDAgOiBzdHIuZW5kc1dpdGggPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci5lbmRzV2l0aChzZWFyY2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKG9iaiwgc2VhcmNoKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmouaW5jbHVkZXMgPT0gbnVsbCA/IHZvaWQgMCA6IG9iai5pbmNsdWRlcyhzZWFyY2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IHZvaWQgMCA6IGFycmF5LmZpbmRJbmRleCA9PSBudWxsID8gdm9pZCAwIDogYXJyYXkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBpc0FycmF5LCBmcm9tOiB0b0FycmF5IH0gPSBBcnJheTtcbiAgICBjb25zdCB7IGFzc2lnbiB9ID0gT2JqZWN0O1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiBvYmogPT09IG9iai53aW5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEb2N1bWVudChvYmopIHtcbiAgICAgIHJldHVybiBub2RlVHlwZShvYmopID09PSA5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTm9kZShvYmopIHtcbiAgICAgIHJldHVybiBub2RlVHlwZShvYmopID49IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgICAgcmV0dXJuIG5vZGVUeXBlKG9iaikgPT09IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9kZVR5cGUob2JqKSB7XG4gICAgICByZXR1cm4gIWlzV2luZG93KG9iaikgJiYgaXNPYmplY3Qob2JqKSAmJiBvYmoubm9kZVR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWVyaWModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpICYmICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgICAgcmV0dXJuICEoaXNBcnJheShvYmopID8gb2JqLmxlbmd0aCA6IGlzT2JqZWN0KG9iaikgPyBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA6IGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNCb29sZWFuKHZhbHVlKSA/XG4gICAgICB2YWx1ZSA6XG4gICAgICB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnMScgfHwgdmFsdWUgPT09ICcnID9cbiAgICAgIHRydWUgOlxuICAgICAgdmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICcwJyA/XG4gICAgICBmYWxzZSA6XG4gICAgICB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgY29uc3QgbnVtYmVyID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBpc05hTihudW1iZXIpID8gZmFsc2UgOiBudW1iZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob2RlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm9kZXMoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgKGlzTm9kZShlbGVtZW50KSA/IFtlbGVtZW50XSA6IEFycmF5LmZyb20oZWxlbWVudCkuZmlsdGVyKGlzTm9kZSkpIHx8IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvV2luZG93KGVsZW1lbnQpIHt2YXIgX2VsZW1lbnQ7XG4gICAgICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogKF9lbGVtZW50ID0gZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgIHJldHVybiAoZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZhbHVlID09PSBvdGhlciB8fFxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgaXNPYmplY3Qob3RoZXIpICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKG90aGVyKS5sZW5ndGggJiZcbiAgICAgICAgZWFjaCh2YWx1ZSwgKHZhbCwga2V5KSA9PiB2YWwgPT09IG90aGVyW2tleV0pKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN3YXAodmFsdWUsIGEsIGIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7YX18JHtifWAsICdnJyksIChtYXRjaCkgPT4gbWF0Y2ggPT09IGEgPyBiIDogYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2gob2JqLCBjYikge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gY2Iob2JqW2tleV0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRCeSQxKGFycmF5LCBwcm9wKSB7XG4gICAgICByZXR1cm4gYXJyYXkuXG4gICAgICBzbGljZSgpLlxuICAgICAgc29ydCgoeyBbcHJvcF06IHByb3BBID0gMCB9LCB7IFtwcm9wXTogcHJvcEIgPSAwIH0pID0+IHByb3BBID4gcHJvcEIgPyAxIDogcHJvcEIgPiBwcm9wQSA/IC0xIDogMCk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBhcnJheS5yZWR1Y2UoXG4gICAgICAoc3VtLCBpdGVtKSA9PiBzdW0gKyB0b0Zsb2F0KGlzRnVuY3Rpb24oaXRlcmF0ZWUpID8gaXRlcmF0ZWUoaXRlbSkgOiBpdGVtW2l0ZXJhdGVlXSksXG4gICAgICAwKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXF1ZUJ5KGFycmF5LCBwcm9wKSB7XG4gICAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgICAgcmV0dXJuIGFycmF5LmZpbHRlcigoeyBbcHJvcF06IGNoZWNrIH0pID0+IHNlZW4uaGFzKGNoZWNrKSA/IGZhbHNlIDogc2Vlbi5hZGQoY2hlY2spKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0b051bWJlcihudW1iZXIpIHx8IDAsIG1pbiksIG1heCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RSZWN0KC4uLnJlY3RzKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgWydib3R0b20nLCAndG9wJ10sXG4gICAgICBbJ3JpZ2h0JywgJ2xlZnQnXV0uXG4gICAgICBldmVyeShcbiAgICAgIChbbWluUHJvcCwgbWF4UHJvcF0pID0+IE1hdGgubWluKC4uLnJlY3RzLm1hcCgoeyBbbWluUHJvcF06IG1pbiB9KSA9PiBtaW4pKSAtXG4gICAgICBNYXRoLm1heCguLi5yZWN0cy5tYXAoKHsgW21heFByb3BdOiBtYXggfSkgPT4gbWF4KSkgPiAwKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb2ludC54IDw9IHJlY3QucmlnaHQgJiZcbiAgICAgICAgcG9pbnQueCA+PSByZWN0LmxlZnQgJiZcbiAgICAgICAgcG9pbnQueSA8PSByZWN0LmJvdHRvbSAmJlxuICAgICAgICBwb2ludC55ID49IHJlY3QudG9wKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBhUHJvcCA9IHByb3AgPT09ICd3aWR0aCcgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFthUHJvcF06IGRpbWVuc2lvbnNbcHJvcF0gP1xuICAgICAgICBNYXRoLnJvdW5kKHZhbHVlICogZGltZW5zaW9uc1thUHJvcF0gLyBkaW1lbnNpb25zW3Byb3BdKSA6XG4gICAgICAgIGRpbWVuc2lvbnNbYVByb3BdLFxuICAgICAgICBbcHJvcF06IHZhbHVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW4oZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucykge1xuICAgICAgZGltZW5zaW9ucyA9IHsgLi4uZGltZW5zaW9ucyB9O1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBkaW1lbnNpb25zID1cbiAgICAgICAgZGltZW5zaW9uc1twcm9wXSA+IG1heERpbWVuc2lvbnNbcHJvcF0gP1xuICAgICAgICByYXRpbyhkaW1lbnNpb25zLCBwcm9wLCBtYXhEaW1lbnNpb25zW3Byb3BdKSA6XG4gICAgICAgIGRpbWVuc2lvbnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvdmVyJDEoZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucykge1xuICAgICAgZGltZW5zaW9ucyA9IGNvbnRhaW4oZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucyk7XG5cbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPVxuICAgICAgICBkaW1lbnNpb25zW3Byb3BdIDwgbWF4RGltZW5zaW9uc1twcm9wXSA/XG4gICAgICAgIHJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIG1heERpbWVuc2lvbnNbcHJvcF0pIDpcbiAgICAgICAgZGltZW5zaW9ucztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgRGltZW5zaW9ucyA9IHsgcmF0aW8sIGNvbnRhaW4sIGNvdmVyOiBjb3ZlciQxIH07XG5cbiAgICBmdW5jdGlvbiBnZXRJbmRleChpLCBlbGVtZW50cywgY3VycmVudCA9IDAsIGZpbml0ZSA9IGZhbHNlKSB7XG4gICAgICBlbGVtZW50cyA9IHRvTm9kZXMoZWxlbWVudHMpO1xuXG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gZWxlbWVudHM7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgaSA9IGlzTnVtZXJpYyhpKSA/XG4gICAgICB0b051bWJlcihpKSA6XG4gICAgICBpID09PSAnbmV4dCcgP1xuICAgICAgY3VycmVudCArIDEgOlxuICAgICAgaSA9PT0gJ3ByZXZpb3VzJyA/XG4gICAgICBjdXJyZW50IC0gMSA6XG4gICAgICBlbGVtZW50cy5pbmRleE9mKHRvTm9kZShpKSk7XG5cbiAgICAgIGlmIChmaW5pdGUpIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wKGksIDAsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBpICU9IGxlbmd0aDtcblxuICAgICAgcmV0dXJuIGkgPCAwID8gaSArIGxlbmd0aCA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICAgICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIChrZXkpID0+IGNhY2hlW2tleV0gfHwgKGNhY2hlW2tleV0gPSBmbihrZXkpKTtcbiAgICB9XG5cbiAgICBjbGFzcyBEZWZlcnJlZCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dHIoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lKSB7XG4gICAgICAgICAgYXR0cihlbGVtZW50LCBrZXksIG5hbWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7dmFyIF90b05vZGU7XG4gICAgICAgIHJldHVybiAoX3RvTm9kZSA9IHRvTm9kZShlbGVtZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90b05vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoZWwsIGF0dHIoZWwsIG5hbWUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0F0dHIoZWxlbWVudCwgbmFtZSkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gZWxlbWVudC5oYXNBdHRyaWJ1dGUobmFtZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHIoZWxlbWVudCwgbmFtZSkge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSB0b05vZGVzKGVsZW1lbnQpO1xuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgbmFtZS5zcGxpdCgnICcpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXRhKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFthdHRyaWJ1dGUsIGBkYXRhLSR7YXR0cmlidXRlfWBdKSB7XG4gICAgICAgIGlmIChoYXNBdHRyKGVsZW1lbnQsIG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHIoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2b2lkRWxlbWVudHMgPSB7XG4gICAgICBhcmVhOiB0cnVlLFxuICAgICAgYmFzZTogdHJ1ZSxcbiAgICAgIGJyOiB0cnVlLFxuICAgICAgY29sOiB0cnVlLFxuICAgICAgZW1iZWQ6IHRydWUsXG4gICAgICBocjogdHJ1ZSxcbiAgICAgIGltZzogdHJ1ZSxcbiAgICAgIGlucHV0OiB0cnVlLFxuICAgICAga2V5Z2VuOiB0cnVlLFxuICAgICAgbGluazogdHJ1ZSxcbiAgICAgIG1ldGE6IHRydWUsXG4gICAgICBwYXJhbTogdHJ1ZSxcbiAgICAgIHNvdXJjZTogdHJ1ZSxcbiAgICAgIHRyYWNrOiB0cnVlLFxuICAgICAgd2JyOiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc1ZvaWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IHZvaWRFbGVtZW50c1tlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmlzaWJsZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKFxuICAgICAgKGVsZW1lbnQpID0+IGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgZWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG5cbiAgICB9XG5cbiAgICBjb25zdCBzZWxJbnB1dCA9ICdpbnB1dCxzZWxlY3QsdGV4dGFyZWEsYnV0dG9uJztcbiAgICBmdW5jdGlvbiBpc0lucHV0KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IG1hdGNoZXMoZWxlbWVudCwgc2VsSW5wdXQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxGb2N1c2FibGUgPSBgJHtzZWxJbnB1dH0sYVtocmVmXSxbdGFiaW5kZXhdYDtcbiAgICBmdW5jdGlvbiBpc0ZvY3VzYWJsZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyhlbGVtZW50LCBzZWxGb2N1c2FibGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudChlbGVtZW50KSB7dmFyIF90b05vZGU7XG4gICAgICByZXR1cm4gKF90b05vZGUgPSB0b05vZGUoZWxlbWVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfdG9Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyJDEoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLmZpbHRlcigoZWxlbWVudCkgPT4gbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudCkgP1xuICAgICAgZWxlbWVudC5jbG9zZXN0KHN0YXJ0c1dpdGgoc2VsZWN0b3IsICc+JykgPyBzZWxlY3Rvci5zbGljZSgxKSA6IHNlbGVjdG9yKSA6XG4gICAgICB0b05vZGVzKGVsZW1lbnQpLlxuICAgICAgbWFwKChlbGVtZW50KSA9PiBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSkuXG4gICAgICBmaWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2l0aGluKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gaXNTdHJpbmcoc2VsZWN0b3IpID9cbiAgICAgICEhY2xvc2VzdChlbGVtZW50LCBzZWxlY3RvcikgOlxuICAgICAgdG9Ob2RlKHNlbGVjdG9yKS5jb250YWlucyh0b05vZGUoZWxlbWVudCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICAgIHdoaWxlIChlbGVtZW50ID0gcGFyZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGlmICghc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZWxlbWVudCA/IHRvTm9kZXMoZWxlbWVudC5jaGlsZHJlbikgOiBbXTtcbiAgICAgIHJldHVybiBzZWxlY3RvciA/IGZpbHRlciQxKGNoaWxkcmVuLCBzZWxlY3RvcikgOiBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRleChlbGVtZW50LCByZWYpIHtcbiAgICAgIHJldHVybiByZWYgPyB0b05vZGVzKGVsZW1lbnQpLmluZGV4T2YodG9Ob2RlKHJlZikpIDogY2hpbGRyZW4ocGFyZW50KGVsZW1lbnQpKS5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZmluZChzZWxlY3RvciwgZ2V0Q29udGV4dChzZWxlY3RvciwgY29udGV4dCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1ZXJ5QWxsKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZmluZEFsbChzZWxlY3RvciwgZ2V0Q29udGV4dChzZWxlY3RvciwgY29udGV4dCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0b05vZGUoX3F1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0LCAncXVlcnlTZWxlY3RvcicpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kQWxsKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQsICdxdWVyeVNlbGVjdG9yQWxsJykpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHRTZWxlY3RvclJlID0gLyhefFteXFxcXF0sKVxccypbIT4rfi1dLztcbiAgICBjb25zdCBpc0NvbnRleHRTZWxlY3RvciA9IG1lbW9pemUoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5tYXRjaChjb250ZXh0U2VsZWN0b3JSZSkpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dChzZWxlY3RvciwgY29udGV4dCA9IGRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gaXNTdHJpbmcoc2VsZWN0b3IpICYmIGlzQ29udGV4dFNlbGVjdG9yKHNlbGVjdG9yKSB8fCBpc0RvY3VtZW50KGNvbnRleHQpID9cbiAgICAgIGNvbnRleHQgOlxuICAgICAgY29udGV4dC5vd25lckRvY3VtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHRTYW5pdGl6ZVJlID0gLyhbIT4rfi1dKSg/PVxccytbIT4rfi1dfFxccyokKS9nO1xuICAgIGNvbnN0IHNhbmF0aXplID0gbWVtb2l6ZSgoc2VsZWN0b3IpID0+IHNlbGVjdG9yLnJlcGxhY2UoY29udGV4dFNhbml0aXplUmUsICckMSAqJykpO1xuXG4gICAgZnVuY3Rpb24gX3F1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0ID0gZG9jdW1lbnQsIHF1ZXJ5Rm4pIHtcbiAgICAgIGlmICghc2VsZWN0b3IgfHwgIWlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdG9yID0gc2FuYXRpemUoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAoaXNDb250ZXh0U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gJyc7XG4gICAgICAgIGZvciAobGV0IHNlbCBvZiBzcGxpdCkge1xuICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0O1xuXG4gICAgICAgICAgaWYgKHNlbFswXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWwuc3Vic3RyKDEpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY3R4ID0gY2xvc2VzdChwYXJlbnQoY29udGV4dCksIHNlbGVjdG9yc1swXSk7XG4gICAgICAgICAgICBzZWwgPSBzZWxlY3RvcnMuc2xpY2UoMSkuam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghc2VsLmxlbmd0aCAmJiBzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsWzBdID09PSAnLScpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbC5zdWJzdHIoMSkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gKGN0eCB8fCBjb250ZXh0KS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgY3R4ID0gbWF0Y2hlcyhwcmV2LCBzZWwuc3Vic3RyKDEpKSA/IHByZXYgOiBudWxsO1xuICAgICAgICAgICAgc2VsID0gc2VsZWN0b3JzLnNsaWNlKDEpLmpvaW4oJyAnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBzZWxlY3RvciArPSBgJHtzZWxlY3RvciA/ICcsJyA6ICcnfSR7ZG9tUGF0aChjdHgpfSAke3NlbH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQgPSBkb2N1bWVudDtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRbcXVlcnlGbl0oc2VsZWN0b3IpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RvclJlID0gLy4qP1teXFxcXF0oPzosfCQpL2c7XG5cbiAgICBjb25zdCBzcGxpdFNlbGVjdG9yID0gbWVtb2l6ZSgoc2VsZWN0b3IpID0+XG4gICAgc2VsZWN0b3IubWF0Y2goc2VsZWN0b3JSZSkubWFwKChzZWxlY3RvcikgPT4gc2VsZWN0b3IucmVwbGFjZSgvLCQvLCAnJykudHJpbSgpKSk7XG5cblxuICAgIGZ1bmN0aW9uIGRvbVBhdGgoZWxlbWVudCkge1xuICAgICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhdHRyKGVsZW1lbnQsICdpZCcpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBuYW1lcy51bnNoaWZ0KGAjJHtlc2NhcGUoaWQpfWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCB7IHRhZ05hbWUgfSA9IGVsZW1lbnQ7XG4gICAgICAgICAgaWYgKHRhZ05hbWUgIT09ICdIVE1MJykge1xuICAgICAgICAgICAgdGFnTmFtZSArPSBgOm50aC1jaGlsZCgke2luZGV4KGVsZW1lbnQpICsgMX0pYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZXMudW5zaGlmdCh0YWdOYW1lKTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZXMuam9pbignID4gJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlKGNzcykge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNzcykgPyBDU1MuZXNjYXBlKGNzcykgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbiguLi5hcmdzKSB7XG4gICAgICBsZXQgW3RhcmdldHMsIHR5cGVzLCBzZWxlY3RvciwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZV0gPSBnZXRBcmdzKGFyZ3MpO1xuXG4gICAgICBpZiAobGlzdGVuZXIubGVuZ3RoID4gMSkge1xuICAgICAgICBsaXN0ZW5lciA9IGRldGFpbChsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VDYXB0dXJlICE9IG51bGwgJiYgdXNlQ2FwdHVyZS5zZWxmKSB7XG4gICAgICAgIGxpc3RlbmVyID0gc2VsZkZpbHRlcihsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBsaXN0ZW5lciA9IGRlbGVnYXRlKHNlbGVjdG9yLCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKSA9PiBvZmYodGFyZ2V0cywgdHlwZXMsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmYoLi4uYXJncykge1xuICAgICAgbGV0IFt0YXJnZXRzLCB0eXBlcywsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2VdID0gZ2V0QXJncyhhcmdzKTtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25jZSguLi5hcmdzKSB7XG4gICAgICBjb25zdCBbZWxlbWVudCwgdHlwZXMsIHNlbGVjdG9yLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlLCBjb25kaXRpb25dID0gZ2V0QXJncyhhcmdzKTtcbiAgICAgIGNvbnN0IG9mZiA9IG9uKFxuICAgICAgZWxlbWVudCxcbiAgICAgIHR5cGVzLFxuICAgICAgc2VsZWN0b3IsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAhY29uZGl0aW9uIHx8IGNvbmRpdGlvbihlKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIG9mZigpO1xuICAgICAgICAgIGxpc3RlbmVyKGUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VDYXB0dXJlKTtcblxuXG4gICAgICByZXR1cm4gb2ZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0cywgZXZlbnQsIGRldGFpbCkge1xuICAgICAgcmV0dXJuIHRvRXZlbnRUYXJnZXRzKHRhcmdldHMpLmV2ZXJ5KCh0YXJnZXQpID0+IHRhcmdldC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlLCBkZXRhaWwpKSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChlLCBidWJibGVzID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IGZhbHNlLCBkZXRhaWwpIHtcbiAgICAgIGlmIChpc1N0cmluZyhlKSkge1xuICAgICAgICBlID0gbmV3IEN1c3RvbUV2ZW50KGUsIHsgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBcmdzKGFyZ3MpIHtcbiAgICAgIC8vIEV2ZW50IHRhcmdldHNcbiAgICAgIGFyZ3NbMF0gPSB0b0V2ZW50VGFyZ2V0cyhhcmdzWzBdKTtcblxuICAgICAgLy8gRXZlbnQgdHlwZXNcbiAgICAgIGlmIChpc1N0cmluZyhhcmdzWzFdKSkge1xuICAgICAgICBhcmdzWzFdID0gYXJnc1sxXS5zcGxpdCgnICcpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWxlZ2F0ZT9cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZ3NbMl0pKSB7XG4gICAgICAgIGFyZ3Muc3BsaWNlKDIsIDAsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZWdhdGUoc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9XG4gICAgICAgIHNlbGVjdG9yWzBdID09PSAnPicgP1xuICAgICAgICBmaW5kQWxsKHNlbGVjdG9yLCBlLmN1cnJlbnRUYXJnZXQpLlxuICAgICAgICByZXZlcnNlKCkuXG4gICAgICAgIGZpbHRlcigoZWxlbWVudCkgPT4gd2l0aGluKGUudGFyZ2V0LCBlbGVtZW50KSlbMF0gOlxuICAgICAgICBjbG9zZXN0KGUudGFyZ2V0LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICBlLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0YWlsKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gKGUpID0+IGlzQXJyYXkoZS5kZXRhaWwpID8gbGlzdGVuZXIoZSwgLi4uZS5kZXRhaWwpIDogbGlzdGVuZXIoZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZkZpbHRlcihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8IGUudGFyZ2V0ID09PSBlLmN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2FsbChudWxsLCBlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldCAmJiAnYWRkRXZlbnRMaXN0ZW5lcicgaW4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRXZlbnRUYXJnZXQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaXNFdmVudFRhcmdldCh0YXJnZXQpID8gdGFyZ2V0IDogdG9Ob2RlKHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9FdmVudFRhcmdldHModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh0YXJnZXQpID9cbiAgICAgIHRhcmdldC5tYXAodG9FdmVudFRhcmdldCkuZmlsdGVyKEJvb2xlYW4pIDpcbiAgICAgIGlzU3RyaW5nKHRhcmdldCkgP1xuICAgICAgZmluZEFsbCh0YXJnZXQpIDpcbiAgICAgIGlzRXZlbnRUYXJnZXQodGFyZ2V0KSA/XG4gICAgICBbdGFyZ2V0XSA6XG4gICAgICB0b05vZGVzKHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNUb3VjaChlKSB7XG4gICAgICByZXR1cm4gZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyB8fCAhIWUudG91Y2hlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFdmVudFBvcyhlKSB7dmFyIF9lJHRvdWNoZXMsIF9lJGNoYW5nZWRUb3VjaGVzO1xuICAgICAgY29uc3QgeyBjbGllbnRYOiB4LCBjbGllbnRZOiB5IH0gPSAoKF9lJHRvdWNoZXMgPSBlLnRvdWNoZXMpID09IG51bGwgPyB2b2lkIDAgOiBfZSR0b3VjaGVzWzBdKSB8fCAoKF9lJGNoYW5nZWRUb3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJGNoYW5nZWRUb3VjaGVzWzBdKSB8fCBlO1xuXG4gICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWpheCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVudiA9IHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHhocjogbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgIGJlZm9yZVNlbmQ6IG5vb3AsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJycsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkuXG4gICAgICB0aGVuKCgpID0+IGVudi5iZWZvcmVTZW5kKGVudikpLlxuICAgICAgdGhlbigoKSA9PiBzZW5kKHVybCwgZW52KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VuZCh1cmwsIGVudikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgeyB4aHIgfSA9IGVudjtcblxuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZW52KSB7XG4gICAgICAgICAgaWYgKHByb3AgaW4geGhyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB4aHJbcHJvcF0gPSBlbnZbcHJvcF07XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgfX1cbiAgICAgICAgfVxuXG4gICAgICAgIHhoci5vcGVuKGVudi5tZXRob2QudG9VcHBlckNhc2UoKSwgdXJsKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBlbnYuaGVhZGVycykge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgZW52LmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBvbih4aHIsICdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAwIHx8IHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgICAgICByZXNvbHZlKHhocik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIGFzc2lnbihFcnJvcih4aHIuc3RhdHVzVGV4dCksIHtcbiAgICAgICAgICAgICAgeGhyLFxuICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXNcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb24oeGhyLCAnZXJyb3InLCAoKSA9PiByZWplY3QoYXNzaWduKEVycm9yKCdOZXR3b3JrIEVycm9yJyksIHsgeGhyIH0pKSk7XG4gICAgICAgIG9uKHhociwgJ3RpbWVvdXQnLCAoKSA9PiByZWplY3QoYXNzaWduKEVycm9yKCdOZXR3b3JrIFRpbWVvdXQnKSwgeyB4aHIgfSkpKTtcblxuICAgICAgICB4aHIuc2VuZChlbnYuZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbWFnZShzcmMsIHNyY3NldCwgc2l6ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpemVzICYmIChpbWcuc2l6ZXMgPSBzaXplcyk7XG4gICAgICAgIHNyY3NldCAmJiAoaW1nLnNyY3NldCA9IHNyY3NldCk7XG4gICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjc3NOdW1iZXIgPSB7XG4gICAgICAnYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCc6IHRydWUsXG4gICAgICAnY29sdW1uLWNvdW50JzogdHJ1ZSxcbiAgICAgICdmaWxsLW9wYWNpdHknOiB0cnVlLFxuICAgICAgJ2ZsZXgtZ3Jvdyc6IHRydWUsXG4gICAgICAnZmxleC1zaHJpbmsnOiB0cnVlLFxuICAgICAgJ2ZvbnQtd2VpZ2h0JzogdHJ1ZSxcbiAgICAgICdsaW5lLWhlaWdodCc6IHRydWUsXG4gICAgICBvcGFjaXR5OiB0cnVlLFxuICAgICAgb3JkZXI6IHRydWUsXG4gICAgICBvcnBoYW5zOiB0cnVlLFxuICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiB0cnVlLFxuICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogdHJ1ZSxcbiAgICAgIHdpZG93czogdHJ1ZSxcbiAgICAgICd6LWluZGV4JzogdHJ1ZSxcbiAgICAgIHpvb206IHRydWVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3NzKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHkgPSAnJykge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSB0b05vZGVzKGVsZW1lbnQpO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BOYW1lKHByb3BlcnR5KTtcblxuICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICBpc051bWVyaWModmFsdWUpICYmICFjc3NOdW1iZXJbcHJvcGVydHldID9cbiAgICAgICAgICAgIGAke3ZhbHVlfXB4YCA6XG4gICAgICAgICAgICB2YWx1ZSB8fCBpc051bWJlcih2YWx1ZSkgP1xuICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBwcmlvcml0eSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSBjc3MoZWxlbWVudCwgcHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9wcztcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBwcmlvcml0eSA9IHZhbHVlO1xuICAgICAgICAgIGVhY2gocHJvcGVydHksICh2YWx1ZSwgcHJvcGVydHkpID0+IGNzcyhlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50c1swXTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2RvbS1jc3NzdHlsZWRlY2xhcmF0aW9uLXNldHByb3BlcnR5XG4gICAgY29uc3QgcHJvcE5hbWUgPSBtZW1vaXplKChuYW1lKSA9PiB2ZW5kb3JQcm9wTmFtZShuYW1lKSk7XG5cbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZShuYW1lKSB7XG4gICAgICBpZiAoc3RhcnRzV2l0aChuYW1lLCAnLS0nKSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cblxuICAgICAgbmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcblxuICAgICAgY29uc3QgeyBzdHlsZSB9ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICBpZiAobmFtZSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBwcmVmaXggb2YgWyd3ZWJraXQnLCAnbW96J10pIHtcbiAgICAgICAgY29uc3QgcHJlZml4ZWROYW1lID0gYC0ke3ByZWZpeH0tJHtuYW1lfWA7XG4gICAgICAgIGlmIChwcmVmaXhlZE5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ZWROYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgLi4uYXJncykge1xuICAgICAgYXBwbHkkMShlbGVtZW50LCBhcmdzLCAnYWRkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgLi4uYXJncykge1xuICAgICAgYXBwbHkkMShlbGVtZW50LCBhcmdzLCAncmVtb3ZlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCBjbHMpIHtcbiAgICAgIGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgKHZhbHVlKSA9PiAodmFsdWUgfHwgJycpLnJlcGxhY2UobmV3IFJlZ0V4cChgXFxcXGIke2Nsc31cXFxcYlxcXFxzP2AsICdnJyksICcnKSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlQ2xhc3MoZWxlbWVudCwgLi4uYXJncykge1xuICAgICAgYXJnc1swXSAmJiByZW1vdmVDbGFzcyhlbGVtZW50LCBhcmdzWzBdKTtcbiAgICAgIGFyZ3NbMV0gJiYgYWRkQ2xhc3MoZWxlbWVudCwgYXJnc1sxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xzKSB7XG4gICAgICBbY2xzXSA9IGdldENsYXNzZXMoY2xzKTtcbiAgICAgIHJldHVybiAhIWNscyAmJiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKG5vZGUpID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNscykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNscywgZm9yY2UpIHtcbiAgICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRDbGFzc2VzKGNscyk7XG5cbiAgICAgIGlmICghaXNVbmRlZmluZWQoZm9yY2UpKSB7XG4gICAgICAgIGZvcmNlID0gISFmb3JjZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRvTm9kZXMoZWxlbWVudCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjbHMgb2YgY2xhc3Nlcykge1xuICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnRvZ2dsZShjbHMsIGZvcmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5JDEoZWxlbWVudCwgYXJncywgZm4pIHtcbiAgICAgIGFyZ3MgPSBhcmdzLnJlZHVjZSgoYXJncywgYXJnKSA9PiBhcmdzLmNvbmNhdChnZXRDbGFzc2VzKGFyZykpLCBbXSk7XG5cbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0W2ZuXSguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDbGFzc2VzKHN0cikge1xuICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLnNwbGl0KC9cXHN8LC8pLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uJDEoZWxlbWVudCwgcHJvcHMsIGR1cmF0aW9uID0gNDAwLCB0aW1pbmcgPSAnbGluZWFyJykge1xuICAgICAgZHVyYXRpb24gPSBNYXRoLnJvdW5kKGR1cmF0aW9uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgKGVsZW1lbnQpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBjc3MoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgY3NzKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdHJpZ2dlcihlbGVtZW50LCAndHJhbnNpdGlvbmVuZCcpLCBkdXJhdGlvbik7XG5cbiAgICAgICAgb25jZShcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgJ3RyYW5zaXRpb25lbmQgdHJhbnNpdGlvbmNhbmNlbGVkJyxcbiAgICAgICAgKHsgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCAndWstdHJhbnNpdGlvbicpO1xuICAgICAgICAgIGNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAnJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0eXBlID09PSAndHJhbnNpdGlvbmNhbmNlbGVkJyA/IHJlamVjdCgpIDogcmVzb2x2ZShlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBzZWxmOiB0cnVlIH0pO1xuXG5cbiAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgJ3VrLXRyYW5zaXRpb24nKTtcbiAgICAgICAgY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKHByb3BzKS5tYXAocHJvcE5hbWUpLmpvaW4oJywnKSxcbiAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9ufW1zYCxcbiAgICAgICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IHRpbWluZyxcbiAgICAgICAgICAuLi5wcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGNvbnN0IFRyYW5zaXRpb24gPSB7XG4gICAgICBzdGFydDogdHJhbnNpdGlvbiQxLFxuXG4gICAgICBhc3luYyBzdG9wKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAndHJhbnNpdGlvbmVuZCcpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0sXG5cbiAgICAgIGFzeW5jIGNhbmNlbChlbGVtZW50KSB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25jYW5jZWxlZCcpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0sXG5cbiAgICAgIGluUHJvZ3Jlc3MoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZWxlbWVudCwgJ3VrLXRyYW5zaXRpb24nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYW5pbWF0aW9uUHJlZml4ID0gJ3VrLWFuaW1hdGlvbi0nO1xuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSQyKGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24gPSAyMDAsIG9yaWdpbiwgb3V0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICB0b05vZGVzKGVsZW1lbnQpLm1hcChcbiAgICAgIChlbGVtZW50KSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ2FuaW1hdGlvbmNhbmNlbGVkJyk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0cmlnZ2VyKGVsZW1lbnQsICdhbmltYXRpb25lbmQnKSwgZHVyYXRpb24pO1xuXG4gICAgICAgIG9uY2UoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgICdhbmltYXRpb25lbmQgYW5pbWF0aW9uY2FuY2VsZWQnLFxuICAgICAgICAoeyB0eXBlIH0pID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgdHlwZSA9PT0gJ2FuaW1hdGlvbmNhbmNlbGVkJyA/IHJlamVjdCgpIDogcmVzb2x2ZShlbGVtZW50KTtcblxuICAgICAgICAgIGNzcyhlbGVtZW50LCAnYW5pbWF0aW9uRHVyYXRpb24nLCAnJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCBgJHthbmltYXRpb25QcmVmaXh9XFxcXFMqYCk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuXG4gICAgICAgIGNzcyhlbGVtZW50LCAnYW5pbWF0aW9uRHVyYXRpb24nLCBgJHtkdXJhdGlvbn1tc2ApO1xuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBhbmltYXRpb24sIGFuaW1hdGlvblByZWZpeCArIChvdXQgPyAnbGVhdmUnIDogJ2VudGVyJykpO1xuXG4gICAgICAgIGlmIChzdGFydHNXaXRoKGFuaW1hdGlvbiwgYW5pbWF0aW9uUHJlZml4KSkge1xuICAgICAgICAgIG9yaWdpbiAmJiBhZGRDbGFzcyhlbGVtZW50LCBgdWstdHJhbnNmb3JtLW9yaWdpbi0ke29yaWdpbn1gKTtcbiAgICAgICAgICBvdXQgJiYgYWRkQ2xhc3MoZWxlbWVudCwgYCR7YW5pbWF0aW9uUHJlZml4fXJldmVyc2VgKTtcbiAgICAgICAgfVxuICAgICAgfSkpKTtcblxuXG4gICAgfVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc1JlID0gbmV3IFJlZ0V4cChgJHthbmltYXRpb25QcmVmaXh9KGVudGVyfGxlYXZlKWApO1xuXG4gICAgY29uc3QgQW5pbWF0aW9uID0ge1xuICAgICAgaW46IGFuaW1hdGUkMixcblxuICAgICAgb3V0KGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0ZSQyKGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIG9yaWdpbiwgdHJ1ZSk7XG4gICAgICB9LFxuXG4gICAgICBpblByb2dyZXNzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGluUHJvZ3Jlc3NSZS50ZXN0KGF0dHIoZWxlbWVudCwgJ2NsYXNzJykpO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAnYW5pbWF0aW9uY2FuY2VsZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVhZHkoZm4pIHtcbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvbmNlKGRvY3VtZW50LCAnRE9NQ29udGVudExvYWRlZCcsIGZuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1RhZyhlbGVtZW50LCB0YWdOYW1lKSB7dmFyIF9lbGVtZW50JHRhZ05hbWU7XG4gICAgICByZXR1cm4gKGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IChfZWxlbWVudCR0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkdGFnTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtcHR5KGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh0bWwocGFyZW50LCBodG1sKSB7XG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoaHRtbCkgPyAkKHBhcmVudCkuaW5uZXJIVE1MIDogYXBwZW5kKGVtcHR5KHBhcmVudCksIGh0bWwpO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXBlbmQgPSBhcHBseUZuKCdwcmVwZW5kJyk7XG4gICAgY29uc3QgYXBwZW5kID0gYXBwbHlGbignYXBwZW5kJyk7XG4gICAgY29uc3QgYmVmb3JlID0gYXBwbHlGbignYmVmb3JlJyk7XG4gICAgY29uc3QgYWZ0ZXIgPSBhcHBseUZuKCdhZnRlcicpO1xuXG4gICAgZnVuY3Rpb24gYXBwbHlGbihmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWYsIGVsZW1lbnQpIHt2YXIgXyQ7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdG9Ob2Rlcyhpc1N0cmluZyhlbGVtZW50KSA/IGZyYWdtZW50KGVsZW1lbnQpIDogZWxlbWVudCk7XG4gICAgICAgIChfJCA9ICQocmVmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF8kW2ZuXSguLi5ub2Rlcyk7XG4gICAgICAgIHJldHVybiB1bndyYXBTaW5nbGUobm9kZXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUkMShlbGVtZW50KSB7XG4gICAgICB0b05vZGVzKGVsZW1lbnQpLmZvckVhY2goKGVsZW1lbnQpID0+IGVsZW1lbnQucmVtb3ZlKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBBbGwoZWxlbWVudCwgc3RydWN0dXJlKSB7XG4gICAgICBzdHJ1Y3R1cmUgPSB0b05vZGUoYmVmb3JlKGVsZW1lbnQsIHN0cnVjdHVyZSkpO1xuXG4gICAgICB3aGlsZSAoc3RydWN0dXJlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgc3RydWN0dXJlID0gc3RydWN0dXJlLmZpcnN0Q2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZChzdHJ1Y3R1cmUsIGVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBJbm5lcihlbGVtZW50LCBzdHJ1Y3R1cmUpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKFxuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5tYXAoKGVsZW1lbnQpID0+IGVsZW1lbnQuaGFzQ2hpbGROb2RlcygpID9cbiAgICAgIHdyYXBBbGwodG9Ob2RlcyhlbGVtZW50LmNoaWxkTm9kZXMpLCBzdHJ1Y3R1cmUpIDpcbiAgICAgIGFwcGVuZChlbGVtZW50LCBzdHJ1Y3R1cmUpKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVud3JhcChlbGVtZW50KSB7XG4gICAgICB0b05vZGVzKGVsZW1lbnQpLlxuICAgICAgbWFwKHBhcmVudCkuXG4gICAgICBmaWx0ZXIoKHZhbHVlLCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXgpLlxuICAgICAgZm9yRWFjaCgocGFyZW50KSA9PiBwYXJlbnQucmVwbGFjZVdpdGgoLi4ucGFyZW50LmNoaWxkTm9kZXMpKTtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFnbWVudFJlID0gL15cXHMqPChcXHcrfCEpW14+XSo+LztcbiAgICBjb25zdCBzaW5nbGVUYWdSZSA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+KT8kLztcblxuICAgIGZ1bmN0aW9uIGZyYWdtZW50KGh0bWwpIHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBzaW5nbGVUYWdSZS5leGVjKGh0bWwpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobWF0Y2hlc1sxXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaWYgKGZyYWdtZW50UmUudGVzdChodG1sKSkge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBodG1sLnRyaW0oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIudGV4dENvbnRlbnQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW53cmFwU2luZ2xlKGNvbnRhaW5lci5jaGlsZE5vZGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bndyYXBTaW5nbGUobm9kZXMpIHtcbiAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAxID8gbm9kZXMgOiBub2Rlc1swXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseShub2RlLCBmbikge1xuICAgICAgaWYgKCFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmbihub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBhcHBseShub2RlLCBmbik7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBpc0h0bWwoc2VsZWN0b3IpID8gdG9Ob2RlKGZyYWdtZW50KHNlbGVjdG9yKSkgOiBmaW5kKHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGlzSHRtbChzZWxlY3RvcikgPyB0b05vZGVzKGZyYWdtZW50KHNlbGVjdG9yKSkgOiBmaW5kQWxsKHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0h0bWwoc3RyKSB7XG4gICAgICByZXR1cm4gaXNTdHJpbmcoc3RyKSAmJiBzdGFydHNXaXRoKHN0ci50cmltKCksICc8Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGlycyQxID0ge1xuICAgICAgd2lkdGg6IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgaGVpZ2h0OiBbJ3RvcCcsICdib3R0b20nXVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkaW1lbnNpb25zJDEoZWxlbWVudCkge1xuICAgICAgY29uc3QgcmVjdCA9IGlzRWxlbWVudChlbGVtZW50KSA/XG4gICAgICB0b05vZGUoZWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOlxuICAgICAgeyBoZWlnaHQ6IGhlaWdodChlbGVtZW50KSwgd2lkdGg6IHdpZHRoKGVsZW1lbnQpLCB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgYm90dG9tOiByZWN0LnRvcCArIHJlY3QuaGVpZ2h0LFxuICAgICAgICByaWdodDogcmVjdC5sZWZ0ICsgcmVjdC53aWR0aFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQoZWxlbWVudCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSBkaW1lbnNpb25zJDEoZWxlbWVudCk7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsWSwgc2Nyb2xsWCB9ID0gdG9XaW5kb3coZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IG9mZnNldEJ5ID0geyBoZWlnaHQ6IHNjcm9sbFksIHdpZHRoOiBzY3JvbGxYIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBkaXIgaW4gZGlycyQxKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGRpcnMkMVtkaXJdKSB7XG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0W3Byb3BdICs9IG9mZnNldEJ5W2Rpcl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvcyA9IGNzcyhlbGVtZW50LCAncG9zaXRpb24nKTtcblxuICAgICAgZWFjaChjc3MoZWxlbWVudCwgWydsZWZ0JywgJ3RvcCddKSwgKHZhbHVlLCBwcm9wKSA9PiBjc3MoXG4gICAgICBlbGVtZW50LFxuICAgICAgcHJvcCxcbiAgICAgIGNvb3JkaW5hdGVzW3Byb3BdIC1cbiAgICAgIGN1cnJlbnRPZmZzZXRbcHJvcF0gK1xuICAgICAgdG9GbG9hdChwb3MgPT09ICdhYnNvbHV0ZScgJiYgdmFsdWUgPT09ICdhdXRvJyA/IHBvc2l0aW9uKGVsZW1lbnQpW3Byb3BdIDogdmFsdWUpKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGxldCB7IHRvcCwgbGVmdCB9ID0gb2Zmc2V0KGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQ6IHsgYm9keSwgZG9jdW1lbnRFbGVtZW50IH0sXG4gICAgICAgIG9mZnNldFBhcmVudFxuICAgICAgfSA9IHRvTm9kZShlbGVtZW50KTtcbiAgICAgIGxldCBwYXJlbnQgPSBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICB3aGlsZSAoXG4gICAgICBwYXJlbnQgJiYgKFxuICAgICAgcGFyZW50ID09PSBib2R5IHx8IHBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSAmJlxuICAgICAgY3NzKHBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKVxuICAgICAge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWxlbWVudChwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE9mZnNldCA9IG9mZnNldChwYXJlbnQpO1xuICAgICAgICB0b3AgLT0gcGFyZW50T2Zmc2V0LnRvcCArIHRvRmxvYXQoY3NzKHBhcmVudCwgJ2JvcmRlclRvcFdpZHRoJykpO1xuICAgICAgICBsZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0ICsgdG9GbG9hdChjc3MocGFyZW50LCAnYm9yZGVyTGVmdFdpZHRoJykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCAtIHRvRmxvYXQoY3NzKGVsZW1lbnQsICdtYXJnaW5Ub3AnKSksXG4gICAgICAgIGxlZnQ6IGxlZnQgLSB0b0Zsb2F0KGNzcyhlbGVtZW50LCAnbWFyZ2luTGVmdCcpKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRQb3NpdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCBvZmZzZXQgPSBbZWxlbWVudC5vZmZzZXRUb3AsIGVsZW1lbnQub2Zmc2V0TGVmdF07XG5cbiAgICAgIHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgb2Zmc2V0WzBdICs9IGVsZW1lbnQub2Zmc2V0VG9wICsgdG9GbG9hdChjc3MoZWxlbWVudCwgYGJvcmRlclRvcFdpZHRoYCkpO1xuICAgICAgICBvZmZzZXRbMV0gKz0gZWxlbWVudC5vZmZzZXRMZWZ0ICsgdG9GbG9hdChjc3MoZWxlbWVudCwgYGJvcmRlckxlZnRXaWR0aGApKTtcblxuICAgICAgICBpZiAoY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgY29uc3Qgd2luID0gdG9XaW5kb3coZWxlbWVudCk7XG4gICAgICAgICAgb2Zmc2V0WzBdICs9IHdpbi5zY3JvbGxZO1xuICAgICAgICAgIG9mZnNldFsxXSArPSB3aW4uc2Nyb2xsWDtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgY29uc3QgaGVpZ2h0ID0gZGltZW5zaW9uKCdoZWlnaHQnKTtcbiAgICBjb25zdCB3aWR0aCA9IGRpbWVuc2lvbignd2lkdGgnKTtcblxuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbihwcm9wKSB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IHVjZmlyc3QocHJvcCk7XG4gICAgICByZXR1cm4gKGVsZW1lbnQsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50W2Bpbm5lciR7cHJvcE5hbWV9YF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGVsZW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRvY1tgb2Zmc2V0JHtwcm9wTmFtZX1gXSwgZG9jW2BzY3JvbGwke3Byb3BOYW1lfWBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgdmFsdWUgPSBjc3MoZWxlbWVudCwgcHJvcCk7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ2F1dG8nID8gZWxlbWVudFtgb2Zmc2V0JHtwcm9wTmFtZX1gXSA6IHRvRmxvYXQodmFsdWUpIHx8IDA7XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgLSBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3NzKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICAhdmFsdWUgJiYgdmFsdWUgIT09IDAgPyAnJyA6ICt2YWx1ZSArIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsIHByb3ApICsgJ3B4Jyk7XG5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wLCBzaXppbmcgPSAnYm9yZGVyLWJveCcpIHtcbiAgICAgIHJldHVybiBjc3MoZWxlbWVudCwgJ2JveFNpemluZycpID09PSBzaXppbmcgP1xuICAgICAgc3VtQnkoXG4gICAgICBkaXJzJDFbcHJvcF0ubWFwKHVjZmlyc3QpLFxuICAgICAgKHByb3ApID0+IHRvRmxvYXQoY3NzKGVsZW1lbnQsIGBwYWRkaW5nJHtwcm9wfWApKSArXG4gICAgICB0b0Zsb2F0KGNzcyhlbGVtZW50LCBgYm9yZGVyJHtwcm9wfVdpZHRoYCkpKSA6XG5cbiAgICAgIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmxpcFBvc2l0aW9uKHBvcykge1xuICAgICAgZm9yIChjb25zdCBkaXIgaW4gZGlycyQxKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiBkaXJzJDFbZGlyXSkge1xuICAgICAgICAgIGlmIChkaXJzJDFbZGlyXVtpXSA9PT0gcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlycyQxW2Rpcl1bMSAtIGldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b1B4KHZhbHVlLCBwcm9wZXJ0eSA9ICd3aWR0aCcsIGVsZW1lbnQgPSB3aW5kb3csIG9mZnNldERpbSA9IGZhbHNlKSB7XG4gICAgICBpZiAoIWlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdG9GbG9hdCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdW1CeShwYXJzZUNhbGModmFsdWUpLCAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdW5pdCA9IHBhcnNlVW5pdCh2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHVuaXQgP1xuICAgICAgICBwZXJjZW50KFxuICAgICAgICB1bml0ID09PSAndmgnID9cbiAgICAgICAgZ2V0Vmlld3BvcnRIZWlnaHQoKSA6XG4gICAgICAgIHVuaXQgPT09ICd2dycgP1xuICAgICAgICB3aWR0aCh0b1dpbmRvdyhlbGVtZW50KSkgOlxuICAgICAgICBvZmZzZXREaW0gP1xuICAgICAgICBlbGVtZW50W2BvZmZzZXQke3VjZmlyc3QocHJvcGVydHkpfWBdIDpcbiAgICAgICAgZGltZW5zaW9ucyQxKGVsZW1lbnQpW3Byb3BlcnR5XSxcbiAgICAgICAgdmFsdWUpIDpcblxuICAgICAgICB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGNSZSA9IC8tP1xcZCsoPzpcXC5cXGQrKT8oPzp2W3doXXwlfHB4KT8vZztcbiAgICBjb25zdCBwYXJzZUNhbGMgPSBtZW1vaXplKChjYWxjKSA9PiBjYWxjLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzL2csICcnKS5tYXRjaChjYWxjUmUpIHx8IFtdKTtcbiAgICBjb25zdCB1bml0UmUkMSA9IC8oPzp2W2h3XXwlKSQvO1xuICAgIGNvbnN0IHBhcnNlVW5pdCA9IG1lbW9pemUoKHN0cikgPT4gKHN0ci5tYXRjaCh1bml0UmUkMSkgfHwgW10pWzBdKTtcblxuICAgIGZ1bmN0aW9uIHBlcmNlbnQoYmFzZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlICogdG9GbG9hdCh2YWx1ZSkgLyAxMDA7XG4gICAgfVxuXG4gICAgbGV0IHZoO1xuICAgIGxldCB2aEVsO1xuXG4gICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnRIZWlnaHQoKSB7XG4gICAgICBpZiAodmgpIHtcbiAgICAgICAgcmV0dXJuIHZoO1xuICAgICAgfVxuICAgICAgaWYgKCF2aEVsKSB7XG4gICAgICAgIHZoRWwgPSAkKCc8ZGl2PicpO1xuICAgICAgICBjc3ModmhFbCwge1xuICAgICAgICAgIGhlaWdodDogJzEwMHZoJyxcbiAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgb24od2luZG93LCAncmVzaXplJywgKCkgPT4gdmggPSBudWxsKTtcbiAgICAgIH1cblxuICAgICAgYXBwZW5kKGRvY3VtZW50LmJvZHksIHZoRWwpO1xuICAgICAgdmggPSB2aEVsLmNsaWVudEhlaWdodDtcbiAgICAgIHJlbW92ZSQxKHZoRWwpO1xuICAgICAgcmV0dXJuIHZoO1xuICAgIH1cblxuICAgIGNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IGlzUnRsID0gaW5Ccm93c2VyICYmIGRvY3VtZW50LmRpciA9PT0gJ3J0bCc7XG5cbiAgICBjb25zdCBoYXNUb3VjaCA9IGluQnJvd3NlciAmJiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG4gICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGluQnJvd3NlciAmJiB3aW5kb3cuUG9pbnRlckV2ZW50O1xuXG4gICAgY29uc3QgcG9pbnRlckRvd24kMSA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmRvd24nIDogaGFzVG91Y2ggPyAndG91Y2hzdGFydCcgOiAnbW91c2Vkb3duJztcbiAgICBjb25zdCBwb2ludGVyTW92ZSQxID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVybW92ZScgOiBoYXNUb3VjaCA/ICd0b3VjaG1vdmUnIDogJ21vdXNlbW92ZSc7XG4gICAgY29uc3QgcG9pbnRlclVwJDEgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJ1cCcgOiBoYXNUb3VjaCA/ICd0b3VjaGVuZCcgOiAnbW91c2V1cCc7XG4gICAgY29uc3QgcG9pbnRlckVudGVyID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyZW50ZXInIDogaGFzVG91Y2ggPyAnJyA6ICdtb3VzZWVudGVyJztcbiAgICBjb25zdCBwb2ludGVyTGVhdmUgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJsZWF2ZScgOiBoYXNUb3VjaCA/ICcnIDogJ21vdXNlbGVhdmUnO1xuICAgIGNvbnN0IHBvaW50ZXJDYW5jZWwgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJjYW5jZWwnIDogJ3RvdWNoY2FuY2VsJztcblxuICAgIC8qXG4gICAgICAgIEJhc2VkIG9uOlxuICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMTYgV2lsc29uIFBhZ2Ugd2lsc29ucGFnZUBtZS5jb21cbiAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3dpbHNvbnBhZ2UvZmFzdGRvbVxuICAgICovXG5cbiAgICBjb25zdCBmYXN0ZG9tID0ge1xuICAgICAgcmVhZHM6IFtdLFxuICAgICAgd3JpdGVzOiBbXSxcblxuICAgICAgcmVhZCh0YXNrKSB7XG4gICAgICAgIHRoaXMucmVhZHMucHVzaCh0YXNrKTtcbiAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgIH0sXG5cbiAgICAgIHdyaXRlKHRhc2spIHtcbiAgICAgICAgdGhpcy53cml0ZXMucHVzaCh0YXNrKTtcbiAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgIH0sXG5cbiAgICAgIGNsZWFyKHRhc2spIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMucmVhZHMsIHRhc2spO1xuICAgICAgICByZW1vdmUodGhpcy53cml0ZXMsIHRhc2spO1xuICAgICAgfSxcblxuICAgICAgZmx1c2hcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZmx1c2gocmVjdXJzaW9uKSB7XG4gICAgICBydW5UYXNrcyhmYXN0ZG9tLnJlYWRzKTtcbiAgICAgIHJ1blRhc2tzKGZhc3Rkb20ud3JpdGVzLnNwbGljZSgwKSk7XG5cbiAgICAgIGZhc3Rkb20uc2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChmYXN0ZG9tLnJlYWRzLmxlbmd0aCB8fCBmYXN0ZG9tLndyaXRlcy5sZW5ndGgpIHtcbiAgICAgICAgc2NoZWR1bGVGbHVzaChyZWN1cnNpb24gKyAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBSRUNVUlNJT05fTElNSVQgPSA0O1xuICAgIGZ1bmN0aW9uIHNjaGVkdWxlRmx1c2gocmVjdXJzaW9uKSB7XG4gICAgICBpZiAoZmFzdGRvbS5zY2hlZHVsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmYXN0ZG9tLnNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBpZiAocmVjdXJzaW9uICYmIHJlY3Vyc2lvbiA8IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGZsdXNoKHJlY3Vyc2lvbikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGZsdXNoKDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5UYXNrcyh0YXNrcykge1xuICAgICAgbGV0IHRhc2s7XG4gICAgICB3aGlsZSAodGFzayA9IHRhc2tzLnNoaWZ0KCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0YXNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpdGVtKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgICByZXR1cm4gfmluZGV4ICYmIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTW91c2VUcmFja2VyKCkge31cblxuICAgIE1vdXNlVHJhY2tlci5wcm90b3R5cGUgPSB7XG4gICAgICBwb3NpdGlvbnM6IFtdLFxuXG4gICAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IFtdO1xuXG4gICAgICAgIGxldCBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy51bmJpbmQgPSBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIChlKSA9PiBwb3NpdGlvbiA9IGdldEV2ZW50UG9zKGUpKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbnMubGVuZ3RoID4gNSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwKTtcbiAgICAgIH0sXG5cbiAgICAgIGNhbmNlbCgpIHt2YXIgX3RoaXMkdW5iaW5kO1xuICAgICAgICAoX3RoaXMkdW5iaW5kID0gdGhpcy51bmJpbmQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR1bmJpbmQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCAmJiBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfSxcblxuICAgICAgbW92ZXNUbyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gcDtcblxuICAgICAgICBjb25zdCBbcHJldlBvc2l0aW9uXSA9IHRoaXMucG9zaXRpb25zO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGxhc3QodGhpcy5wb3NpdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXRoID0gW3ByZXZQb3NpdGlvbiwgcG9zaXRpb25dO1xuXG4gICAgICAgIGlmIChwb2ludEluUmVjdChwb3NpdGlvbiwgcCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkaWFnb25hbHMgPSBbXG4gICAgICAgIFtcbiAgICAgICAgeyB4OiBsZWZ0LCB5OiB0b3AgfSxcbiAgICAgICAgeyB4OiByaWdodCwgeTogYm90dG9tIH1dLFxuXG4gICAgICAgIFtcbiAgICAgICAgeyB4OiBsZWZ0LCB5OiBib3R0b20gfSxcbiAgICAgICAgeyB4OiByaWdodCwgeTogdG9wIH1dXTtcblxuXG5cbiAgICAgICAgcmV0dXJuIGRpYWdvbmFscy5zb21lKChkaWFnb25hbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGludGVyc2VjdChwYXRoLCBkaWFnb25hbCk7XG4gICAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbiAmJiBwb2ludEluUmVjdChpbnRlcnNlY3Rpb24sIHApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5zcGlyZWQgYnkgaHR0cDovL3BhdWxib3Vya2UubmV0L2dlb21ldHJ5L3BvaW50bGluZXBsYW5lL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdChbeyB4OiB4MSwgeTogeTEgfSwgeyB4OiB4MiwgeTogeTIgfV0sIFt7IHg6IHgzLCB5OiB5MyB9LCB7IHg6IHg0LCB5OiB5NCB9XSkge1xuICAgICAgY29uc3QgZGVub21pbmF0b3IgPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgICAgIC8vIExpbmVzIGFyZSBwYXJhbGxlbFxuICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdWEgPSAoKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpKSAvIGRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAodWEgPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgIHJldHVybiB7IHg6IHgxICsgdWEgKiAoeDIgLSB4MSksIHk6IHkxICsgdWEgKiAoeTIgLSB5MSkgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvYnNlcnZlSW50ZXJzZWN0aW9uKHRhcmdldHMsIGNiLCBvcHRpb25zLCBpbnRlcnNlY3RpbmcgPSB0cnVlKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgIGludGVyc2VjdGluZyA/XG4gICAgICAoZW50cmllcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgaWYgKGVudHJpZXMuc29tZSgoZW50cnkpID0+IGVudHJ5LmlzSW50ZXJzZWN0aW5nKSkge1xuICAgICAgICAgIGNiKGVudHJpZXMsIG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfSA6XG4gICAgICBjYixcbiAgICAgIG9wdGlvbnMpO1xuXG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXModGFyZ2V0cykpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNSZXNpemVPYnNlcnZlciA9IGluQnJvd3NlciAmJiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXI7XG4gICAgZnVuY3Rpb24gb2JzZXJ2ZVJlc2l6ZSh0YXJnZXRzLCBjYiwgb3B0aW9ucyA9IHsgYm94OiAnYm9yZGVyLWJveCcgfSkge1xuICAgICAgaWYgKGhhc1Jlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlKFJlc2l6ZU9ic2VydmVyLCB0YXJnZXRzLCBjYiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZhbGxiYWNrIFNhZmFyaSA8IDEzLjFcbiAgICAgIGluaXRSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgbGlzdGVuZXJzLmFkZChjYik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IGxpc3RlbmVycztcbiAgICBmdW5jdGlvbiBpbml0UmVzaXplTGlzdGVuZXIoKSB7XG4gICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuXG4gICAgICAvLyB0aHJvdHRsZSAncmVzaXplJ1xuICAgICAgbGV0IHBlbmRpbmdSZXNpemU7XG4gICAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChwZW5kaW5nUmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdSZXNpemUgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcGVuZGluZ1Jlc2l6ZSA9IGZhbHNlKTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBvbih3aW5kb3csICdsb2FkIHJlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBvbihkb2N1bWVudCwgJ2xvYWRlZG1ldGFkYXRhIGxvYWQnLCBoYW5kbGVSZXNpemUsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmVNdXRhdGlvbih0YXJnZXRzLCBjYiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9ic2VydmUoTXV0YXRpb25PYnNlcnZlciwgdGFyZ2V0cywgY2IsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmUoT2JzZXJ2ZXIsIHRhcmdldHMsIGNiLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBPYnNlcnZlcihjYik7XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXModGFyZ2V0cykpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJhdHMgPSB7fTtcblxuICAgIHN0cmF0cy5ldmVudHMgPVxuICAgIHN0cmF0cy5jcmVhdGVkID1cbiAgICBzdHJhdHMuYmVmb3JlQ29ubmVjdCA9XG4gICAgc3RyYXRzLmNvbm5lY3RlZCA9XG4gICAgc3RyYXRzLmJlZm9yZURpc2Nvbm5lY3QgPVxuICAgIHN0cmF0cy5kaXNjb25uZWN0ZWQgPVxuICAgIHN0cmF0cy5kZXN0cm95ID1cbiAgICBjb25jYXRTdHJhdDtcblxuICAgIC8vIGFyZ3Mgc3RyYXRlZ3lcbiAgICBzdHJhdHMuYXJncyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWwgIT09IGZhbHNlICYmIGNvbmNhdFN0cmF0KGNoaWxkVmFsIHx8IHBhcmVudFZhbCk7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSBzdHJhdGVneVxuICAgIHN0cmF0cy51cGRhdGUgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHNvcnRCeSQxKFxuICAgICAgY29uY2F0U3RyYXQocGFyZW50VmFsLCBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IHsgcmVhZDogY2hpbGRWYWwgfSA6IGNoaWxkVmFsKSxcbiAgICAgICdvcmRlcicpO1xuXG4gICAgfTtcblxuICAgIC8vIHByb3BlcnR5IHN0cmF0ZWd5XG4gICAgc3RyYXRzLnByb3BzID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIGlmIChpc0FycmF5KGNoaWxkVmFsKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBjaGlsZFZhbCkge1xuICAgICAgICAgIHZhbHVlW2tleV0gPSBTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRWYWwgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmF0cy5tZXRob2RzKHBhcmVudFZhbCwgY2hpbGRWYWwpO1xuICAgIH07XG5cbiAgICAvLyBleHRlbmQgc3RyYXRlZ3lcbiAgICBzdHJhdHMuY29tcHV0ZWQgPSBzdHJhdHMubWV0aG9kcyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWwgPyBwYXJlbnRWYWwgPyB7IC4uLnBhcmVudFZhbCwgLi4uY2hpbGRWYWwgfSA6IGNoaWxkVmFsIDogcGFyZW50VmFsO1xuICAgIH07XG5cbiAgICAvLyBkYXRhIHN0cmF0ZWd5XG4gICAgc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICAgIGlmICghdm0pIHtcbiAgICAgICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodm0pIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZuRGF0YShwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICAgICAgcmV0dXJuIHN0cmF0cy5jb21wdXRlZChcbiAgICAgIGlzRnVuY3Rpb24ocGFyZW50VmFsKSA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSkgOiBwYXJlbnRWYWwsXG4gICAgICBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKSA6IGNoaWxkVmFsKTtcblxuICAgIH1cblxuICAgIC8vIGNvbmNhdCBzdHJhdGVneVxuICAgIGZ1bmN0aW9uIGNvbmNhdFN0cmF0KHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIHBhcmVudFZhbCA9IHBhcmVudFZhbCAmJiAhaXNBcnJheShwYXJlbnRWYWwpID8gW3BhcmVudFZhbF0gOiBwYXJlbnRWYWw7XG5cbiAgICAgIHJldHVybiBjaGlsZFZhbCA/XG4gICAgICBwYXJlbnRWYWwgP1xuICAgICAgcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbCkgOlxuICAgICAgaXNBcnJheShjaGlsZFZhbCkgP1xuICAgICAgY2hpbGRWYWwgOlxuICAgICAgW2NoaWxkVmFsXSA6XG4gICAgICBwYXJlbnRWYWw7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBzdHJhdGVneVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoY2hpbGRWYWwpID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICBmb3IgKGNvbnN0IG1peGluIG9mIGNoaWxkLm1peGlucykge1xuICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyZW50KSB7XG4gICAgICAgIG1lcmdlS2V5KGtleSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgICAgIG1lcmdlS2V5KGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWVyZ2VLZXkoa2V5KSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IChzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQpKHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRpb25zLCBhcmdzID0gW10pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID9cbiAgICAgICAgc3RhcnRzV2l0aChvcHRpb25zLCAneycpID9cbiAgICAgICAgSlNPTi5wYXJzZShvcHRpb25zKSA6XG4gICAgICAgIGFyZ3MubGVuZ3RoICYmICFpbmNsdWRlcyhvcHRpb25zLCAnOicpID9cbiAgICAgICAgeyBbYXJnc1swXV06IG9wdGlvbnMgfSA6XG4gICAgICAgIG9wdGlvbnMuc3BsaXQoJzsnKS5yZWR1Y2UoKG9wdGlvbnMsIG9wdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IG9wdGlvbi5zcGxpdCgvOiguKikvKTtcbiAgICAgICAgICBpZiAoa2V5ICYmICFpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnNba2V5LnRyaW0oKV0gPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9LCB7fSkgOlxuICAgICAgICB7fTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBsYXkoZWwpIHtcbiAgICAgIGlmIChpc0lGcmFtZShlbCkpIHtcbiAgICAgICAgY2FsbChlbCwgeyBmdW5jOiAncGxheVZpZGVvJywgbWV0aG9kOiAncGxheScgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0hUTUw1KGVsKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsLnBsYXkoKS5jYXRjaChub29wKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9fVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdXNlKGVsKSB7XG4gICAgICBpZiAoaXNJRnJhbWUoZWwpKSB7XG4gICAgICAgIGNhbGwoZWwsIHsgZnVuYzogJ3BhdXNlVmlkZW8nLCBtZXRob2Q6ICdwYXVzZScgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0hUTUw1KGVsKSkge1xuICAgICAgICBlbC5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11dGUoZWwpIHtcbiAgICAgIGlmIChpc0lGcmFtZShlbCkpIHtcbiAgICAgICAgY2FsbChlbCwgeyBmdW5jOiAnbXV0ZScsIG1ldGhvZDogJ3NldFZvbHVtZScsIHZhbHVlOiAwIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNIVE1MNShlbCkpIHtcbiAgICAgICAgZWwubXV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmlkZW8oZWwpIHtcbiAgICAgIHJldHVybiBpc0hUTUw1KGVsKSB8fCBpc0lGcmFtZShlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIVE1MNShlbCkge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAndmlkZW8nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lGcmFtZShlbCkge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAnaWZyYW1lJykgJiYgKGlzWW91dHViZShlbCkgfHwgaXNWaW1lbyhlbCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzWW91dHViZShlbCkge1xuICAgICAgcmV0dXJuICEhZWwuc3JjLm1hdGNoKFxuICAgICAgL1xcL1xcLy4qP3lvdXR1YmUoLW5vY29va2llKT9cXC5bYS16XStcXC8od2F0Y2hcXD92PVteJlxcc10rfGVtYmVkKXx5b3V0dVxcLmJlXFwvLiovKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmltZW8oZWwpIHtcbiAgICAgIHJldHVybiAhIWVsLnNyYy5tYXRjaCgvdmltZW9cXC5jb21cXC92aWRlb1xcLy4qLyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY2FsbChlbCwgY21kKSB7XG4gICAgICBhd2FpdCBlbmFibGVBcGkoZWwpO1xuICAgICAgcG9zdChlbCwgY21kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3N0KGVsLCBjbWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoeyBldmVudDogJ2NvbW1hbmQnLCAuLi5jbWQgfSksICcqJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgLy8gbm9vcFxuICAgICAgfX1cblxuICAgIGNvbnN0IHN0YXRlS2V5ID0gJ191a1BsYXllcic7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGZ1bmN0aW9uIGVuYWJsZUFwaShlbCkge1xuICAgICAgaWYgKGVsW3N0YXRlS2V5XSkge1xuICAgICAgICByZXR1cm4gZWxbc3RhdGVLZXldO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB5b3V0dWJlID0gaXNZb3V0dWJlKGVsKTtcbiAgICAgIGNvbnN0IHZpbWVvID0gaXNWaW1lbyhlbCk7XG5cbiAgICAgIGNvbnN0IGlkID0gKytjb3VudGVyO1xuICAgICAgbGV0IHBvbGxlcjtcblxuICAgICAgcmV0dXJuIGVsW3N0YXRlS2V5XSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHlvdXR1YmUgJiZcbiAgICAgICAgb25jZShlbCwgJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiBwb3N0KGVsLCB7IGV2ZW50OiAnbGlzdGVuaW5nJywgaWQgfSk7XG4gICAgICAgICAgcG9sbGVyID0gc2V0SW50ZXJ2YWwobGlzdGVuZXIsIDEwMCk7XG4gICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb25jZSh3aW5kb3csICdtZXNzYWdlJywgcmVzb2x2ZSwgZmFsc2UsICh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGRhdGEgJiYgKFxuICAgICAgICAgICAgICB5b3V0dWJlICYmIGRhdGEuaWQgPT09IGlkICYmIGRhdGEuZXZlbnQgPT09ICdvblJlYWR5JyB8fFxuICAgICAgICAgICAgICB2aW1lbyAmJiBOdW1iZXIoZGF0YS5wbGF5ZXJfaWQpID09PSBpZCkpO1xuXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgfX0pO1xuXG4gICAgICAgIGVsLnNyYyA9IGAke2VsLnNyY30ke2luY2x1ZGVzKGVsLnNyYywgJz8nKSA/ICcmJyA6ICc/J30ke1xuICAgIHlvdXR1YmUgPyAnZW5hYmxlanNhcGk9MScgOiBgYXBpPTEmcGxheWVyX2lkPSR7aWR9YFxuICAgIH1gO1xuICAgICAgfSkudGhlbigoKSA9PiBjbGVhckludGVydmFsKHBvbGxlcikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5WaWV3KGVsZW1lbnQsIG9mZnNldFRvcCA9IDAsIG9mZnNldExlZnQgPSAwKSB7XG4gICAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3RSZWN0KFxuICAgICAgLi4uc2Nyb2xsUGFyZW50cyhlbGVtZW50KS5cbiAgICAgIG1hcCgocGFyZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gPSBvZmZzZXRWaWV3cG9ydChwYXJlbnQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiB0b3AgLSBvZmZzZXRUb3AsXG4gICAgICAgICAgbGVmdDogbGVmdCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgYm90dG9tOiBib3R0b20gKyBvZmZzZXRUb3AsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0ICsgb2Zmc2V0TGVmdFxuICAgICAgICB9O1xuICAgICAgfSkuXG4gICAgICBjb25jYXQob2Zmc2V0KGVsZW1lbnQpKSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbGVtZW50LCB7IG9mZnNldDogb2Zmc2V0QnkgPSAwIH0gPSB7fSkge1xuICAgICAgY29uc3QgcGFyZW50cyA9IGlzVmlzaWJsZShlbGVtZW50KSA/IHNjcm9sbFBhcmVudHMoZWxlbWVudCkgOiBbXTtcbiAgICAgIHJldHVybiBwYXJlbnRzLnJlZHVjZShcbiAgICAgIChmbiwgc2Nyb2xsRWxlbWVudCwgaSkgPT4ge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IG1heFNjcm9sbCA9IHNjcm9sbEhlaWdodCAtIHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQ6IGVsSGVpZ2h0LCB0b3A6IGVsVG9wIH0gPSBwYXJlbnRzW2kgLSAxXSA/XG4gICAgICAgIG9mZnNldFZpZXdwb3J0KHBhcmVudHNbaSAtIDFdKSA6XG4gICAgICAgIG9mZnNldChlbGVtZW50KTtcblxuICAgICAgICBsZXQgdG9wID0gTWF0aC5jZWlsKGVsVG9wIC0gdmlld3BvcnQudG9wIC0gb2Zmc2V0QnkgKyBzY3JvbGxUb3ApO1xuXG4gICAgICAgIGlmIChvZmZzZXRCeSA+IDAgJiYgb2Zmc2V0SGVpZ2h0IDwgZWxIZWlnaHQgKyBvZmZzZXRCeSkge1xuICAgICAgICAgIHRvcCArPSBvZmZzZXRCeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXRCeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wID4gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wIC0gbWF4U2Nyb2xsO1xuICAgICAgICAgIHRvcCA9IG1heFNjcm9sbDtcbiAgICAgICAgfSBlbHNlIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wO1xuICAgICAgICAgIHRvcCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCkgPT4gc2Nyb2xsVG8oc2Nyb2xsRWxlbWVudCwgdG9wIC0gc2Nyb2xsVG9wKS50aGVuKGZuKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSkoKTtcblxuXG4gICAgICBmdW5jdGlvbiBzY3JvbGxUbyhlbGVtZW50LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBnZXREdXJhdGlvbihNYXRoLmFicyh0b3ApKTtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAoZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSBlYXNlKGNsYW1wKChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24pKTtcblxuICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGwgKyB0b3AgKiBwZXJjZW50O1xuXG4gICAgICAgICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXREdXJhdGlvbihkaXN0KSB7XG4gICAgICAgIHJldHVybiA0MCAqIE1hdGgucG93KGRpc3QsIDAuMzc1KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZShrKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsZWRPdmVyKGVsZW1lbnQsIHN0YXJ0T2Zmc2V0ID0gMCwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgaWYgKCFpc1Zpc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtzY3JvbGxFbGVtZW50XSA9IHNjcm9sbFBhcmVudHMoZWxlbWVudCwgL2F1dG98c2Nyb2xsLywgdHJ1ZSk7XG4gICAgICBjb25zdCB7IHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gPSBzY3JvbGxFbGVtZW50O1xuICAgICAgY29uc3QgeyBoZWlnaHQ6IHZpZXdwb3J0SGVpZ2h0IH0gPSBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KTtcbiAgICAgIGNvbnN0IG1heFNjcm9sbCA9IHNjcm9sbEhlaWdodCAtIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgY29uc3QgZWxlbWVudE9mZnNldFRvcCA9IG9mZnNldFBvc2l0aW9uKGVsZW1lbnQpWzBdIC0gb2Zmc2V0UG9zaXRpb24oc2Nyb2xsRWxlbWVudClbMF07XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZWxlbWVudE9mZnNldFRvcCAtIHZpZXdwb3J0SGVpZ2h0ICsgc3RhcnRPZmZzZXQpO1xuICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4obWF4U2Nyb2xsLCBlbGVtZW50T2Zmc2V0VG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBlbmRPZmZzZXQpO1xuXG4gICAgICByZXR1cm4gY2xhbXAoKHNjcm9sbFRvcCAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbFBhcmVudHMoZWxlbWVudCwgb3ZlcmZsb3dSZSA9IC9hdXRvfHNjcm9sbHxoaWRkZW58Y2xpcC8sIHNjcm9sbGFibGUgPSBmYWxzZSkge1xuICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICBsZXQgYW5jZXN0b3JzID0gcGFyZW50cyhlbGVtZW50KS5yZXZlcnNlKCk7XG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuc2xpY2UoYW5jZXN0b3JzLmluZGV4T2Yoc2Nyb2xsRWwpICsgMSk7XG5cbiAgICAgIGNvbnN0IGZpeGVkSW5kZXggPSBmaW5kSW5kZXgoYW5jZXN0b3JzLCAoZWwpID0+IGNzcyhlbCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpO1xuICAgICAgaWYgKH5maXhlZEluZGV4KSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZShmaXhlZEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtzY3JvbGxFbF0uXG4gICAgICBjb25jYXQoXG4gICAgICBhbmNlc3RvcnMuZmlsdGVyKFxuICAgICAgKHBhcmVudCkgPT4gb3ZlcmZsb3dSZS50ZXN0KGNzcyhwYXJlbnQsICdvdmVyZmxvdycpKSAmJiAoXG4gICAgICAhc2Nyb2xsYWJsZSB8fCBwYXJlbnQuc2Nyb2xsSGVpZ2h0ID4gb2Zmc2V0Vmlld3BvcnQocGFyZW50KS5oZWlnaHQpKSkuXG5cblxuICAgICAgcmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldFZpZXdwb3J0KHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IHRvV2luZG93KHNjcm9sbEVsZW1lbnQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb2N1bWVudDogeyBkb2N1bWVudEVsZW1lbnQgfVxuICAgICAgfSA9IHdpbmRvdztcbiAgICAgIGxldCB2aWV3cG9ydEVsZW1lbnQgPVxuICAgICAgc2Nyb2xsRWxlbWVudCA9PT0gc2Nyb2xsaW5nRWxlbWVudChzY3JvbGxFbGVtZW50KSA/IHdpbmRvdyA6IHNjcm9sbEVsZW1lbnQ7XG5cbiAgICAgIGNvbnN0IHsgdmlzdWFsVmlld3BvcnQgfSA9IHdpbmRvdztcbiAgICAgIGlmIChpc1dpbmRvdyh2aWV3cG9ydEVsZW1lbnQpICYmIHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgICAgIGxldCB7IGhlaWdodCwgd2lkdGgsIHNjYWxlLCBwYWdlVG9wOiB0b3AsIHBhZ2VMZWZ0OiBsZWZ0IH0gPSB2aXN1YWxWaWV3cG9ydDtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKiBzY2FsZSk7XG4gICAgICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCAqIHNjYWxlKTtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0LCB3aWR0aCwgdG9wLCBsZWZ0LCBib3R0b206IHRvcCArIGhlaWdodCwgcmlnaHQ6IGxlZnQgKyB3aWR0aCB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVjdCA9IG9mZnNldCh2aWV3cG9ydEVsZW1lbnQpO1xuICAgICAgaWYgKGNzcyh2aWV3cG9ydEVsZW1lbnQsICdkaXNwbGF5JykgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBbcHJvcCwgZGlyLCBzdGFydCwgZW5kXSBvZiBbXG4gICAgICBbJ3dpZHRoJywgJ3gnLCAnbGVmdCcsICdyaWdodCddLFxuICAgICAgWydoZWlnaHQnLCAneScsICd0b3AnLCAnYm90dG9tJ11dKVxuICAgICAge1xuICAgICAgICBpZiAoaXNXaW5kb3codmlld3BvcnRFbGVtZW50KSkge1xuICAgICAgICAgIC8vIGlPUyAxMiByZXR1cm5zIDxib2R5PiBhcyBzY3JvbGxpbmdFbGVtZW50XG4gICAgICAgICAgdmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Rbc3RhcnRdICs9IHRvRmxvYXQoY3NzKHZpZXdwb3J0RWxlbWVudCwgYGJvcmRlci0ke3N0YXJ0fS13aWR0aGApKTtcbiAgICAgICAgfVxuICAgICAgICByZWN0W3Byb3BdID0gcmVjdFtkaXJdID0gdmlld3BvcnRFbGVtZW50W2BjbGllbnQke3VjZmlyc3QocHJvcCl9YF07XG4gICAgICAgIHJlY3RbZW5kXSA9IHJlY3RbcHJvcF0gKyByZWN0W3N0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRvV2luZG93KGVsZW1lbnQpLmRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGlycyA9IFtcbiAgICBbJ3dpZHRoJywgJ3gnLCAnbGVmdCcsICdyaWdodCddLFxuICAgIFsnaGVpZ2h0JywgJ3knLCAndG9wJywgJ2JvdHRvbSddXTtcblxuXG4gICAgZnVuY3Rpb24gcG9zaXRpb25BdChlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgIGVsZW1lbnQ6IFsnbGVmdCcsICd0b3AnXSxcbiAgICAgICAgICB0YXJnZXQ6IFsnbGVmdCcsICd0b3AnXSxcbiAgICAgICAgICAuLi5vcHRpb25zLmF0dGFjaFxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgcGxhY2VtZW50OiBbXSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gW3RhcmdldCwgdGFyZ2V0XTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0KGVsZW1lbnQsIGdldFBvc2l0aW9uKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBhdHRhY2hUbyhlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgeyBib3VuZGFyeSwgdmlld3BvcnRPZmZzZXQgPSAwLCBwbGFjZW1lbnQgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGxldCBvZmZzZXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgZm9yIChjb25zdCBbaSwgW3Byb3AsLCBzdGFydCwgZW5kXV0gb2YgT2JqZWN0LmVudHJpZXMoZGlycykpIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCQyKGVsZW1lbnQsIHRhcmdldFtpXSwgdmlld3BvcnRPZmZzZXQsIGJvdW5kYXJ5LCBpKTtcblxuICAgICAgICBpZiAoaXNXaXRoaW4ocG9zaXRpb24sIHZpZXdwb3J0LCBpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldEJ5ID0gMDtcblxuICAgICAgICAvLyBGbGlwXG4gICAgICAgIGlmIChwbGFjZW1lbnRbaV0gPT09ICdmbGlwJykge1xuICAgICAgICAgIGNvbnN0IGF0dGFjaCA9IG9wdGlvbnMuYXR0YWNoLnRhcmdldFtpXTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgYXR0YWNoID09PSBlbmQgJiYgcG9zaXRpb25bZW5kXSA8PSB2aWV3cG9ydFtlbmRdIHx8XG4gICAgICAgICAgYXR0YWNoID09PSBzdGFydCAmJiBwb3NpdGlvbltzdGFydF0gPj0gdmlld3BvcnRbc3RhcnRdKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9mZnNldEJ5ID0gZmxpcChlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGkpW3N0YXJ0XSAtIHBvc2l0aW9uW3N0YXJ0XTtcblxuICAgICAgICAgIGNvbnN0IHNjcm9sbEFyZWEgPSBnZXRTY3JvbGxBcmVhKGVsZW1lbnQsIHRhcmdldFtpXSwgdmlld3BvcnRPZmZzZXQsIGkpO1xuXG4gICAgICAgICAgaWYgKCFpc1dpdGhpbihhcHBseU9mZnNldChwb3NpdGlvbiwgb2Zmc2V0QnksIGkpLCBzY3JvbGxBcmVhLCBpKSkge1xuICAgICAgICAgICAgaWYgKGlzV2l0aGluKHBvc2l0aW9uLCBzY3JvbGxBcmVhLCBpKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVjdXJzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbmV3UG9zID0gZmxpcEF4aXMoZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKG5ld1BvcyAmJiBpc1dpdGhpbihuZXdQb3MsIHNjcm9sbEFyZWEsIDEgLSBpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3UG9zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaGlmdFxuICAgICAgICB9IGVsc2UgaWYgKHBsYWNlbWVudFtpXSA9PT0gJ3NoaWZ0Jykge1xuICAgICAgICAgIGNvbnN0IHRhcmdldERpbSA9IG9mZnNldCh0YXJnZXRbaV0pO1xuICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0OiBlbE9mZnNldCB9ID0gb3B0aW9ucztcbiAgICAgICAgICBvZmZzZXRCeSA9XG4gICAgICAgICAgY2xhbXAoXG4gICAgICAgICAgY2xhbXAocG9zaXRpb25bc3RhcnRdLCB2aWV3cG9ydFtzdGFydF0sIHZpZXdwb3J0W2VuZF0gLSBwb3NpdGlvbltwcm9wXSksXG4gICAgICAgICAgdGFyZ2V0RGltW3N0YXJ0XSAtIHBvc2l0aW9uW3Byb3BdICsgZWxPZmZzZXRbaV0sXG4gICAgICAgICAgdGFyZ2V0RGltW2VuZF0gLSBlbE9mZnNldFtpXSkgLVxuICAgICAgICAgIHBvc2l0aW9uW3N0YXJ0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldFBvc2l0aW9uID0gYXBwbHlPZmZzZXQob2Zmc2V0UG9zaXRpb24sIG9mZnNldEJ5LCBpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldFBvc2l0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dGFjaFRvKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgbGV0IHsgYXR0YWNoLCBvZmZzZXQ6IG9mZnNldEJ5IH0gPSB7XG4gICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgIGVsZW1lbnQ6IFsnbGVmdCcsICd0b3AnXSxcbiAgICAgICAgICB0YXJnZXQ6IFsnbGVmdCcsICd0b3AnXSxcbiAgICAgICAgICAuLi5vcHRpb25zLmF0dGFjaFxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgbGV0IGVsT2Zmc2V0ID0gb2Zmc2V0KGVsZW1lbnQpO1xuXG4gICAgICBmb3IgKGNvbnN0IFtpLCBbcHJvcCwsIHN0YXJ0LCBlbmRdXSBvZiBPYmplY3QuZW50cmllcyhkaXJzKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPVxuICAgICAgICBhdHRhY2gudGFyZ2V0W2ldID09PSBhdHRhY2guZWxlbWVudFtpXSA/IG9mZnNldFZpZXdwb3J0KHRhcmdldFtpXSkgOiBvZmZzZXQodGFyZ2V0W2ldKTtcblxuICAgICAgICBlbE9mZnNldCA9IGFwcGx5T2Zmc2V0KFxuICAgICAgICBlbE9mZnNldCxcbiAgICAgICAgdGFyZ2V0T2Zmc2V0W3N0YXJ0XSAtXG4gICAgICAgIGVsT2Zmc2V0W3N0YXJ0XSArXG4gICAgICAgIG1vdmVCeShhdHRhY2gudGFyZ2V0W2ldLCBlbmQsIHRhcmdldE9mZnNldFtwcm9wXSkgLVxuICAgICAgICBtb3ZlQnkoYXR0YWNoLmVsZW1lbnRbaV0sIGVuZCwgZWxPZmZzZXRbcHJvcF0pICtcbiAgICAgICAgK29mZnNldEJ5W2ldLFxuICAgICAgICBpKTtcblxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsT2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5T2Zmc2V0KHBvc2l0aW9uLCBvZmZzZXQsIGkpIHtcbiAgICAgIGNvbnN0IFssIGRpciwgc3RhcnQsIGVuZF0gPSBkaXJzW2ldO1xuICAgICAgY29uc3QgbmV3UG9zID0geyAuLi5wb3NpdGlvbiB9O1xuICAgICAgbmV3UG9zW3N0YXJ0XSA9IHBvc2l0aW9uW2Rpcl0gPSBwb3NpdGlvbltzdGFydF0gKyBvZmZzZXQ7XG4gICAgICBuZXdQb3NbZW5kXSArPSBvZmZzZXQ7XG4gICAgICByZXR1cm4gbmV3UG9zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmVCeShhdHRhY2gsIGVuZCwgZGltKSB7XG4gICAgICByZXR1cm4gYXR0YWNoID09PSAnY2VudGVyJyA/IGRpbSAvIDIgOiBhdHRhY2ggPT09IGVuZCA/IGRpbSA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnQkMihlbGVtZW50LCB0YXJnZXQsIHZpZXdwb3J0T2Zmc2V0LCBib3VuZGFyeSwgaSkge1xuICAgICAgbGV0IHZpZXdwb3J0ID0gZ2V0SW50ZXJzZWN0aW9uQXJlYSguLi5jb21tb25TY3JvbGxQYXJlbnRzKGVsZW1lbnQsIHRhcmdldCkubWFwKG9mZnNldFZpZXdwb3J0KSk7XG5cbiAgICAgIGlmICh2aWV3cG9ydE9mZnNldCkge1xuICAgICAgICB2aWV3cG9ydFtkaXJzW2ldWzJdXSArPSB2aWV3cG9ydE9mZnNldDtcbiAgICAgICAgdmlld3BvcnRbZGlyc1tpXVszXV0gLT0gdmlld3BvcnRPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZGFyeSkge1xuICAgICAgICB2aWV3cG9ydCA9IGdldEludGVyc2VjdGlvbkFyZWEoXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICBvZmZzZXQoaXNBcnJheShib3VuZGFyeSkgPyBib3VuZGFyeVtpXSA6IGJvdW5kYXJ5KSk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNjcm9sbEFyZWEoZWxlbWVudCwgdGFyZ2V0LCB2aWV3cG9ydE9mZnNldCwgaSkge1xuICAgICAgY29uc3QgW3Byb3AsIGF4aXMsIHN0YXJ0LCBlbmRdID0gZGlyc1tpXTtcbiAgICAgIGNvbnN0IFtzY3JvbGxFbGVtZW50XSA9IGNvbW1vblNjcm9sbFBhcmVudHMoZWxlbWVudCwgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG5cbiAgICAgIGlmIChbJ2F1dG8nLCAnc2Nyb2xsJ10uaW5jbHVkZXMoY3NzKHNjcm9sbEVsZW1lbnQsIGBvdmVyZmxvdy0ke2F4aXN9YCkpKSB7XG4gICAgICAgIHZpZXdwb3J0W3N0YXJ0XSAtPSBzY3JvbGxFbGVtZW50W2BzY3JvbGwke3VjZmlyc3Qoc3RhcnQpfWBdO1xuICAgICAgICB2aWV3cG9ydFtlbmRdID0gc2Nyb2xsRWxlbWVudFtgc2Nyb2xsJHt1Y2ZpcnN0KHByb3ApfWBdO1xuICAgICAgfVxuXG4gICAgICB2aWV3cG9ydFtzdGFydF0gKz0gdmlld3BvcnRPZmZzZXQ7XG4gICAgICB2aWV3cG9ydFtlbmRdIC09IHZpZXdwb3J0T2Zmc2V0O1xuXG4gICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tbW9uU2Nyb2xsUGFyZW50cyhlbGVtZW50LCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzKHRhcmdldCkuZmlsdGVyKChwYXJlbnQpID0+IHdpdGhpbihlbGVtZW50LCBwYXJlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25BcmVhKC4uLnJlY3RzKSB7XG4gICAgICBsZXQgYXJlYSA9IHt9O1xuICAgICAgZm9yIChjb25zdCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgIGZvciAoY29uc3QgWywsIHN0YXJ0LCBlbmRdIG9mIGRpcnMpIHtcbiAgICAgICAgICBhcmVhW3N0YXJ0XSA9IE1hdGgubWF4KGFyZWFbc3RhcnRdIHx8IDAsIHJlY3Rbc3RhcnRdKTtcbiAgICAgICAgICBhcmVhW2VuZF0gPSBNYXRoLm1pbiguLi5bYXJlYVtlbmRdLCByZWN0W2VuZF1dLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzV2l0aGluKHBvc2l0aW9uQSwgcG9zaXRpb25CLCBpKSB7XG4gICAgICBjb25zdCBbLCwgc3RhcnQsIGVuZF0gPSBkaXJzW2ldO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uQVtzdGFydF0gPj0gcG9zaXRpb25CW3N0YXJ0XSAmJiBwb3NpdGlvbkFbZW5kXSA8PSBwb3NpdGlvbkJbZW5kXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGlwKGVsZW1lbnQsIHRhcmdldCwgeyBvZmZzZXQsIGF0dGFjaCB9LCBpKSB7XG4gICAgICByZXR1cm4gYXR0YWNoVG8oZWxlbWVudCwgdGFyZ2V0LCB7XG4gICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgIGVsZW1lbnQ6IGZsaXBBdHRhY2goYXR0YWNoLmVsZW1lbnQsIGkpLFxuICAgICAgICAgIHRhcmdldDogZmxpcEF0dGFjaChhdHRhY2gudGFyZ2V0LCBpKVxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IGZsaXBPZmZzZXQob2Zmc2V0LCBpKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmxpcEF4aXMoZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb24oZWxlbWVudCwgdGFyZ2V0LCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgIGVsZW1lbnQ6IG9wdGlvbnMuYXR0YWNoLmVsZW1lbnQubWFwKGZsaXBBdHRhY2hBeGlzKS5yZXZlcnNlKCksXG4gICAgICAgICAgdGFyZ2V0OiBvcHRpb25zLmF0dGFjaC50YXJnZXQubWFwKGZsaXBBdHRhY2hBeGlzKS5yZXZlcnNlKClcbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldC5yZXZlcnNlKCksXG4gICAgICAgIHBsYWNlbWVudDogb3B0aW9ucy5wbGFjZW1lbnQucmV2ZXJzZSgpLFxuICAgICAgICByZWN1cnNpb246IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsaXBBdHRhY2goYXR0YWNoLCBpKSB7XG4gICAgICBjb25zdCBuZXdBdHRhY2ggPSBbLi4uYXR0YWNoXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gZGlyc1tpXS5pbmRleE9mKGF0dGFjaFtpXSk7XG4gICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgIG5ld0F0dGFjaFtpXSA9IGRpcnNbaV1bMSAtIGluZGV4ICUgMiArIDJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0F0dGFjaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGlwQXR0YWNoQXhpcyhwcm9wKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBkaXJzW2ldLmluZGV4T2YocHJvcCk7XG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gZGlyc1sxIC0gaV1baW5kZXggJSAyICsgMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGlwT2Zmc2V0KG9mZnNldCwgaSkge1xuICAgICAgb2Zmc2V0ID0gWy4uLm9mZnNldF07XG4gICAgICBvZmZzZXRbaV0gKj0gLTE7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB1dGlsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIGFqYXg6IGFqYXgsXG4gICAgICAgIGdldEltYWdlOiBnZXRJbWFnZSxcbiAgICAgICAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgICAgICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXG4gICAgICAgIGF0dHI6IGF0dHIsXG4gICAgICAgIGhhc0F0dHI6IGhhc0F0dHIsXG4gICAgICAgIHJlbW92ZUF0dHI6IHJlbW92ZUF0dHIsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICAgICAgICByZW1vdmVDbGFzc2VzOiByZW1vdmVDbGFzc2VzLFxuICAgICAgICByZXBsYWNlQ2xhc3M6IHJlcGxhY2VDbGFzcyxcbiAgICAgICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICAgICAgICB0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXG4gICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMkMSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgb2Zmc2V0UG9zaXRpb246IG9mZnNldFBvc2l0aW9uLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBib3hNb2RlbEFkanVzdDogYm94TW9kZWxBZGp1c3QsXG4gICAgICAgIGZsaXBQb3NpdGlvbjogZmxpcFBvc2l0aW9uLFxuICAgICAgICB0b1B4OiB0b1B4LFxuICAgICAgICByZWFkeTogcmVhZHksXG4gICAgICAgIGlzVGFnOiBpc1RhZyxcbiAgICAgICAgZW1wdHk6IGVtcHR5LFxuICAgICAgICBodG1sOiBodG1sLFxuICAgICAgICBwcmVwZW5kOiBwcmVwZW5kLFxuICAgICAgICBhcHBlbmQ6IGFwcGVuZCxcbiAgICAgICAgYmVmb3JlOiBiZWZvcmUsXG4gICAgICAgIGFmdGVyOiBhZnRlcixcbiAgICAgICAgcmVtb3ZlOiByZW1vdmUkMSxcbiAgICAgICAgd3JhcEFsbDogd3JhcEFsbCxcbiAgICAgICAgd3JhcElubmVyOiB3cmFwSW5uZXIsXG4gICAgICAgIHVud3JhcDogdW53cmFwLFxuICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgIGFwcGx5OiBhcHBseSxcbiAgICAgICAgJDogJCxcbiAgICAgICAgJCQ6ICQkLFxuICAgICAgICBpbkJyb3dzZXI6IGluQnJvd3NlcixcbiAgICAgICAgaXNSdGw6IGlzUnRsLFxuICAgICAgICBoYXNUb3VjaDogaGFzVG91Y2gsXG4gICAgICAgIHBvaW50ZXJEb3duOiBwb2ludGVyRG93biQxLFxuICAgICAgICBwb2ludGVyTW92ZTogcG9pbnRlck1vdmUkMSxcbiAgICAgICAgcG9pbnRlclVwOiBwb2ludGVyVXAkMSxcbiAgICAgICAgcG9pbnRlckVudGVyOiBwb2ludGVyRW50ZXIsXG4gICAgICAgIHBvaW50ZXJMZWF2ZTogcG9pbnRlckxlYXZlLFxuICAgICAgICBwb2ludGVyQ2FuY2VsOiBwb2ludGVyQ2FuY2VsLFxuICAgICAgICBvbjogb24sXG4gICAgICAgIG9mZjogb2ZmLFxuICAgICAgICBvbmNlOiBvbmNlLFxuICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICAgICAgICBjcmVhdGVFdmVudDogY3JlYXRlRXZlbnQsXG4gICAgICAgIHRvRXZlbnRUYXJnZXRzOiB0b0V2ZW50VGFyZ2V0cyxcbiAgICAgICAgaXNUb3VjaDogaXNUb3VjaCxcbiAgICAgICAgZ2V0RXZlbnRQb3M6IGdldEV2ZW50UG9zLFxuICAgICAgICBmYXN0ZG9tOiBmYXN0ZG9tLFxuICAgICAgICBpc1ZvaWRFbGVtZW50OiBpc1ZvaWRFbGVtZW50LFxuICAgICAgICBpc1Zpc2libGU6IGlzVmlzaWJsZSxcbiAgICAgICAgc2VsSW5wdXQ6IHNlbElucHV0LFxuICAgICAgICBpc0lucHV0OiBpc0lucHV0LFxuICAgICAgICBzZWxGb2N1c2FibGU6IHNlbEZvY3VzYWJsZSxcbiAgICAgICAgaXNGb2N1c2FibGU6IGlzRm9jdXNhYmxlLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIkMSxcbiAgICAgICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICAgICAgY2xvc2VzdDogY2xvc2VzdCxcbiAgICAgICAgd2l0aGluOiB3aXRoaW4sXG4gICAgICAgIHBhcmVudHM6IHBhcmVudHMsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBoYXNPd246IGhhc093bixcbiAgICAgICAgaHlwaGVuYXRlOiBoeXBoZW5hdGUsXG4gICAgICAgIGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgICAgICAgdWNmaXJzdDogdWNmaXJzdCxcbiAgICAgICAgc3RhcnRzV2l0aDogc3RhcnRzV2l0aCxcbiAgICAgICAgZW5kc1dpdGg6IGVuZHNXaXRoLFxuICAgICAgICBpbmNsdWRlczogaW5jbHVkZXMsXG4gICAgICAgIGZpbmRJbmRleDogZmluZEluZGV4LFxuICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgICAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgICAgICBhc3NpZ246IGFzc2lnbixcbiAgICAgICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICAgICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgICAgICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBpc1dpbmRvdzogaXNXaW5kb3csXG4gICAgICAgIGlzRG9jdW1lbnQ6IGlzRG9jdW1lbnQsXG4gICAgICAgIGlzTm9kZTogaXNOb2RlLFxuICAgICAgICBpc0VsZW1lbnQ6IGlzRWxlbWVudCxcbiAgICAgICAgaXNCb29sZWFuOiBpc0Jvb2xlYW4sXG4gICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICAgICAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICAgICAgICBpc051bWVyaWM6IGlzTnVtZXJpYyxcbiAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICAgICAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICAgICAgICB0b0Jvb2xlYW46IHRvQm9vbGVhbixcbiAgICAgICAgdG9OdW1iZXI6IHRvTnVtYmVyLFxuICAgICAgICB0b0Zsb2F0OiB0b0Zsb2F0LFxuICAgICAgICB0b05vZGU6IHRvTm9kZSxcbiAgICAgICAgdG9Ob2RlczogdG9Ob2RlcyxcbiAgICAgICAgdG9XaW5kb3c6IHRvV2luZG93LFxuICAgICAgICBpc0VxdWFsOiBpc0VxdWFsLFxuICAgICAgICBzd2FwOiBzd2FwLFxuICAgICAgICBsYXN0OiBsYXN0LFxuICAgICAgICBlYWNoOiBlYWNoLFxuICAgICAgICBzb3J0Qnk6IHNvcnRCeSQxLFxuICAgICAgICBzdW1CeTogc3VtQnksXG4gICAgICAgIHVuaXF1ZUJ5OiB1bmlxdWVCeSxcbiAgICAgICAgY2xhbXA6IGNsYW1wLFxuICAgICAgICBub29wOiBub29wLFxuICAgICAgICBpbnRlcnNlY3RSZWN0OiBpbnRlcnNlY3RSZWN0LFxuICAgICAgICBwb2ludEluUmVjdDogcG9pbnRJblJlY3QsXG4gICAgICAgIERpbWVuc2lvbnM6IERpbWVuc2lvbnMsXG4gICAgICAgIGdldEluZGV4OiBnZXRJbmRleCxcbiAgICAgICAgbWVtb2l6ZTogbWVtb2l6ZSxcbiAgICAgICAgRGVmZXJyZWQ6IERlZmVycmVkLFxuICAgICAgICBNb3VzZVRyYWNrZXI6IE1vdXNlVHJhY2tlcixcbiAgICAgICAgb2JzZXJ2ZUludGVyc2VjdGlvbjogb2JzZXJ2ZUludGVyc2VjdGlvbixcbiAgICAgICAgb2JzZXJ2ZVJlc2l6ZTogb2JzZXJ2ZVJlc2l6ZSxcbiAgICAgICAgb2JzZXJ2ZU11dGF0aW9uOiBvYnNlcnZlTXV0YXRpb24sXG4gICAgICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgICAgICBwYXJzZU9wdGlvbnM6IHBhcnNlT3B0aW9ucyxcbiAgICAgICAgcGxheTogcGxheSxcbiAgICAgICAgcGF1c2U6IHBhdXNlLFxuICAgICAgICBtdXRlOiBtdXRlLFxuICAgICAgICBpc1ZpZGVvOiBpc1ZpZGVvLFxuICAgICAgICBwb3NpdGlvbkF0OiBwb3NpdGlvbkF0LFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIHF1ZXJ5QWxsOiBxdWVyeUFsbCxcbiAgICAgICAgZmluZDogZmluZCxcbiAgICAgICAgZmluZEFsbDogZmluZEFsbCxcbiAgICAgICAgZXNjYXBlOiBlc2NhcGUsXG4gICAgICAgIGNzczogY3NzLFxuICAgICAgICBwcm9wTmFtZTogcHJvcE5hbWUsXG4gICAgICAgIGlzSW5WaWV3OiBpc0luVmlldyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHNjcm9sbEludG9WaWV3LFxuICAgICAgICBzY3JvbGxlZE92ZXI6IHNjcm9sbGVkT3ZlcixcbiAgICAgICAgc2Nyb2xsUGFyZW50czogc2Nyb2xsUGFyZW50cyxcbiAgICAgICAgb2Zmc2V0Vmlld3BvcnQ6IG9mZnNldFZpZXdwb3J0XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnbG9iYWxBUEkgKFVJa2l0KSB7XG4gICAgICBjb25zdCBEQVRBID0gVUlraXQuZGF0YTtcblxuICAgICAgVUlraXQudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsdWdpbi5jYWxsKG51bGwsIHRoaXMpO1xuICAgICAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0Lm1peGluID0gZnVuY3Rpb24gKG1peGluLCBjb21wb25lbnQpIHtcbiAgICAgICAgY29tcG9uZW50ID0gKGlzU3RyaW5nKGNvbXBvbmVudCkgPyBVSWtpdC5jb21wb25lbnQoY29tcG9uZW50KSA6IGNvbXBvbmVudCkgfHwgdGhpcztcbiAgICAgICAgY29tcG9uZW50Lm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoY29tcG9uZW50Lm9wdGlvbnMsIG1peGluKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LmV4dGVuZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGNvbnN0IFN1cGVyID0gdGhpcztcbiAgICAgICAgY29uc3QgU3ViID0gZnVuY3Rpb24gVUlraXRDb21wb25lbnQob3B0aW9ucykge1xuICAgICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICAgICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoU3VwZXIub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgU3ViLnN1cGVyID0gU3VwZXI7XG4gICAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG5cbiAgICAgICAgcmV0dXJuIFN1YjtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnVwZGF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBlKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50ID8gdG9Ob2RlKGVsZW1lbnQpIDogZG9jdW1lbnQuYm9keTtcblxuICAgICAgICBmb3IgKGNvbnN0IHBhcmVudEVsIG9mIHBhcmVudHMoZWxlbWVudCkucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgdXBkYXRlKHBhcmVudEVsW0RBVEFdLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5KGVsZW1lbnQsIChlbGVtZW50KSA9PiB1cGRhdGUoZWxlbWVudFtEQVRBXSwgZSkpO1xuICAgICAgfTtcblxuICAgICAgbGV0IGNvbnRhaW5lcjtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSWtpdCwgJ2NvbnRhaW5lcicsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQoZWxlbWVudCkge1xuICAgICAgICAgIGNvbnRhaW5lciA9ICQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoZGF0YSwgZSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhW25hbWVdLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGRhdGFbbmFtZV0uX2NhbGxVcGRhdGUoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaG9va3NBUEkgKFVJa2l0KSB7XG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHt2YXIgX3RoaXMkJG9wdGlvbnMkaG9vaztcbiAgICAgICAgKF90aGlzJCRvcHRpb25zJGhvb2sgPSB0aGlzLiRvcHRpb25zW2hvb2tdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkJG9wdGlvbnMkaG9vay5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyLmNhbGwodGhpcykpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9jYWxsQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2luaXRQcm9wcygpO1xuXG4gICAgICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb25uZWN0Jyk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuICAgICAgICB0aGlzLl9pbml0T2JzZXJ2ZXJzKCk7XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLl9jYWxsVXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxEaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZURpc2Nvbm5lY3QnKTtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdE9ic2VydmVycygpO1xuICAgICAgICB0aGlzLl91bmJpbmRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2Rpc2Nvbm5lY3RlZCcpO1xuXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWxldGUgdGhpcy5fd2F0Y2g7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxVcGRhdGUgPSBmdW5jdGlvbiAoZSA9ICd1cGRhdGUnKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUgPT09ICd1cGRhdGUnIHx8IGUgPT09ICdyZXNpemUnKSB7XG4gICAgICAgICAgdGhpcy5fY2FsbFdhdGNoZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy4kb3B0aW9ucy51cGRhdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZXMpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZhc3Rkb20ucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIHJ1blVwZGF0ZXMuY2FsbCh0aGlzLCB0aGlzLl91cGRhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlcy5hZGQoZS50eXBlIHx8IGUpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9jYWxsV2F0Y2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhdGNoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5pdGlhbCA9ICFoYXNPd24odGhpcywgJ193YXRjaCcpO1xuXG4gICAgICAgIHRoaXMuX3dhdGNoID0gZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBydW5XYXRjaGVzLmNhbGwodGhpcywgaW5pdGlhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3dhdGNoID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBydW5VcGRhdGVzKHR5cGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyByZWFkLCB3cml0ZSwgZXZlbnRzID0gW10gfSBvZiB0aGlzLiRvcHRpb25zLnVwZGF0ZSkge1xuICAgICAgICAgIGlmICghdHlwZXMuaGFzKCd1cGRhdGUnKSAmJiAhZXZlbnRzLnNvbWUoKHR5cGUpID0+IHR5cGVzLmhhcyh0eXBlKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgaWYgKHJlYWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlYWQuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLCB0eXBlcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgaXNQbGFpbk9iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGFzc2lnbih0aGlzLl9kYXRhLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3cml0ZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHdyaXRlLmNhbGwodGhpcywgdGhpcy5fZGF0YSwgdHlwZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcnVuV2F0Y2hlcyhpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkb3B0aW9uczogeyBjb21wdXRlZCB9XG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB7IC4uLnRoaXMuX2NvbXB1dGVkIH07XG4gICAgICAgIHRoaXMuX2NvbXB1dGVkID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb25zdCB7IHdhdGNoLCBpbW1lZGlhdGUgfSA9IGNvbXB1dGVkW2tleV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHdhdGNoICYmIChcbiAgICAgICAgICBpbml0aWFsICYmIGltbWVkaWF0ZSB8fFxuICAgICAgICAgIGhhc093bih2YWx1ZXMsIGtleSkgJiYgIWlzRXF1YWwodmFsdWVzW2tleV0sIHRoaXNba2V5XSkpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdhdGNoLmNhbGwodGhpcywgdGhpc1trZXldLCB2YWx1ZXNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhdGVBUEkgKFVJa2l0KSB7XG4gICAgICBsZXQgdWlkID0gMDtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IG5vcm1hbGl6ZURhdGEob3B0aW9ucywgdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcblxuICAgICAgICB0aGlzLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucywgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcHJvcHMgPSB7fTtcblxuICAgICAgICB0aGlzLl91aWQgPSB1aWQrKztcbiAgICAgICAgdGhpcy5faW5pdERhdGEoKTtcbiAgICAgICAgdGhpcy5faW5pdE1ldGhvZHMoKTtcbiAgICAgICAgdGhpcy5faW5pdENvbXB1dGVkcygpO1xuICAgICAgICB0aGlzLl9jYWxsSG9vaygnY3JlYXRlZCcpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICAgICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5faW5pdERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSA9IHt9IH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICB0aGlzLiRwcm9wc1trZXldID0gdGhpc1trZXldID0gZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB7IG1ldGhvZHMgfSA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBtZXRob2RzW2tleV0uYmluZCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5faW5pdENvbXB1dGVkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgeyBjb21wdXRlZCB9ID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZWdpc3RlckNvbXB1dGVkKHRoaXMsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICBsZXQga2V5O1xuXG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwgZ2V0UHJvcHMkMSh0aGlzLiRvcHRpb25zKTtcblxuICAgICAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMuJHByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGUgPSBbdGhpcy4kb3B0aW9ucy5jb21wdXRlZCwgdGhpcy4kb3B0aW9ucy5tZXRob2RzXTtcbiAgICAgICAgZm9yIChrZXkgaW4gdGhpcy4kcHJvcHMpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHByb3BzICYmIG5vdEluKGV4Y2x1ZGUsIGtleSkpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHRoaXMuJHByb3BzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuJG9wdGlvbnMuZXZlbnRzIHx8IFtdKSB7XG4gICAgICAgICAgaWYgKGhhc093bihldmVudCwgJ2hhbmRsZXInKSkge1xuICAgICAgICAgICAgcmVnaXN0ZXJFdmVudCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnQodGhpcywgZXZlbnRba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fdW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgodW5iaW5kKSA9PiB1bmJpbmQoKSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRPYnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtpbml0UHJvcHNPYnNlcnZlcih0aGlzKSwgaW5pdENoaWxkTGlzdE9ic2VydmVyKHRoaXMpXTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5yZWdpc3Rlck9ic2VydmVyID0gZnVuY3Rpb24gKC4uLm9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5wdXNoKC4uLm9ic2VydmVyKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fZGlzY29ubmVjdE9ic2VydmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goKG9ic2VydmVyKSA9PiBvYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogb2JzZXJ2ZXIuZGlzY29ubmVjdCgpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJvcHMkMShvcHRzKSB7XG4gICAgICBjb25zdCBkYXRhJDEgPSB7fTtcbiAgICAgIGNvbnN0IHsgYXJncyA9IFtdLCBwcm9wcyA9IHt9LCBlbCwgaWQgfSA9IG9wdHM7XG5cbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEkMTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBsZXQgdmFsdWUgPSBkYXRhKGVsLCBwcm9wKTtcblxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHByb3BzW2tleV0gPT09IEJvb2xlYW4gJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IGNvZXJjZSQxKHByb3BzW2tleV0sIHZhbHVlKTtcblxuICAgICAgICBpZiAocHJvcCA9PT0gJ3RhcmdldCcgJiYgc3RhcnRzV2l0aCh2YWx1ZSwgJ18nKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YSQxW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhkYXRhKGVsLCBpZCksIGFyZ3MpO1xuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHByb3BzW3Byb3BdKSkge1xuICAgICAgICAgIGRhdGEkMVtwcm9wXSA9IGNvZXJjZSQxKHByb3BzW3Byb3BdLCBvcHRpb25zW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhJDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDb21wdXRlZChjb21wb25lbnQsIGtleSwgY2IpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wb25lbnQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCB7IF9jb21wdXRlZCwgJHByb3BzLCAkZWwgfSA9IGNvbXBvbmVudDtcblxuICAgICAgICAgIGlmICghaGFzT3duKF9jb21wdXRlZCwga2V5KSkge1xuICAgICAgICAgICAgX2NvbXB1dGVkW2tleV0gPSAoY2IuZ2V0IHx8IGNiKS5jYWxsKGNvbXBvbmVudCwgJHByb3BzLCAkZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfY29tcHV0ZWRba2V5XTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB7IF9jb21wdXRlZCB9ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgX2NvbXB1dGVkW2tleV0gPSBjYi5zZXQgPyBjYi5zZXQuY2FsbChjb21wb25lbnQsIHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF9jb21wdXRlZFtrZXldKSkge1xuICAgICAgICAgICAgZGVsZXRlIF9jb21wdXRlZFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudChjb21wb25lbnQsIGV2ZW50LCBrZXkpIHtcbiAgICAgIGlmICghaXNQbGFpbk9iamVjdChldmVudCkpIHtcbiAgICAgICAgZXZlbnQgPSB7IG5hbWU6IGtleSwgaGFuZGxlcjogZXZlbnQgfTtcbiAgICAgIH1cblxuICAgICAgbGV0IHsgbmFtZSwgZWwsIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUsIGRlbGVnYXRlLCBmaWx0ZXIsIHNlbGYgfSA9IGV2ZW50O1xuICAgICAgZWwgPSBpc0Z1bmN0aW9uKGVsKSA/IGVsLmNhbGwoY29tcG9uZW50KSA6IGVsIHx8IGNvbXBvbmVudC4kZWw7XG5cbiAgICAgIGlmIChpc0FycmF5KGVsKSkge1xuICAgICAgICBlbC5mb3JFYWNoKChlbCkgPT4gcmVnaXN0ZXJFdmVudChjb21wb25lbnQsIHsgLi4uZXZlbnQsIGVsIH0sIGtleSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZWwgfHwgZmlsdGVyICYmICFmaWx0ZXIuY2FsbChjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50Ll9ldmVudHMucHVzaChcbiAgICAgIG9uKFxuICAgICAgZWwsXG4gICAgICBuYW1lLFxuICAgICAgZGVsZWdhdGUgPyBpc1N0cmluZyhkZWxlZ2F0ZSkgPyBkZWxlZ2F0ZSA6IGRlbGVnYXRlLmNhbGwoY29tcG9uZW50KSA6IG51bGwsXG4gICAgICBpc1N0cmluZyhoYW5kbGVyKSA/IGNvbXBvbmVudFtoYW5kbGVyXSA6IGhhbmRsZXIuYmluZChjb21wb25lbnQpLFxuICAgICAgeyBwYXNzaXZlLCBjYXB0dXJlLCBzZWxmIH0pKTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90SW4ob3B0aW9ucywga2V5KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5ldmVyeSgoYXJyKSA9PiAhYXJyIHx8ICFoYXNPd24oYXJyLCBrZXkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2VyY2UkMSh0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGUgPT09IEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIHRvQm9vbGVhbih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgcmV0dXJuIHRvTGlzdCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlID8gdHlwZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0xpc3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/XG4gICAgICB2YWx1ZSA6XG4gICAgICBpc1N0cmluZyh2YWx1ZSkgP1xuICAgICAgdmFsdWUuXG4gICAgICBzcGxpdCgvLCg/IVteKF0qXFwpKS8pLlxuICAgICAgbWFwKCh2YWx1ZSkgPT4gaXNOdW1lcmljKHZhbHVlKSA/IHRvTnVtYmVyKHZhbHVlKSA6IHRvQm9vbGVhbih2YWx1ZS50cmltKCkpKSA6XG4gICAgICBbdmFsdWVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEoeyBkYXRhID0ge30gfSwgeyBhcmdzID0gW10sIHByb3BzID0ge30gfSkge1xuICAgICAgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgYXJncy5sZW5ndGgpLnJlZHVjZSgoZGF0YSwgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBhc3NpZ24oZGF0YSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhW2FyZ3NbaW5kZXhdXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChkYXRhW2tleV0pKSB7XG4gICAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wc1trZXldKSB7XG4gICAgICAgICAgZGF0YVtrZXldID0gY29lcmNlJDEocHJvcHNba2V5XSwgZGF0YVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0Q2hpbGRMaXN0T2JzZXJ2ZXIoY29tcG9uZW50KSB7XG4gICAgICBsZXQgeyBlbCwgY29tcHV0ZWQgfSA9IGNvbXBvbmVudC4kb3B0aW9ucztcblxuICAgICAgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgIGlmIChjb21wdXRlZFtrZXldLmRvY3VtZW50KSB7XG4gICAgICAgICAgZWwgPSBlbC5vd25lckRvY3VtZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gY29tcG9uZW50Ll9jYWxsV2F0Y2hlcygpKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRQcm9wc09ic2VydmVyKGNvbXBvbmVudCkge1xuICAgICAgY29uc3QgeyAkb3B0aW9ucywgJHByb3BzIH0gPSBjb21wb25lbnQ7XG4gICAgICBjb25zdCB7IGlkLCBhdHRycywgcHJvcHMsIGVsIH0gPSAkb3B0aW9ucztcblxuICAgICAgaWYgKCFwcm9wcyB8fCBhdHRycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gaXNBcnJheShhdHRycykgPyBhdHRycyA6IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICAgIGNvbnN0IGZpbHRlciA9IGF0dHJpYnV0ZXMubWFwKChrZXkpID0+IGh5cGhlbmF0ZShrZXkpKS5jb25jYXQoaWQpO1xuXG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRQcm9wcyQxKCRvcHRpb25zKTtcbiAgICAgICAgaWYgKFxuICAgICAgICByZWNvcmRzLnNvbWUoKHsgYXR0cmlidXRlTmFtZSB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvcCA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgnZGF0YS0nLCAnJyk7XG4gICAgICAgICAgcmV0dXJuIChwcm9wID09PSBpZCA/IGF0dHJpYnV0ZXMgOiBbY2FtZWxpemUocHJvcCksIGNhbWVsaXplKGF0dHJpYnV0ZU5hbWUpXSkuc29tZShcbiAgICAgICAgICAocHJvcCkgPT4gIWlzVW5kZWZpbmVkKGRhdGFbcHJvcF0pICYmIGRhdGFbcHJvcF0gIT09ICRwcm9wc1twcm9wXSk7XG5cbiAgICAgICAgfSkpXG4gICAgICAgIHtcbiAgICAgICAgICBjb21wb25lbnQuJHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGVsLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogZmlsdGVyLmNvbmNhdChmaWx0ZXIubWFwKChrZXkpID0+IGBkYXRhLSR7a2V5fWApKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YW5jZUFQSSAoVUlraXQpIHtcbiAgICAgIGNvbnN0IERBVEEgPSBVSWtpdC5kYXRhO1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGNyZWF0ZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFVJa2l0W2NvbXBvbmVudF0oZWxlbWVudCwgZGF0YSk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICBpZiAoIWVsW0RBVEFdKSB7XG4gICAgICAgICAgZWxbREFUQV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbFtEQVRBXVtuYW1lXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsW0RBVEFdW25hbWVdID0gdGhpcztcblxuICAgICAgICB0aGlzLiRlbCA9IHRoaXMuJG9wdGlvbnMuZWwgPSB0aGlzLiRvcHRpb25zLmVsIHx8IGVsO1xuXG4gICAgICAgIGlmICh3aXRoaW4oZWwsIGRvY3VtZW50KSkge1xuICAgICAgICAgIHRoaXMuX2NhbGxDb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiRyZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2FsbERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB0aGlzLl9jYWxsQ29ubmVjdGVkKCk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlRWwgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7IGVsLCBuYW1lIH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIHRoaXMuX2NhbGxEaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhbGxIb29rKCdkZXN0cm95Jyk7XG5cbiAgICAgICAgaWYgKCEoZWwgIT0gbnVsbCAmJiBlbFtEQVRBXSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgZWxbREFUQV1bbmFtZV07XG5cbiAgICAgICAgaWYgKCFpc0VtcHR5KGVsW0RBVEFdKSkge1xuICAgICAgICAgIGRlbGV0ZSBlbFtEQVRBXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmVFbCkge1xuICAgICAgICAgIHJlbW92ZSQxKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fY2FsbFVwZGF0ZShlKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kdXBkYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQgPSB0aGlzLiRlbCwgZSkge1xuICAgICAgICBVSWtpdC51cGRhdGUoZWxlbWVudCwgZSk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGdldENvbXBvbmVudCA9IFVJa2l0LmdldENvbXBvbmVudDtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgVUlraXQucHJvdG90eXBlLFxuICAgICAgJyRjb250YWluZXInLFxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihVSWtpdCwgJ2NvbnRhaW5lcicpKTtcblxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudHMkMyA9IHt9O1xuICAgIGZ1bmN0aW9uIGNvbXBvbmVudEFQSSAoVUlraXQpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogREFUQSwgcHJlZml4OiBQUkVGSVggfSA9IFVJa2l0O1xuXG4gICAgICBVSWtpdC5jb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBuYW1lID0gaHlwaGVuYXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBpZCA9IFBSRUZJWCArIG5hbWU7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoY29tcG9uZW50cyQzW2lkXSkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMkM1tpZF0gPSBjb21wb25lbnRzJDNbYGRhdGEtJHtpZH1gXSA9IFVJa2l0LmV4dGVuZChjb21wb25lbnRzJDNbaWRdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50cyQzW2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcblxuICAgICAgICBVSWtpdFtuYW1lXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBkYXRhKSB7XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gVUlraXQuY29tcG9uZW50KG5hbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwgP1xuICAgICAgICAgIG5ldyBjb21wb25lbnQoeyBkYXRhOiBpc1BsYWluT2JqZWN0KGVsZW1lbnQpID8gZWxlbWVudCA6IFsuLi5hcmd1bWVudHNdIH0pIDpcbiAgICAgICAgICBlbGVtZW50ID9cbiAgICAgICAgICAkJChlbGVtZW50KS5tYXAoaW5pdClbMF0gOlxuICAgICAgICAgIGluaXQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGluaXQoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBVSWtpdC5nZXRDb21wb25lbnQoZWxlbWVudCwgbmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgY29tcG9uZW50KHsgZWw6IGVsZW1lbnQsIGRhdGEgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9wdCA9IGlzUGxhaW5PYmplY3Qob3B0aW9ucykgPyB7IC4uLm9wdGlvbnMgfSA6IG9wdGlvbnMub3B0aW9ucztcblxuICAgICAgICBvcHQuaWQgPSBpZDtcbiAgICAgICAgb3B0Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIG9wdC5pbnN0YWxsID09IG51bGwgPyB2b2lkIDAgOiBvcHQuaW5zdGFsbChVSWtpdCwgb3B0LCBuYW1lKTtcblxuICAgICAgICBpZiAoVUlraXQuX2luaXRpYWxpemVkICYmICFvcHQuZnVuY3Rpb25hbCkge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBVSWtpdFtuYW1lXShgWyR7aWR9XSxbZGF0YS0ke2lkfV1gKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50cyQzW2lkXSA9IGNvbXBvbmVudHMkM1tgZGF0YS0ke2lkfWBdID0gaXNQbGFpbk9iamVjdChvcHRpb25zKSA/IG9wdCA6IG9wdGlvbnM7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5nZXRDb21wb25lbnRzID0gKGVsZW1lbnQpID0+IChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50W0RBVEFdKSB8fCB7fTtcbiAgICAgIFVJa2l0LmdldENvbXBvbmVudCA9IChlbGVtZW50LCBuYW1lKSA9PiBVSWtpdC5nZXRDb21wb25lbnRzKGVsZW1lbnQpW25hbWVdO1xuXG4gICAgICBVSWtpdC5jb25uZWN0ID0gKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGVbREFUQV0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZVtEQVRBXSkge1xuICAgICAgICAgICAgbm9kZVtEQVRBXVtuYW1lXS5fY2FsbENvbm5lY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIG5vZGUuZ2V0QXR0cmlidXRlTmFtZXMoKSkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgbmFtZSAmJiBVSWtpdFtuYW1lXShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQuZGlzY29ubmVjdCA9IChub2RlKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBub2RlW0RBVEFdKSB7XG4gICAgICAgICAgbm9kZVtEQVRBXVtuYW1lXS5fY2FsbERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoYXR0cmlidXRlKSB7XG4gICAgICBjb25zdCBjbXAgPSBjb21wb25lbnRzJDNbYXR0cmlidXRlXTtcbiAgICAgIHJldHVybiBjbXAgJiYgKGlzUGxhaW5PYmplY3QoY21wKSA/IGNtcCA6IGNtcC5vcHRpb25zKS5uYW1lO1xuICAgIH1cblxuICAgIGNvbnN0IFVJa2l0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIFVJa2l0LnV0aWwgPSB1dGlsO1xuICAgIFVJa2l0LmRhdGEgPSAnX191aWtpdF9fJztcbiAgICBVSWtpdC5wcmVmaXggPSAndWstJztcbiAgICBVSWtpdC5vcHRpb25zID0ge307XG4gICAgVUlraXQudmVyc2lvbiA9ICczLjE1LjE4JztcblxuICAgIGdsb2JhbEFQSShVSWtpdCk7XG4gICAgaG9va3NBUEkoVUlraXQpO1xuICAgIHN0YXRlQVBJKFVJa2l0KTtcbiAgICBjb21wb25lbnRBUEkoVUlraXQpO1xuICAgIGluc3RhbmNlQVBJKFVJa2l0KTtcblxuICAgIGZ1bmN0aW9uIGJvb3QgKFVJa2l0KSB7XG4gICAgICBjb25zdCB7IGNvbm5lY3QsIGRpc2Nvbm5lY3QgfSA9IFVJa2l0O1xuXG4gICAgICBpZiAoIWluQnJvd3NlciB8fCAhd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmlnZ2VyKGRvY3VtZW50LCAndWlraXQ6aW5pdCcsIFVJa2l0KTtcblxuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgIGFwcGx5KGRvY3VtZW50LmJvZHksIGNvbm5lY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHJlY29yZHMuZm9yRWFjaChhcHBseUNoaWxkTGlzdE11dGF0aW9uKSkub2JzZXJ2ZShcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiByZWNvcmRzLmZvckVhY2goYXBwbHlBdHRyaWJ1dGVNdXRhdGlvbikpLm9ic2VydmUoXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgVUlraXQuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhcHBseUNoaWxkTGlzdE11dGF0aW9uKHsgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzIH0pIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgICAgICBhcHBseShub2RlLCBjb25uZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiByZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICBhcHBseShub2RlLCBkaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZU11dGF0aW9uKHsgdGFyZ2V0LCBhdHRyaWJ1dGVOYW1lIH0pIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgaWYgKG5hbWUpIHt2YXIgX1VJa2l0JGdldENvbXBvbmVudDtcbiAgICAgICAgICBpZiAoaGFzQXR0cih0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICBVSWtpdFtuYW1lXSh0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIChfVUlraXQkZ2V0Q29tcG9uZW50ID0gVUlraXQuZ2V0Q29tcG9uZW50KHRhcmdldCwgbmFtZSkpID09IG51bGwgPyB2b2lkIDAgOiBfVUlraXQkZ2V0Q29tcG9uZW50LiRkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQ2xhc3MgPSB7XG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLiRvcHRpb25zLmlkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIExhenlsb2FkID0ge1xuICAgICAgZGF0YToge1xuICAgICAgICBwcmVsb2FkOiA1XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGxhenlsb2FkKG9ic2VydmVUYXJnZXRzID0gdGhpcy4kZWwsIHRhcmdldHMgPSB0aGlzLiRlbCkge1xuICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihcbiAgICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKG9ic2VydmVUYXJnZXRzLCAoZW50cmllcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdG9Ob2Rlcyhpc0Z1bmN0aW9uKHRhcmdldHMpID8gdGFyZ2V0cygpIDogdGFyZ2V0cykpIHtcbiAgICAgICAgICAgICAgJCQoJ1tsb2FkaW5nPVwibGF6eVwiXScsIGVsKS5cbiAgICAgICAgICAgICAgc2xpY2UoMCwgdGhpcy5wcmVsb2FkIC0gMSkuXG4gICAgICAgICAgICAgIGZvckVhY2goKGVsKSA9PiByZW1vdmVBdHRyKGVsLCAnbG9hZGluZycpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBlbnRyaWVzLlxuICAgICAgICAgICAgZmlsdGVyKCh7IGlzSW50ZXJzZWN0aW5nIH0pID0+IGlzSW50ZXJzZWN0aW5nKS5cbiAgICAgICAgICAgIG1hcCgoeyB0YXJnZXQgfSkgPT4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBUb2dnbGFibGUgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHM6IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGlvbjogJ2xpc3QnLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLFxuICAgICAgICB2ZWxvY2l0eTogTnVtYmVyLFxuICAgICAgICBvcmlnaW46IFN0cmluZyxcbiAgICAgICAgdHJhbnNpdGlvbjogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsczogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogW2ZhbHNlXSxcbiAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgdmVsb2NpdHk6IDAuMixcbiAgICAgICAgb3JpZ2luOiBmYWxzZSxcbiAgICAgICAgdHJhbnNpdGlvbjogJ2Vhc2UnLFxuICAgICAgICBjbHNFbnRlcjogJ3VrLXRvZ2dsYWJlLWVudGVyJyxcbiAgICAgICAgY2xzTGVhdmU6ICd1ay10b2dnbGFiZS1sZWF2ZSdcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGhhc0FuaW1hdGlvbih7IGFuaW1hdGlvbiB9KSB7XG4gICAgICAgICAgcmV0dXJuICEhYW5pbWF0aW9uWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc1RyYW5zaXRpb24oeyBhbmltYXRpb24gfSkge1xuICAgICAgICAgIHJldHVybiBbJ3NsaWRlJywgJ3JldmVhbCddLnNvbWUoKHRyYW5zaXRpb24pID0+IHN0YXJ0c1dpdGgoYW5pbWF0aW9uWzBdLCB0cmFuc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdG9nZ2xlRWxlbWVudCh0YXJnZXRzLCB0b2dnbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IFByb21pc2UuYWxsKFxuICAgICAgICAgIHRvTm9kZXModGFyZ2V0cykubWFwKChlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hvdyA9IGlzQm9vbGVhbih0b2dnbGUpID8gdG9nZ2xlIDogIXRoaXMuaXNUb2dnbGVkKGVsKTtcblxuICAgICAgICAgICAgaWYgKCF0cmlnZ2VyKGVsLCBgYmVmb3JlJHtzaG93ID8gJ3Nob3cnIDogJ2hpZGUnfWAsIFt0aGlzXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSAoXG4gICAgICAgICAgICBpc0Z1bmN0aW9uKGFuaW1hdGUpID9cbiAgICAgICAgICAgIGFuaW1hdGUgOlxuICAgICAgICAgICAgYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIXRoaXMuaGFzQW5pbWF0aW9uID9cbiAgICAgICAgICAgIHRvZ2dsZUluc3RhbnQgOlxuICAgICAgICAgICAgdGhpcy5oYXNUcmFuc2l0aW9uID9cbiAgICAgICAgICAgIHRvZ2dsZVRyYW5zaXRpb24gOlxuICAgICAgICAgICAgdG9nZ2xlQW5pbWF0aW9uKShcbiAgICAgICAgICAgIGVsLCBzaG93LCB0aGlzKTtcblxuICAgICAgICAgICAgY29uc3QgY2xzID0gc2hvdyA/IHRoaXMuY2xzRW50ZXIgOiB0aGlzLmNsc0xlYXZlO1xuXG4gICAgICAgICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcblxuICAgICAgICAgICAgdHJpZ2dlcihlbCwgc2hvdyA/ICdzaG93JyA6ICdoaWRlJywgW3RoaXNdKTtcblxuICAgICAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG4gICAgICAgICAgICAgIHRyaWdnZXIoZWwsIHNob3cgPyAnc2hvd24nIDogJ2hpZGRlbicsIFt0aGlzXSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZSA/XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZG9uZSwgKCkgPT4ge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSkpLlxuICAgICAgICAgIHRoZW4ocmVzb2x2ZSwgbm9vcCkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNUb2dnbGVkKGVsID0gdGhpcy4kZWwpIHtcbiAgICAgICAgICBbZWxdID0gdG9Ob2RlcyhlbCk7XG4gICAgICAgICAgcmV0dXJuIGhhc0NsYXNzKGVsLCB0aGlzLmNsc0VudGVyKSA/XG4gICAgICAgICAgdHJ1ZSA6XG4gICAgICAgICAgaGFzQ2xhc3MoZWwsIHRoaXMuY2xzTGVhdmUpID9cbiAgICAgICAgICBmYWxzZSA6XG4gICAgICAgICAgdGhpcy5jbHMgP1xuICAgICAgICAgIGhhc0NsYXNzKGVsLCB0aGlzLmNscy5zcGxpdCgnICcpWzBdKSA6XG4gICAgICAgICAgaXNWaXNpYmxlKGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdG9nZ2xlKGVsLCB0b2dnbGVkKSB7XG4gICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvZ2dsZWQgPSBCb29sZWFuKHRvZ2dsZWQpO1xuXG4gICAgICAgICAgbGV0IGNoYW5nZWQ7XG4gICAgICAgICAgaWYgKHRoaXMuY2xzKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gaW5jbHVkZXModGhpcy5jbHMsICcgJykgfHwgdG9nZ2xlZCAhPT0gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzKTtcbiAgICAgICAgICAgIGNoYW5nZWQgJiYgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzLCBpbmNsdWRlcyh0aGlzLmNscywgJyAnKSA/IHVuZGVmaW5lZCA6IHRvZ2dsZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdG9nZ2xlZCA9PT0gZWwuaGlkZGVuO1xuICAgICAgICAgICAgY2hhbmdlZCAmJiAoZWwuaGlkZGVuID0gIXRvZ2dsZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICQkKCdbYXV0b2ZvY3VzXScsIGVsKS5zb21lKChlbCkgPT4gaXNWaXNpYmxlKGVsKSA/IGVsLmZvY3VzKCkgfHwgdHJ1ZSA6IGVsLmJsdXIoKSk7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ3RvZ2dsZWQnLCBbdG9nZ2xlZCwgdGhpc10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVJbnN0YW50KGVsLCBzaG93LCB7IF90b2dnbGUgfSkge1xuICAgICAgQW5pbWF0aW9uLmNhbmNlbChlbCk7XG4gICAgICBUcmFuc2l0aW9uLmNhbmNlbChlbCk7XG4gICAgICByZXR1cm4gX3RvZ2dsZShlbCwgc2hvdyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlVHJhbnNpdGlvbihcbiAgICBlbCxcbiAgICBzaG93LFxuICAgIHsgYW5pbWF0aW9uLCBkdXJhdGlvbiwgdmVsb2NpdHksIHRyYW5zaXRpb24sIF90b2dnbGUgfSlcbiAgICB7dmFyIF9hbmltYXRpb24kO1xuICAgICAgY29uc3QgW21vZGUgPSAncmV2ZWFsJywgc3RhcnRQcm9wID0gJ3RvcCddID0gKChfYW5pbWF0aW9uJCA9IGFuaW1hdGlvblswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbmltYXRpb24kLnNwbGl0KCctJykpIHx8IFtdO1xuXG4gICAgICBjb25zdCBkaXJzID0gW1xuICAgICAgWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBbJ3RvcCcsICdib3R0b20nXV07XG5cbiAgICAgIGNvbnN0IGRpciA9IGRpcnNbaW5jbHVkZXMoZGlyc1swXSwgc3RhcnRQcm9wKSA/IDAgOiAxXTtcbiAgICAgIGNvbnN0IGVuZCA9IGRpclsxXSA9PT0gc3RhcnRQcm9wO1xuICAgICAgY29uc3QgcHJvcHMgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuICAgICAgY29uc3QgZGltUHJvcCA9IHByb3BzW2RpcnMuaW5kZXhPZihkaXIpXTtcbiAgICAgIGNvbnN0IG1hcmdpblByb3AgPSBgbWFyZ2luLSR7ZGlyWzBdfWA7XG4gICAgICBjb25zdCBtYXJnaW5TdGFydFByb3AgPSBgbWFyZ2luLSR7c3RhcnRQcm9wfWA7XG5cbiAgICAgIGxldCBjdXJyZW50RGltID0gZGltZW5zaW9ucyQxKGVsKVtkaW1Qcm9wXTtcblxuICAgICAgY29uc3QgaW5Qcm9ncmVzcyA9IFRyYW5zaXRpb24uaW5Qcm9ncmVzcyhlbCk7XG4gICAgICBhd2FpdCBUcmFuc2l0aW9uLmNhbmNlbChlbCk7XG5cbiAgICAgIGlmIChzaG93KSB7XG4gICAgICAgIF90b2dnbGUoZWwsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmV2UHJvcHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBbXG4gICAgICAncGFkZGluZycsXG4gICAgICAnYm9yZGVyJyxcbiAgICAgICd3aWR0aCcsXG4gICAgICAnaGVpZ2h0JyxcbiAgICAgICdtaW5XaWR0aCcsXG4gICAgICAnbWluSGVpZ2h0JyxcbiAgICAgICdvdmVyZmxvd1knLFxuICAgICAgJ292ZXJmbG93WCcsXG4gICAgICBtYXJnaW5Qcm9wLFxuICAgICAgbWFyZ2luU3RhcnRQcm9wXS5cbiAgICAgIG1hcCgoa2V5KSA9PiBba2V5LCBlbC5zdHlsZVtrZXldXSkpO1xuXG5cbiAgICAgIGNvbnN0IGRpbSA9IGRpbWVuc2lvbnMkMShlbCk7XG4gICAgICBjb25zdCBjdXJyZW50TWFyZ2luID0gdG9GbG9hdChjc3MoZWwsIG1hcmdpblByb3ApKTtcbiAgICAgIGNvbnN0IG1hcmdpblN0YXJ0ID0gdG9GbG9hdChjc3MoZWwsIG1hcmdpblN0YXJ0UHJvcCkpO1xuICAgICAgY29uc3QgZW5kRGltID0gZGltW2RpbVByb3BdICsgbWFyZ2luU3RhcnQ7XG5cbiAgICAgIGlmICghaW5Qcm9ncmVzcyAmJiAhc2hvdykge1xuICAgICAgICBjdXJyZW50RGltICs9IG1hcmdpblN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbd3JhcHBlcl0gPSB3cmFwSW5uZXIoZWwsICc8ZGl2PicpO1xuICAgICAgY3NzKHdyYXBwZXIsIHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGhlaWdodDogZGltLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGRpbS53aWR0aCxcbiAgICAgICAgLi4uY3NzKGVsLCBbXG4gICAgICAgICdvdmVyZmxvdycsXG4gICAgICAgICdwYWRkaW5nJyxcbiAgICAgICAgJ2JvcmRlclRvcCcsXG4gICAgICAgICdib3JkZXJSaWdodCcsXG4gICAgICAgICdib3JkZXJCb3R0b20nLFxuICAgICAgICAnYm9yZGVyTGVmdCcsXG4gICAgICAgICdib3JkZXJJbWFnZScsXG4gICAgICAgIG1hcmdpblN0YXJ0UHJvcF0pXG5cbiAgICAgIH0pO1xuXG4gICAgICBjc3MoZWwsIHtcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtaW5XaWR0aDogMCxcbiAgICAgICAgbWluSGVpZ2h0OiAwLFxuICAgICAgICBbbWFyZ2luU3RhcnRQcm9wXTogMCxcbiAgICAgICAgd2lkdGg6IGRpbS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkaW0uaGVpZ2h0LFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIFtkaW1Qcm9wXTogY3VycmVudERpbVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBjdXJyZW50RGltIC8gZW5kRGltO1xuICAgICAgZHVyYXRpb24gPSAodmVsb2NpdHkgKiBlbmREaW0gKyBkdXJhdGlvbikgKiAoc2hvdyA/IDEgLSBwZXJjZW50IDogcGVyY2VudCk7XG4gICAgICBjb25zdCBlbmRQcm9wcyA9IHsgW2RpbVByb3BdOiBzaG93ID8gZW5kRGltIDogMCB9O1xuXG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIGNzcyhlbCwgbWFyZ2luUHJvcCwgZW5kRGltIC0gY3VycmVudERpbSArIGN1cnJlbnRNYXJnaW4pO1xuICAgICAgICBlbmRQcm9wc1ttYXJnaW5Qcm9wXSA9IHNob3cgPyBjdXJyZW50TWFyZ2luIDogZW5kRGltICsgY3VycmVudE1hcmdpbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbmQgXiBtb2RlID09PSAncmV2ZWFsJykge1xuICAgICAgICBjc3Mod3JhcHBlciwgbWFyZ2luUHJvcCwgLWVuZERpbSArIGN1cnJlbnREaW0pO1xuICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KHdyYXBwZXIsIHsgW21hcmdpblByb3BdOiBzaG93ID8gMCA6IC1lbmREaW0gfSwgZHVyYXRpb24sIHRyYW5zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBUcmFuc2l0aW9uLnN0YXJ0KGVsLCBlbmRQcm9wcywgZHVyYXRpb24sIHRyYW5zaXRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3NzKGVsLCBwcmV2UHJvcHMpO1xuICAgICAgICB1bndyYXAod3JhcHBlci5maXJzdENoaWxkKTtcblxuICAgICAgICBpZiAoIXNob3cpIHtcbiAgICAgICAgICBfdG9nZ2xlKGVsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVBbmltYXRpb24oZWwsIHNob3csIGNtcCkge1xuICAgICAgQW5pbWF0aW9uLmNhbmNlbChlbCk7XG5cbiAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBkdXJhdGlvbiwgX3RvZ2dsZSB9ID0gY21wO1xuXG4gICAgICBpZiAoc2hvdykge1xuICAgICAgICBfdG9nZ2xlKGVsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbi5pbihlbCwgYW5pbWF0aW9uWzBdLCBkdXJhdGlvbiwgY21wLm9yaWdpbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBBbmltYXRpb24ub3V0KGVsLCBhbmltYXRpb25bMV0gfHwgYW5pbWF0aW9uWzBdLCBkdXJhdGlvbiwgY21wLm9yaWdpbikudGhlbigoKSA9PiBfdG9nZ2xlKGVsLCBmYWxzZSkpO1xuXG4gICAgfVxuXG4gICAgdmFyIEFjY29yZGlvbiA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBMYXp5bG9hZCwgVG9nZ2xhYmxlXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXRzOiBTdHJpbmcsXG4gICAgICAgIGFjdGl2ZTogbnVsbCxcbiAgICAgICAgY29sbGFwc2libGU6IEJvb2xlYW4sXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuLFxuICAgICAgICB0b2dnbGU6IFN0cmluZyxcbiAgICAgICAgY29udGVudDogU3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IE51bWJlclxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXRzOiAnPiAqJyxcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBjb2xsYXBzaWJsZTogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICBjbHNPcGVuOiAndWstb3BlbicsXG4gICAgICAgIHRvZ2dsZTogJz4gLnVrLWFjY29yZGlvbi10aXRsZScsXG4gICAgICAgIGNvbnRlbnQ6ICc+IC51ay1hY2NvcmRpb24tY29udGVudCcsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICBnZXQoeyB0YXJnZXRzIH0sICRlbCkge1xuICAgICAgICAgICAgcmV0dXJuICQkKHRhcmdldHMsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGl0ZW1zLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAocHJldiB8fCBoYXNDbGFzcyhpdGVtcywgdGhpcy5jbHNPcGVuKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSAhPT0gZmFsc2UgJiYgaXRlbXNbTnVtYmVyKHRoaXMuYWN0aXZlKV0gfHxcbiAgICAgICAgICAgICF0aGlzLmNvbGxhcHNpYmxlICYmIGl0ZW1zWzBdO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGFjdGl2ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVzKHsgdG9nZ2xlIH0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoKGl0ZW0pID0+ICQodG9nZ2xlLCBpdGVtKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGVudHM6IHtcbiAgICAgICAgICBnZXQoeyBjb250ZW50IH0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcCgoaXRlbSkgPT4gJChjb250ZW50LCBpdGVtKSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgIGhpZGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAhaGFzQ2xhc3MoXG4gICAgICAgICAgICAgIHRoaXMuaXRlbXMuZmluZCgoaXRlbSkgPT4gd2l0aGluKGVsLCBpdGVtKSksXG4gICAgICAgICAgICAgIHRoaXMuY2xzT3BlbikpO1xuXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5sYXp5bG9hZCgpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIGAke3RoaXMudGFyZ2V0c30gJHt0aGlzLiRwcm9wcy50b2dnbGV9YDtcbiAgICAgICAgfSxcblxuICAgICAgICBhc3luYyBoYW5kbGVyKGUpIHt2YXIgX3RoaXMkX29mZjtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAoX3RoaXMkX29mZiA9IHRoaXMuX29mZikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJF9vZmYuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLl9vZmYgPSBrZWVwU2Nyb2xsUG9zaXRpb24oZS50YXJnZXQpO1xuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlKGluZGV4KHRoaXMudG9nZ2xlcywgZS5jdXJyZW50KSk7XG4gICAgICAgICAgdGhpcy5fb2ZmKCk7XG4gICAgICAgIH1cbiAgICAgIH1dLFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgdG9nZ2xlKGl0ZW0sIGFuaW1hdGUpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tnZXRJbmRleChpdGVtLCB0aGlzLml0ZW1zKV07XG4gICAgICAgICAgbGV0IGl0ZW1zID0gW2l0ZW1dO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUl0ZW1zID0gZmlsdGVyJDEodGhpcy5pdGVtcywgYC4ke3RoaXMuY2xzT3Blbn1gKTtcblxuICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSAmJiAhaW5jbHVkZXMoYWN0aXZlSXRlbXMsIGl0ZW1zWzBdKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoYWN0aXZlSXRlbXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5jb2xsYXBzaWJsZSAmJiBhY3RpdmVJdGVtcy5sZW5ndGggPCAyICYmIGluY2x1ZGVzKGFjdGl2ZUl0ZW1zLCBpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIGl0ZW1zLm1hcCgoZWwpID0+IHRoaXMudG9nZ2xlRWxlbWVudChlbCwgIWluY2x1ZGVzKGFjdGl2ZUl0ZW1zLCBlbCksIChlbCwgc2hvdykgPT4ge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzT3Blbiwgc2hvdyk7XG4gICAgICAgICAgICBhdHRyKCQodGhpcy4kcHJvcHMudG9nZ2xlLCBlbCksICdhcmlhLWV4cGFuZGVkJywgc2hvdyk7XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRlID09PSBmYWxzZSB8fCAhdGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgaGlkZSgkKHRoaXMuY29udGVudCwgZWwpLCAhc2hvdyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24oZWwsIHNob3csIHRoaXMpO1xuICAgICAgICAgIH0pKSk7XG5cblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhpZGUoZWwsIGhpZGUpIHtcbiAgICAgIGVsICYmIChlbC5oaWRkZW4gPSBoaWRlKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB0cmFuc2l0aW9uKGVsLCBzaG93LCB7IGNvbnRlbnQsIGR1cmF0aW9uLCB2ZWxvY2l0eSwgdHJhbnNpdGlvbiB9KSB7dmFyIF9lbCRfd3JhcHBlcjtcbiAgICAgIGNvbnRlbnQgPSAoKF9lbCRfd3JhcHBlciA9IGVsLl93cmFwcGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2VsJF93cmFwcGVyLmZpcnN0RWxlbWVudENoaWxkKSB8fCAkKGNvbnRlbnQsIGVsKTtcblxuICAgICAgaWYgKCFlbC5fd3JhcHBlcikge1xuICAgICAgICBlbC5fd3JhcHBlciA9IHdyYXBBbGwoY29udGVudCwgJzxkaXY+Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBlbC5fd3JhcHBlcjtcbiAgICAgIGNzcyh3cmFwcGVyLCAnb3ZlcmZsb3cnLCAnaGlkZGVuJyk7XG4gICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gdG9GbG9hdChjc3Mod3JhcHBlciwgJ2hlaWdodCcpKTtcblxuICAgICAgYXdhaXQgVHJhbnNpdGlvbi5jYW5jZWwod3JhcHBlcik7XG4gICAgICBoaWRlKGNvbnRlbnQsIGZhbHNlKTtcblxuICAgICAgY29uc3QgZW5kSGVpZ2h0ID0gc3VtQnkoXG4gICAgICBbJ2hlaWdodCcsICdwYWRkaW5nVG9wJywgJ3BhZGRpbmdCb3R0b20nLCAnbWFyZ2luVG9wJywgJ21hcmdpbkJvdHRvbSddLFxuICAgICAgKHByb3ApID0+IGNzcyhjb250ZW50LCBwcm9wKSk7XG5cbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBjdXJyZW50SGVpZ2h0IC8gZW5kSGVpZ2h0O1xuICAgICAgZHVyYXRpb24gPSAodmVsb2NpdHkgKiBlbmRIZWlnaHQgKyBkdXJhdGlvbikgKiAoc2hvdyA/IDEgLSBwZXJjZW50IDogcGVyY2VudCk7XG4gICAgICBjc3Mod3JhcHBlciwgJ2hlaWdodCcsIGN1cnJlbnRIZWlnaHQpO1xuXG4gICAgICBhd2FpdCBUcmFuc2l0aW9uLnN0YXJ0KHdyYXBwZXIsIHsgaGVpZ2h0OiBzaG93ID8gZW5kSGVpZ2h0IDogMCB9LCBkdXJhdGlvbiwgdHJhbnNpdGlvbik7XG5cbiAgICAgIHVud3JhcChjb250ZW50KTtcbiAgICAgIGRlbGV0ZSBlbC5fd3JhcHBlcjtcblxuICAgICAgaWYgKCFzaG93KSB7XG4gICAgICAgIGhpZGUoY29udGVudCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2VlcFNjcm9sbFBvc2l0aW9uKGVsKSB7XG4gICAgICBjb25zdCBzY3JvbGxQYXJlbnQgPSBzY3JvbGxQYXJlbnRzKGVsKVswXTtcbiAgICAgIGxldCBmcmFtZTtcbiAgICAgIChmdW5jdGlvbiBzY3JvbGwoKSB7XG4gICAgICAgIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHRvcCB9ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgKz0gdG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuXG4gICAgICByZXR1cm4gKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKSk7XG4gICAgfVxuXG4gICAgdmFyIGFsZXJ0ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICdhbmltYXRpb24nLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBhbmltYXRpb246IEJvb2xlYW4sXG4gICAgICAgIGNsb3NlOiBTdHJpbmdcbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBzZWxDbG9zZTogJy51ay1hbGVydC1jbG9zZScsXG4gICAgICAgIGR1cmF0aW9uOiAxNTBcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbENsb3NlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCBmYWxzZSwgYW5pbWF0ZSQxKTtcbiAgICAgICAgICB0aGlzLiRkZXN0cm95KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFuaW1hdGUkMShlbCwgc2hvdywgeyBkdXJhdGlvbiwgdHJhbnNpdGlvbiwgdmVsb2NpdHkgfSkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdG9GbG9hdChjc3MoZWwsICdoZWlnaHQnKSk7XG4gICAgICBjc3MoZWwsICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICBlbCxcbiAgICAgIHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICAgICAgcGFkZGluZ1RvcDogMCxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcbiAgICAgICAgYm9yZGVyVG9wOiAwLFxuICAgICAgICBib3JkZXJCb3R0b206IDAsXG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sXG4gICAgICB2ZWxvY2l0eSAqIGhlaWdodCArIGR1cmF0aW9uLFxuICAgICAgdHJhbnNpdGlvbik7XG5cbiAgICB9XG5cbiAgICB2YXIgVmlkZW8gPSB7XG4gICAgICBhcmdzOiAnYXV0b3BsYXknLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBhdXRvbXV0ZTogQm9vbGVhbixcbiAgICAgICAgYXV0b3BsYXk6IEJvb2xlYW5cbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYXV0b211dGU6IGZhbHNlLFxuICAgICAgICBhdXRvcGxheTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMuYXV0b3BsYXkgPT09ICdpbnZpZXcnO1xuXG4gICAgICAgIGlmICh0aGlzLmluVmlldyAmJiAhaGFzQXR0cih0aGlzLiRlbCwgJ3ByZWxvYWQnKSkge1xuICAgICAgICAgIHRoaXMuJGVsLnByZWxvYWQgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNUYWcodGhpcy4kZWwsICdpZnJhbWUnKSAmJiAhaGFzQXR0cih0aGlzLiRlbCwgJ2FsbG93JykpIHtcbiAgICAgICAgICB0aGlzLiRlbC5hbGxvdyA9ICdhdXRvcGxheSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hdXRvbXV0ZSkge1xuICAgICAgICAgIG11dGUodGhpcy4kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKG9ic2VydmVJbnRlcnNlY3Rpb24odGhpcy4kZWwsICgpID0+IHRoaXMuJGVtaXQoKSwge30sIGZhbHNlKSk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCh7IHZpc2libGUgfSkge1xuICAgICAgICAgIGlmICghaXNWaWRlbyh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJldjogdmlzaWJsZSxcbiAgICAgICAgICAgIHZpc2libGU6IGlzVmlzaWJsZSh0aGlzLiRlbCkgJiYgY3NzKHRoaXMuJGVsLCAndmlzaWJpbGl0eScpICE9PSAnaGlkZGVuJyxcbiAgICAgICAgICAgIGluVmlldzogdGhpcy5pblZpZXcgJiYgaXNJblZpZXcodGhpcy4kZWwpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZSh7IHByZXYsIHZpc2libGUsIGluVmlldyB9KSB7XG4gICAgICAgICAgaWYgKCF2aXNpYmxlIHx8IHRoaXMuaW5WaWV3ICYmICFpblZpZXcpIHtcbiAgICAgICAgICAgIHBhdXNlKHRoaXMuJGVsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b3BsYXkgPT09IHRydWUgJiYgIXByZXYgfHwgdGhpcy5pblZpZXcgJiYgaW5WaWV3KSB7XG4gICAgICAgICAgICBwbGF5KHRoaXMuJGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFJlc2l6ZSA9IHtcbiAgICAgIGNvbm5lY3RlZCgpIHt2YXIgX3RoaXMkJG9wdGlvbnMkcmVzaXplO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgIG9ic2VydmVSZXNpemUoKChfdGhpcyQkb3B0aW9ucyRyZXNpemUgPSB0aGlzLiRvcHRpb25zLnJlc2l6ZVRhcmdldHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyQkb3B0aW9ucyRyZXNpemUuY2FsbCh0aGlzKSkgfHwgdGhpcy4kZWwsICgpID0+IHRoaXMuJGVtaXQoJ3Jlc2l6ZScpKSk7XG5cblxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY292ZXIgPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemUsIFZpZGVvXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgd2lkdGg6IE51bWJlcixcbiAgICAgICAgaGVpZ2h0OiBOdW1iZXJcbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYXV0b211dGU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICAnbG9hZCBsb2FkZWRtZXRhZGF0YScoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgncmVzaXplJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIGdldFBvc2l0aW9uZWRQYXJlbnQodGhpcy4kZWwpIHx8IHBhcmVudCh0aGlzLiRlbCldO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgY29uc3QgeyByYXRpbywgY292ZXIgfSA9IERpbWVuc2lvbnM7XG4gICAgICAgICAgY29uc3QgeyAkZWwsIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG5cbiAgICAgICAgICBsZXQgZGltID0geyB3aWR0aCwgaGVpZ2h0IH07XG5cbiAgICAgICAgICBpZiAoIWRpbS53aWR0aCB8fCAhZGltLmhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgaW50cmluc2ljID0ge1xuICAgICAgICAgICAgICB3aWR0aDogJGVsLm5hdHVyYWxXaWR0aCB8fCAkZWwudmlkZW9XaWR0aCB8fCAkZWwuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogJGVsLm5hdHVyYWxIZWlnaHQgfHwgJGVsLnZpZGVvSGVpZ2h0IHx8ICRlbC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChkaW0ud2lkdGgpIHtcbiAgICAgICAgICAgICAgZGltID0gcmF0aW8oaW50cmluc2ljLCAnd2lkdGgnLCBkaW0ud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgZGltID0gcmF0aW8oaW50cmluc2ljLCAnaGVpZ2h0JywgZGltLmhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkaW0gPSBpbnRyaW5zaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBvZmZzZXRIZWlnaHQ6IGNvdmVySGVpZ2h0LCBvZmZzZXRXaWR0aDogY292ZXJXaWR0aCB9ID1cbiAgICAgICAgICBnZXRQb3NpdGlvbmVkUGFyZW50KCRlbCkgfHwgcGFyZW50KCRlbCk7XG4gICAgICAgICAgY29uc3QgY292ZXJEaW0gPSBjb3ZlcihkaW0sIHtcbiAgICAgICAgICAgIHdpZHRoOiBjb3ZlcldpZHRoICsgKGNvdmVyV2lkdGggJSAyID8gMSA6IDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb3ZlckhlaWdodCArIChjb3ZlckhlaWdodCAlIDIgPyAxIDogMClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghY292ZXJEaW0ud2lkdGggfHwgIWNvdmVyRGltLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3ZlckRpbTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZSh7IGhlaWdodCwgd2lkdGggfSkge1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBoZWlnaHQsIHdpZHRoIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbmVkUGFyZW50KGVsKSB7XG4gICAgICB3aGlsZSAoZWwgPSBwYXJlbnQoZWwpKSB7XG4gICAgICAgIGlmIChjc3MoZWwsICdwb3NpdGlvbicpICE9PSAnc3RhdGljJykge1xuICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBDb250YWluZXIgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjb250YWluZXI6IEJvb2xlYW5cbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29udGFpbmVyOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjb250YWluZXIoeyBjb250YWluZXIgfSkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXIgPT09IHRydWUgJiYgdGhpcy4kY29udGFpbmVyIHx8IGNvbnRhaW5lciAmJiAkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFBvc2l0aW9uID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcG9zOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldDogbnVsbCxcbiAgICAgICAgZmxpcDogQm9vbGVhbixcbiAgICAgICAgc2hpZnQ6IEJvb2xlYW4sXG4gICAgICAgIGluc2V0OiBCb29sZWFuXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBvczogYGJvdHRvbS0ke2lzUnRsID8gJ3JpZ2h0JyA6ICdsZWZ0J31gLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICBmbGlwOiB0cnVlLFxuICAgICAgICBzaGlmdDogdHJ1ZSxcbiAgICAgICAgaW5zZXQ6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy4kcHJvcHMucG9zLnNwbGl0KCctJykuY29uY2F0KCdjZW50ZXInKS5zbGljZSgwLCAyKTtcbiAgICAgICAgW3RoaXMuZGlyLCB0aGlzLmFsaWduXSA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLmF4aXMgPSBpbmNsdWRlcyhbJ3RvcCcsICdib3R0b20nXSwgdGhpcy5kaXIpID8gJ3knIDogJ3gnO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBwb3NpdGlvbkF0KGVsZW1lbnQsIHRhcmdldCwgYm91bmRhcnkpIHtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gW3RoaXMuZ2V0UG9zaXRpb25PZmZzZXQoZWxlbWVudCksIHRoaXMuZ2V0U2hpZnRPZmZzZXQoZWxlbWVudCldO1xuICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IFt0aGlzLmZsaXAgJiYgJ2ZsaXAnLCB0aGlzLnNoaWZ0ICYmICdzaGlmdCddO1xuXG4gICAgICAgICAgY29uc3QgYXR0YWNoID0ge1xuICAgICAgICAgICAgZWxlbWVudDogW3RoaXMuaW5zZXQgPyB0aGlzLmRpciA6IGZsaXBQb3NpdGlvbih0aGlzLmRpciksIHRoaXMuYWxpZ25dLFxuICAgICAgICAgICAgdGFyZ2V0OiBbdGhpcy5kaXIsIHRoaXMuYWxpZ25dXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0aGlzLmF4aXMgPT09ICd5Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGF0dGFjaCkge1xuICAgICAgICAgICAgICBhdHRhY2hbcHJvcF0ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIHBsYWNlbWVudC5yZXZlcnNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgW3Njcm9sbEVsZW1lbnRdID0gc2Nyb2xsUGFyZW50cyhlbGVtZW50LCAvYXV0b3xzY3JvbGwvKTtcbiAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCB9ID0gc2Nyb2xsRWxlbWVudDtcblxuICAgICAgICAgIC8vIEVuc3VyZSBub25lIHBvc2l0aW9uZWQgZWxlbWVudCBkb2VzIG5vdCBnZW5lcmF0ZSBzY3JvbGxiYXJzXG4gICAgICAgICAgY29uc3QgZWxEaW0gPSBkaW1lbnNpb25zJDEoZWxlbWVudCk7XG4gICAgICAgICAgY3NzKGVsZW1lbnQsIHsgdG9wOiAtZWxEaW0uaGVpZ2h0LCBsZWZ0OiAtZWxEaW0ud2lkdGggfSk7XG5cbiAgICAgICAgICBwb3NpdGlvbkF0KGVsZW1lbnQsIHRhcmdldCwge1xuICAgICAgICAgICAgYXR0YWNoLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgICAgICB2aWV3cG9ydE9mZnNldDogdGhpcy5nZXRWaWV3cG9ydE9mZnNldChlbGVtZW50KVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICBzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICBzY3JvbGxFbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFBvc2l0aW9uT2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdG9QeChcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID09PSBmYWxzZSA/IGNzcyhlbGVtZW50LCAnLS11ay1wb3NpdGlvbi1vZmZzZXQnKSA6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5heGlzID09PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCcsXG4gICAgICAgICAgICBlbGVtZW50KSAqIChcblxuICAgICAgICAgICAgaW5jbHVkZXMoWydsZWZ0JywgJ3RvcCddLCB0aGlzLmRpcikgPyAtMSA6IDEpICogKFxuICAgICAgICAgICAgdGhpcy5pbnNldCA/IC0xIDogMSkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2hpZnRPZmZzZXQoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFsaWduID09PSAnY2VudGVyJyA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgdG9QeChcbiAgICAgICAgICBjc3MoZWxlbWVudCwgJy0tdWstcG9zaXRpb24tc2hpZnQtb2Zmc2V0JyksXG4gICAgICAgICAgdGhpcy5heGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCcsXG4gICAgICAgICAgZWxlbWVudCkgKiAoXG4gICAgICAgICAgaW5jbHVkZXMoWydsZWZ0JywgJ3RvcCddLCB0aGlzLmFsaWduKSA/IDEgOiAtMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Vmlld3BvcnRPZmZzZXQoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0b1B4KGNzcyhlbGVtZW50LCAnLS11ay1wb3NpdGlvbi12aWV3cG9ydC1vZmZzZXQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYWN0aXZlJDEgPSBbXTtcblxuICAgIHZhciBNb2RhbCA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBDb250YWluZXIsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNlbFBhbmVsOiBTdHJpbmcsXG4gICAgICAgIHNlbENsb3NlOiBTdHJpbmcsXG4gICAgICAgIGVzY0Nsb3NlOiBCb29sZWFuLFxuICAgICAgICBiZ0Nsb3NlOiBCb29sZWFuLFxuICAgICAgICBzdGFjazogQm9vbGVhblxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBjbHM6ICd1ay1vcGVuJyxcbiAgICAgICAgZXNjQ2xvc2U6IHRydWUsXG4gICAgICAgIGJnQ2xvc2U6IHRydWUsXG4gICAgICAgIG92ZXJsYXk6IHRydWUsXG4gICAgICAgIHN0YWNrOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgcGFuZWwoeyBzZWxQYW5lbCB9LCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gJChzZWxQYW5lbCwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbDtcbiAgICAgICAgfSxcblxuICAgICAgICBiZ0Nsb3NlKHsgYmdDbG9zZSB9KSB7XG4gICAgICAgICAgcmV0dXJuIGJnQ2xvc2UgJiYgdGhpcy5wYW5lbDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYmVmb3JlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSQxLCB0aGlzKSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIGAke3RoaXMuc2VsQ2xvc2V9LGFbaHJlZio9XCIjXCJdYDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBjb25zdCB7IGN1cnJlbnQsIGRlZmF1bHRQcmV2ZW50ZWQgfSA9IGU7XG4gICAgICAgICAgY29uc3QgeyBoYXNoIH0gPSBjdXJyZW50O1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAhZGVmYXVsdFByZXZlbnRlZCAmJlxuICAgICAgICAgIGhhc2ggJiZcbiAgICAgICAgICBpc1NhbWVTaXRlQW5jaG9yKGN1cnJlbnQpICYmXG4gICAgICAgICAgIXdpdGhpbihoYXNoLCB0aGlzLiRlbCkgJiZcbiAgICAgICAgICAkKGhhc2gsIGRvY3VtZW50LmJvZHkpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlcyhjdXJyZW50LCB0aGlzLnNlbENsb3NlKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b2dnbGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpID09PSBpbmNsdWRlcyhhY3RpdmUkMSwgdGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChpbmNsdWRlcyhhY3RpdmUkMSwgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuc3RhY2sgJiYgYWN0aXZlJDEubGVuZ3RoKSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChhY3RpdmUkMS5tYXAoKG1vZGFsKSA9PiBtb2RhbC5oaWRlKCkpKS50aGVuKHRoaXMuc2hvdyk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZSQxLnB1c2godGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgb25jZShcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAnaGlkZScsXG4gICAgICAgICAgb24oZG9jdW1lbnQsICdmb2N1c2luJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChsYXN0KGFjdGl2ZSQxKSA9PT0gdGhpcyAmJiAhd2l0aGluKGUudGFyZ2V0LCB0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgICAgdGhpcy4kZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG5cblxuICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIG9uY2UodGhpcy4kZWwsICdoaWRkZW4nLCBwcmV2ZW50T3ZlcnNjcm9sbCh0aGlzLiRlbCksIHsgc2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIG9uY2UodGhpcy4kZWwsICdoaWRkZW4nLCBwcmV2ZW50QmFja2dyb3VuZFNjcm9sbCgpLCB7IHNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ3pJbmRleCcsIHRvRmxvYXQoY3NzKHRoaXMuJGVsLCAnekluZGV4JykpICsgYWN0aXZlJDEubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzUGFnZSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5iZ0Nsb3NlKSB7XG4gICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgICAnaGlkZScsXG4gICAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlckRvd24kMSwgKHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBsYXN0KGFjdGl2ZSQxKSAhPT0gdGhpcyB8fFxuICAgICAgICAgICAgICB0aGlzLm92ZXJsYXkgJiYgIXdpdGhpbih0YXJnZXQsIHRoaXMuJGVsKSB8fFxuICAgICAgICAgICAgICB3aXRoaW4odGFyZ2V0LCB0aGlzLnBhbmVsKSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgICAgICBgJHtwb2ludGVyVXAkMX0gJHtwb2ludGVyQ2FuY2VsfSBzY3JvbGxgLFxuICAgICAgICAgICAgICAoeyBkZWZhdWx0UHJldmVudGVkLCB0eXBlLCB0YXJnZXQ6IG5ld1RhcmdldCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFkZWZhdWx0UHJldmVudGVkICYmXG4gICAgICAgICAgICAgICAgdHlwZSA9PT0gcG9pbnRlclVwJDEgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQgPT09IG5ld1RhcmdldClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRydWUpO1xuXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmVzY0Nsb3NlKSB7XG4gICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgICAnaGlkZScsXG4gICAgICAgICAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyAmJiBsYXN0KGFjdGl2ZSQxKSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvd24nLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoIWlzRm9jdXNhYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEkKCc6Zm9jdXMnLCB0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRkZW4nLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoaW5jbHVkZXMoYWN0aXZlJDEsIHRoaXMpKSB7XG4gICAgICAgICAgICBhY3RpdmUkMS5zcGxpY2UoYWN0aXZlJDEuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAnekluZGV4JywgJycpO1xuXG4gICAgICAgICAgaWYgKCFhY3RpdmUkMS5zb21lKChtb2RhbCkgPT4gbW9kYWwuY2xzUGFnZSA9PT0gdGhpcy5jbHNQYWdlKSkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmNsc1BhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfV0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNUb2dnbGVkKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyICYmIHBhcmVudCh0aGlzLiRlbCkgIT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmQodGhpcy5jb250YWluZXIsIHRoaXMuJGVsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuc2hvdygpLnRoZW4ocmVzb2x2ZSkpKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUsIGFuaW1hdGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGFuaW1hdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFuaW1hdGUoZWwsIHNob3csIHsgdHJhbnNpdGlvbkVsZW1lbnQsIF90b2dnbGUgfSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IG9uY2UoZWwsICdzaG93IGhpZGUnLCAoKSA9PiB7XG4gICAgICAgIGVsLl9yZWplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLl9yZWplY3QoKTtcbiAgICAgICAgZWwuX3JlamVjdCA9IHJlamVjdDtcblxuICAgICAgICBfdG9nZ2xlKGVsLCBzaG93KTtcblxuICAgICAgICBjb25zdCBvZmYgPSBvbmNlKFxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudCxcbiAgICAgICAgJ3RyYW5zaXRpb25zdGFydCcsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBvbmNlKHRyYW5zaXRpb25FbGVtZW50LCAndHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsJywgcmVzb2x2ZSwge1xuICAgICAgICAgICAgc2VsZjogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuXG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgb2ZmKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCB0b01zKGNzcyh0cmFuc2l0aW9uRWxlbWVudCwgJ3RyYW5zaXRpb25EdXJhdGlvbicpKSk7XG4gICAgICB9KSkuXG4gICAgICB0aGVuKCgpID0+IGRlbGV0ZSBlbC5fcmVqZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b01zKHRpbWUpIHtcbiAgICAgIHJldHVybiB0aW1lID8gZW5kc1dpdGgodGltZSwgJ21zJykgPyB0b0Zsb2F0KHRpbWUpIDogdG9GbG9hdCh0aW1lKSAqIDEwMDAgOiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXZlbnRPdmVyc2Nyb2xsKGVsKSB7XG4gICAgICBpZiAoQ1NTLnN1cHBvcnRzKCdvdmVyc2Nyb2xsLWJlaGF2aW9yJywgJ2NvbnRhaW4nKSkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtcbiAgICAgICAgZWwsXG4gICAgICAgIC4uLmZpbHRlckNoaWxkcmVuKGVsLCAoY2hpbGQpID0+IC9hdXRvfHNjcm9sbC8udGVzdChjc3MoY2hpbGQsICdvdmVyZmxvdycpKSldO1xuXG4gICAgICAgIGNzcyhlbGVtZW50cywgJ292ZXJzY3JvbGxCZWhhdmlvcicsICdjb250YWluJyk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjc3MoZWxlbWVudHMsICdvdmVyc2Nyb2xsQmVoYXZpb3InLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzdGFydENsaWVudFk7XG5cbiAgICAgIGNvbnN0IGV2ZW50cyA9IFtcbiAgICAgIG9uKFxuICAgICAgZWwsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAoeyB0YXJnZXRUb3VjaGVzIH0pID0+IHtcbiAgICAgICAgaWYgKHRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc3RhcnRDbGllbnRZID0gdGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBwYXNzaXZlOiB0cnVlIH0pLFxuXG5cbiAgICAgIG9uKFxuICAgICAgZWwsXG4gICAgICAndG91Y2htb3ZlJyxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IFtzY3JvbGxQYXJlbnRdID0gc2Nyb2xsUGFyZW50cyhlLnRhcmdldCwgL2F1dG98c2Nyb2xsLyk7XG4gICAgICAgIGlmICghd2l0aGluKHNjcm9sbFBhcmVudCwgZWwpKSB7XG4gICAgICAgICAgc2Nyb2xsUGFyZW50ID0gZWw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGllbnRZID0gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgLSBzdGFydENsaWVudFk7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9ID0gc2Nyb2xsUGFyZW50O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgY2xpZW50SGVpZ2h0ID49IHNjcm9sbEhlaWdodCB8fFxuICAgICAgICBzY3JvbGxUb3AgPT09IDAgJiYgY2xpZW50WSA+IDAgfHxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIDw9IGNsaWVudEhlaWdodCAmJiBjbGllbnRZIDwgMClcbiAgICAgICAge1xuICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHBhc3NpdmU6IGZhbHNlIH0pXTtcblxuXG5cbiAgICAgIHJldHVybiAoKSA9PiBldmVudHMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIH1cblxuICAgIGxldCBwcmV2ZW50ZWQ7XG4gICAgZnVuY3Rpb24gcHJldmVudEJhY2tncm91bmRTY3JvbGwoKSB7XG4gICAgICBpZiAocHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuICAgICAgcHJldmVudGVkID0gdHJ1ZTtcblxuICAgICAgY29uc3QgeyBzY3JvbGxpbmdFbGVtZW50IH0gPSBkb2N1bWVudDtcbiAgICAgIGNzcyhzY3JvbGxpbmdFbGVtZW50LCB7XG4gICAgICAgIG92ZXJmbG93WTogJ2hpZGRlbicsXG4gICAgICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgICAgIHBhZGRpbmdSaWdodDogd2lkdGgod2luZG93KSAtIHNjcm9sbGluZ0VsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgIGNzcyhzY3JvbGxpbmdFbGVtZW50LCB7IG92ZXJmbG93WTogJycsIHRvdWNoQWN0aW9uOiAnJywgcGFkZGluZ1JpZ2h0OiAnJyB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyQ2hpbGRyZW4oZWwsIGZuKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgYXBwbHkoZWwsIChub2RlKSA9PiB7XG4gICAgICAgIGlmIChmbihub2RlKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZVNpdGVBbmNob3IoYSkge1xuICAgICAgcmV0dXJuIFsnb3JpZ2luJywgJ3BhdGhuYW1lJywgJ3NlYXJjaCddLmV2ZXJ5KChwYXJ0KSA9PiBhW3BhcnRdID09PSBsb2NhdGlvbltwYXJ0XSk7XG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZTtcblxuICAgIHZhciBkcm9wID0ge1xuICAgICAgbWl4aW5zOiBbQ29udGFpbmVyLCBMYXp5bG9hZCwgUG9zaXRpb24sIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICdwb3MnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtb2RlOiAnbGlzdCcsXG4gICAgICAgIHRvZ2dsZTogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnk6IEJvb2xlYW4sXG4gICAgICAgIGJvdW5kYXJ5WDogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnlZOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldFg6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldFk6IEJvb2xlYW4sXG4gICAgICAgIHN0cmV0Y2g6IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5U2hvdzogTnVtYmVyLFxuICAgICAgICBkZWxheUhpZGU6IE51bWJlcixcbiAgICAgICAgYXV0b1VwZGF0ZTogQm9vbGVhbixcbiAgICAgICAgY2xzRHJvcDogU3RyaW5nLFxuICAgICAgICBhbmltYXRlT3V0OiBCb29sZWFuLFxuICAgICAgICBiZ1Njcm9sbDogQm9vbGVhblxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBtb2RlOiBbJ2NsaWNrJywgJ2hvdmVyJ10sXG4gICAgICAgIHRvZ2dsZTogJy0gKicsXG4gICAgICAgIGJvdW5kYXJ5OiBmYWxzZSxcbiAgICAgICAgYm91bmRhcnlYOiBmYWxzZSxcbiAgICAgICAgYm91bmRhcnlZOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0WDogZmFsc2UsXG4gICAgICAgIHRhcmdldFk6IGZhbHNlLFxuICAgICAgICBzdHJldGNoOiBmYWxzZSxcbiAgICAgICAgZGVsYXlTaG93OiAwLFxuICAgICAgICBkZWxheUhpZGU6IDgwMCxcbiAgICAgICAgYXV0b1VwZGF0ZTogdHJ1ZSxcbiAgICAgICAgY2xzRHJvcDogZmFsc2UsXG4gICAgICAgIGFuaW1hdGVPdXQ6IGZhbHNlLFxuICAgICAgICBiZ1Njcm9sbDogdHJ1ZSxcbiAgICAgICAgYW5pbWF0aW9uOiBbJ3VrLWFuaW1hdGlvbi1mYWRlJ10sXG4gICAgICAgIGNsczogJ3VrLW9wZW4nLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBib3VuZGFyeSh7IGJvdW5kYXJ5LCBib3VuZGFyeVgsIGJvdW5kYXJ5WSB9LCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHF1ZXJ5KGJvdW5kYXJ5WCB8fCBib3VuZGFyeSwgJGVsKSB8fCB3aW5kb3csXG4gICAgICAgICAgcXVlcnkoYm91bmRhcnlZIHx8IGJvdW5kYXJ5LCAkZWwpIHx8IHdpbmRvd107XG5cbiAgICAgICAgfSxcblxuICAgICAgICB0YXJnZXQoeyB0YXJnZXQsIHRhcmdldFgsIHRhcmdldFkgfSwgJGVsKSB7XG4gICAgICAgICAgdGFyZ2V0WCA9IHRhcmdldFggfHwgdGFyZ2V0IHx8IHRoaXMudGFyZ2V0RWw7XG4gICAgICAgICAgdGFyZ2V0WSA9IHRhcmdldFkgfHwgdGFyZ2V0IHx8IHRoaXMudGFyZ2V0RWw7XG5cbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHRhcmdldFggPT09IHRydWUgPyB3aW5kb3cgOiBxdWVyeSh0YXJnZXRYLCAkZWwpLFxuICAgICAgICAgIHRhcmdldFkgPT09IHRydWUgPyB3aW5kb3cgOiBxdWVyeSh0YXJnZXRZLCAkZWwpXTtcblxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSBuZXcgTW91c2VUcmFja2VyKCk7XG4gICAgICB9LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNsc0Ryb3AgPSB0aGlzLiRwcm9wcy5jbHNEcm9wIHx8IGB1ay0ke3RoaXMuJG9wdGlvbnMubmFtZX1gO1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcm9wKTtcblxuICAgICAgICBpZiAodGhpcy50b2dnbGUgJiYgIXRoaXMudGFyZ2V0RWwpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldEVsID0gdGhpcy4kY3JlYXRlKCd0b2dnbGUnLCBxdWVyeSh0aGlzLnRvZ2dsZSwgdGhpcy4kZWwpLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuJGVsLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlXG4gICAgICAgICAgfSkuJGVsO1xuICAgICAgICAgIGF0dHIodGhpcy50YXJnZXRFbCwgJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmxhenlsb2FkKHRoaXMudGFyZ2V0RWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3R5bGUgPSAoKHsgd2lkdGgsIGhlaWdodCB9KSA9PiAoeyB3aWR0aCwgaGVpZ2h0IH0pKSh0aGlzLiRlbC5zdHlsZSk7XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgIGFjdGl2ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY3NzKHRoaXMuJGVsLCB0aGlzLl9zdHlsZSk7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gYC4ke3RoaXMuY2xzRHJvcH0tY2xvc2VgO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuICdhW2hyZWYqPVwiI1wiXSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcih7IGRlZmF1bHRQcmV2ZW50ZWQsIGN1cnJlbnQgfSkge1xuICAgICAgICAgIGNvbnN0IHsgaGFzaCB9ID0gY3VycmVudDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIWRlZmF1bHRQcmV2ZW50ZWQgJiZcbiAgICAgICAgICBoYXNoICYmXG4gICAgICAgICAgaXNTYW1lU2l0ZUFuY2hvcihjdXJyZW50KSAmJlxuICAgICAgICAgICF3aXRoaW4oaGFzaCwgdGhpcy4kZWwpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVzY3JvbGwnLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoZSwgdG9nZ2xlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdyh0b2dnbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHRvZ2dsZS4kZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZXNob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KHRvZ2dsZSA9PSBudWxsID8gdm9pZCAwIDogdG9nZ2xlLiRlbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZWhpZGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICghbWF0Y2hlcyh0aGlzLiRlbCwgJzpmb2N1cyw6aG92ZXInKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6IGAke3BvaW50ZXJFbnRlcn0gZm9jdXNpbmAsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICghaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiBgJHtwb2ludGVyTGVhdmV9IGZvY3Vzb3V0YCxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2hvdmVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCFpc1RvdWNoKGUpICYmIGUucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b2dnbGVkJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoZSwgdG9nZ2xlZCkge1xuICAgICAgICAgIGlmICghdG9nZ2xlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBhY3RpdmUgPSB0aGlzO1xuXG4gICAgICAgICAgdGhpcy50cmFja2VyLmluaXQoKTtcblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHRoaXMuJGVtaXQoKTtcbiAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtcbiAgICAgICAgICBvbihcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICBwb2ludGVyRG93biQxLFxuICAgICAgICAgICh7IHRhcmdldCB9KSA9PiAhd2l0aGluKHRhcmdldCwgdGhpcy4kZWwpICYmXG4gICAgICAgICAgb25jZShcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICBgJHtwb2ludGVyVXAkMX0gJHtwb2ludGVyQ2FuY2VsfSBzY3JvbGxgLFxuICAgICAgICAgICh7IGRlZmF1bHRQcmV2ZW50ZWQsIHR5cGUsIHRhcmdldDogbmV3VGFyZ2V0IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFkZWZhdWx0UHJldmVudGVkICYmXG4gICAgICAgICAgICB0eXBlID09PSBwb2ludGVyVXAkMSAmJlxuICAgICAgICAgICAgdGFyZ2V0ID09PSBuZXdUYXJnZXQgJiZcbiAgICAgICAgICAgICEodGhpcy50YXJnZXRFbCAmJiB3aXRoaW4odGFyZ2V0LCB0aGlzLnRhcmdldEVsKSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlKSksXG5cblxuXG4gICAgICAgICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBvbih3aW5kb3csICdyZXNpemUnLCB1cGRhdGUpLFxuXG4gICAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gb2JzZXJ2ZVJlc2l6ZShcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudHModGhpcy4kZWwpLmNvbmNhdCh0aGlzLnRhcmdldCksXG4gICAgICAgICAgICB1cGRhdGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIH0pKCksXG5cbiAgICAgICAgICAuLi4odGhpcy5hdXRvVXBkYXRlID9cbiAgICAgICAgICBbXG4gICAgICAgICAgb24oW2RvY3VtZW50LCBzY3JvbGxQYXJlbnRzKHRoaXMuJGVsKV0sICdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgICB9KV0gOlxuXG4gICAgICAgICAgW10pLFxuXG4gICAgICAgICAgLi4uKHRoaXMuYmdTY3JvbGwgP1xuICAgICAgICAgIFtdIDpcbiAgICAgICAgICBbcHJldmVudE92ZXJzY3JvbGwodGhpcy4kZWwpLCBwcmV2ZW50QmFja2dyb3VuZFNjcm9sbCgpXSldO1xuXG5cbiAgICAgICAgICBvbmNlKHRoaXMuJGVsLCAnaGlkZScsICgpID0+IGhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IGhhbmRsZXIoKSksIHtcbiAgICAgICAgICAgIHNlbGY6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3JlaGlkZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZScsXG5cbiAgICAgICAgaGFuZGxlcih7IHRhcmdldCB9KSB7XG4gICAgICAgICAgaWYgKHRoaXMuJGVsICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIGFjdGl2ZSA9XG4gICAgICAgICAgICBhY3RpdmUgPT09IG51bGwgJiYgd2l0aGluKHRhcmdldCwgdGhpcy4kZWwpICYmIHRoaXMuaXNUb2dnbGVkKCkgP1xuICAgICAgICAgICAgdGhpcyA6XG4gICAgICAgICAgICBhY3RpdmU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpID8gbnVsbCA6IGFjdGl2ZTtcbiAgICAgICAgICB0aGlzLnRyYWNrZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1dLFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiAhaGFzQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRW50ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3codGFyZ2V0ID0gdGhpcy50YXJnZXRFbCwgZGVsYXkgPSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkgJiYgdGFyZ2V0ICYmIHRoaXMudGFyZ2V0RWwgJiYgdGFyZ2V0ICE9PSB0aGlzLnRhcmdldEVsKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRhcmdldEVsID0gdGFyZ2V0O1xuXG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChkZWxheSAmJiBhY3RpdmUuaXNEZWxheWluZykge1xuICAgICAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gbWF0Y2hlcyh0YXJnZXQsICc6aG92ZXInKSAmJiB0aGlzLnNob3coKSwgMTApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwcmV2O1xuICAgICAgICAgICAgd2hpbGUgKGFjdGl2ZSAmJiBwcmV2ICE9PSBhY3RpdmUgJiYgIXdpdGhpbih0aGlzLiRlbCwgYWN0aXZlLiRlbCkpIHtcbiAgICAgICAgICAgICAgcHJldiA9IGFjdGl2ZTtcbiAgICAgICAgICAgICAgYWN0aXZlLmhpZGUoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIgJiYgcGFyZW50KHRoaXMuJGVsKSAhPT0gdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZCh0aGlzLmNvbnRhaW5lciwgdGhpcy4kZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2hvd1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUpLFxuICAgICAgICAgIGRlbGF5ICYmIHRoaXMuZGVsYXlTaG93IHx8IDApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZShkZWxheSA9IHRydWUsIGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgICAgICAgY29uc3QgaGlkZSA9ICgpID0+IHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIHRoaXMuYW5pbWF0ZU91dCAmJiBhbmltYXRlKTtcblxuICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcblxuICAgICAgICAgIHRoaXMuaXNEZWxheWluZyA9IGdldFBvc2l0aW9uZWRFbGVtZW50cyh0aGlzLiRlbCkuc29tZSgoZWwpID0+IHRoaXMudHJhY2tlci5tb3Zlc1RvKGVsKSk7XG5cblxuICAgICAgICAgIGlmIChkZWxheSAmJiB0aGlzLmlzRGVsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRpbWVyID0gc2V0VGltZW91dCh0aGlzLmhpZGUsIDUwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlbGF5ICYmIHRoaXMuZGVsYXlIaWRlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lciA9IHNldFRpbWVvdXQoaGlkZSwgdGhpcy5kZWxheUhpZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyVGltZXJzKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lcik7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5oaWRlVGltZXIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaXNEZWxheWluZyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWN0aXZlKCkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmUgPT09IHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpb24oKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIGAke3RoaXMuY2xzRHJvcH0tc3RhY2tgKTtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHRoaXMuX3N0eWxlKTtcblxuICAgICAgICAgIC8vIEVuc3VyZSBub25lIHBvc2l0aW9uZWQgZWxlbWVudCBkb2VzIG5vdCBnZW5lcmF0ZSBzY3JvbGxiYXJzXG4gICAgICAgICAgdGhpcy4kZWwuaGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0cyA9IHRoaXMudGFyZ2V0Lm1hcCgodGFyZ2V0KSA9PiBnZXRWaWV3cG9ydCQxKHRoaXMuJGVsLCB0YXJnZXQpKTtcbiAgICAgICAgICBjb25zdCB2aWV3cG9ydE9mZnNldCA9IHRoaXMuZ2V0Vmlld3BvcnRPZmZzZXQodGhpcy4kZWwpO1xuXG4gICAgICAgICAgY29uc3QgZGlycyA9IFtcbiAgICAgICAgICBbMCwgWyd4JywgJ3dpZHRoJywgJ2xlZnQnLCAncmlnaHQnXV0sXG4gICAgICAgICAgWzEsIFsneScsICdoZWlnaHQnLCAndG9wJywgJ2JvdHRvbSddXV07XG5cblxuICAgICAgICAgIGZvciAoY29uc3QgW2ksIFtheGlzLCBwcm9wXV0gb2YgZGlycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXhpcyAhPT0gYXhpcyAmJiBpbmNsdWRlcyhbYXhpcywgdHJ1ZV0sIHRoaXMuc3RyZXRjaCkpIHtcbiAgICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgICAgICAgICAgW3Byb3BdOiBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBvZmZzZXQodGhpcy5ib3VuZGFyeVtpXSlbcHJvcF0sXG4gICAgICAgICAgICAgICAgdmlld3BvcnRzW2ldW3Byb3BdIC0gMiAqIHZpZXdwb3J0T2Zmc2V0KSxcblxuICAgICAgICAgICAgICAgIFtgb3ZlcmZsb3ctJHtheGlzfWBdOiAnYXV0bydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbWF4V2lkdGggPSB2aWV3cG9ydHNbMF0ud2lkdGggLSAyICogdmlld3BvcnRPZmZzZXQ7XG5cbiAgICAgICAgICBpZiAodGhpcy4kZWwub2Zmc2V0V2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIGAke3RoaXMuY2xzRHJvcH0tc3RhY2tgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3ModGhpcy4kZWwsICdtYXhXaWR0aCcsIG1heFdpZHRoKTtcblxuICAgICAgICAgIHRoaXMuJGVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5wb3NpdGlvbkF0KHRoaXMuJGVsLCB0aGlzLnRhcmdldCwgdGhpcy5ib3VuZGFyeSk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IFtpLCBbYXhpcywgcHJvcCwgc3RhcnQsIGVuZF1dIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF4aXMgPT09IGF4aXMgJiYgaW5jbHVkZXMoW2F4aXMsIHRydWVdLCB0aGlzLnN0cmV0Y2gpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uT2Zmc2V0ID0gTWF0aC5hYnModGhpcy5nZXRQb3NpdGlvbk9mZnNldCh0aGlzLiRlbCkpO1xuICAgICAgICAgICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSBvZmZzZXQodGhpcy50YXJnZXRbaV0pO1xuICAgICAgICAgICAgICBjb25zdCBlbE9mZnNldCA9IG9mZnNldCh0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgICAgICAgICAgW3Byb3BdOlxuICAgICAgICAgICAgICAgICh0YXJnZXRPZmZzZXRbc3RhcnRdID4gZWxPZmZzZXRbc3RhcnRdID9cbiAgICAgICAgICAgICAgICB0YXJnZXRPZmZzZXRbc3RhcnRdIC1cbiAgICAgICAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBvZmZzZXQodGhpcy5ib3VuZGFyeVtpXSlbc3RhcnRdLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0c1tpXVtzdGFydF0gKyB2aWV3cG9ydE9mZnNldCkgOlxuXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgb2Zmc2V0KHRoaXMuYm91bmRhcnlbaV0pW2VuZF0sXG4gICAgICAgICAgICAgICAgdmlld3BvcnRzW2ldW2VuZF0gLSB2aWV3cG9ydE9mZnNldCkgLVxuICAgICAgICAgICAgICAgIHRhcmdldE9mZnNldFtlbmRdKSAtIHBvc2l0aW9uT2Zmc2V0LFxuICAgICAgICAgICAgICAgIFtgb3ZlcmZsb3ctJHtheGlzfWBdOiAnYXV0bydcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkF0KHRoaXMuJGVsLCB0aGlzLnRhcmdldCwgdGhpcy5ib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uZWRFbGVtZW50cyhlbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBhcHBseShlbCwgKGVsKSA9PiBjc3MoZWwsICdwb3NpdGlvbicpICE9PSAnc3RhdGljJyAmJiByZXN1bHQucHVzaChlbCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCQxKGVsLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBvZmZzZXRWaWV3cG9ydChzY3JvbGxQYXJlbnRzKHRhcmdldCkuZmluZCgocGFyZW50KSA9PiB3aXRoaW4oZWwsIHBhcmVudCkpKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybUN1c3RvbSA9IHtcbiAgICAgIG1peGluczogW0NsYXNzXSxcblxuICAgICAgYXJnczogJ3RhcmdldCcsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRhcmdldDogQm9vbGVhblxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBpbnB1dChfLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gJChzZWxJbnB1dCwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGF0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGFyZ2V0KHsgdGFyZ2V0IH0sICRlbCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0YXJnZXQgJiYgKFxuICAgICAgICAgICAgdGFyZ2V0ID09PSB0cnVlICYmIHBhcmVudCh0aGlzLmlucHV0KSA9PT0gJGVsICYmIHRoaXMuaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nIHx8XG4gICAgICAgICAgICAkKHRhcmdldCwgJGVsKSkpO1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZSgpIHt2YXIgX2lucHV0JGZpbGVzO1xuICAgICAgICBjb25zdCB7IHRhcmdldCwgaW5wdXQgfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3B0aW9uO1xuICAgICAgICBjb25zdCBwcm9wID0gaXNJbnB1dCh0YXJnZXQpID8gJ3ZhbHVlJyA6ICd0ZXh0Q29udGVudCc7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKF9pbnB1dCRmaWxlcyA9IGlucHV0LmZpbGVzKSAhPSBudWxsICYmIF9pbnB1dCRmaWxlc1swXSA/XG4gICAgICAgIGlucHV0LmZpbGVzWzBdLm5hbWUgOlxuICAgICAgICBtYXRjaGVzKGlucHV0LCAnc2VsZWN0JykgJiYgKFxuICAgICAgICBvcHRpb24gPSAkJCgnb3B0aW9uJywgaW5wdXQpLmZpbHRlcigoZWwpID0+IGVsLnNlbGVjdGVkKVswXSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICA/IG9wdGlvbi50ZXh0Q29udGVudCA6XG4gICAgICAgIGlucHV0LnZhbHVlO1xuXG4gICAgICAgIGlmIChwcmV2ICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NoYW5nZScsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Jlc2V0JyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCh0aGlzLiRlbCwgJ2Zvcm0nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgfV1cblxuICAgIH07XG5cbiAgICB2YXIgTWFyZ2luID0ge1xuICAgICAgbWl4aW5zOiBbUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWFyZ2luOiBTdHJpbmcsXG4gICAgICAgIGZpcnN0Q29sdW1uOiBCb29sZWFuXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcmdpbjogJ3VrLW1hcmdpbi1zbWFsbC10b3AnLFxuICAgICAgICBmaXJzdENvbHVtbjogJ3VrLWZpcnN0LWNvbHVtbidcbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIC4uLnRvQXJyYXkodGhpcy4kZWwuY2hpbGRyZW4pXTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlTXV0YXRpb24odGhpcy4kZWwsICgpID0+IHRoaXMuJHJlc2V0KCksIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3R5bGUnXVxuICAgICAgICB9KSk7XG5cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGNvbnN0IHJvd3MgPSBnZXRSb3dzKHRoaXMuJGVsLmNoaWxkcmVuKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3dzLFxuICAgICAgICAgICAgY29sdW1uczogZ2V0Q29sdW1ucyhyb3dzKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoeyBjb2x1bW5zLCByb3dzIH0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiByb3cpIHtcbiAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY29sdW1uLCB0aGlzLm1hcmdpbiwgcm93c1swXSAhPT0gcm93KTtcbiAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY29sdW1uLCB0aGlzLmZpcnN0Q29sdW1uLCBjb2x1bW5zWzBdLmluY2x1ZGVzKGNvbHVtbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ11cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0Um93cyhpdGVtcykge1xuICAgICAgcmV0dXJuIHNvcnRCeShpdGVtcywgJ3RvcCcsICdib3R0b20nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5zKHJvd3MpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBzb3J0Qnkocm93LCAnbGVmdCcsICdyaWdodCcpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNvcnRlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbHVtbnNbal0gPSBjb2x1bW5zW2pdID8gY29sdW1uc1tqXS5jb25jYXQoc29ydGVkW2pdKSA6IHNvcnRlZFtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNSdGwgPyBjb2x1bW5zLnJldmVyc2UoKSA6IGNvbHVtbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEJ5KGl0ZW1zLCBzdGFydFByb3AsIGVuZFByb3ApIHtcbiAgICAgIGNvbnN0IHNvcnRlZCA9IFtbXV07XG5cbiAgICAgIGZvciAoY29uc3QgZWwgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFpc1Zpc2libGUoZWwpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGltID0gZ2V0T2Zmc2V0KGVsKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gc29ydGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IHNvcnRlZFtpXTtcblxuICAgICAgICAgIGlmICghY3VycmVudFswXSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBzdGFydERpbTtcbiAgICAgICAgICBpZiAoY3VycmVudFswXS5vZmZzZXRQYXJlbnQgPT09IGVsLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgc3RhcnREaW0gPSBnZXRPZmZzZXQoY3VycmVudFswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpbSA9IGdldE9mZnNldChlbCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFydERpbSA9IGdldE9mZnNldChjdXJyZW50WzBdLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGltW3N0YXJ0UHJvcF0gPj0gc3RhcnREaW1bZW5kUHJvcF0gLSAxICYmIGRpbVtzdGFydFByb3BdICE9PSBzdGFydERpbVtzdGFydFByb3BdKSB7XG4gICAgICAgICAgICBzb3J0ZWQucHVzaChbZWxdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaW1bZW5kUHJvcF0gLSAxID4gc3RhcnREaW1bc3RhcnRQcm9wXSB8fCBkaW1bc3RhcnRQcm9wXSA9PT0gc3RhcnREaW1bc3RhcnRQcm9wXSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBzb3J0ZWQudW5zaGlmdChbZWxdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc29ydGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9mZnNldChlbGVtZW50LCBvZmZzZXQgPSBmYWxzZSkge1xuICAgICAgbGV0IHsgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0LCBvZmZzZXRIZWlnaHQsIG9mZnNldFdpZHRoIH0gPSBlbGVtZW50O1xuXG4gICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIFtvZmZzZXRUb3AsIG9mZnNldExlZnRdID0gb2Zmc2V0UG9zaXRpb24oZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBib3R0b206IG9mZnNldFRvcCArIG9mZnNldEhlaWdodCxcbiAgICAgICAgcmlnaHQ6IG9mZnNldExlZnQgKyBvZmZzZXRXaWR0aFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgU2Nyb2xsID0ge1xuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICByZWdpc3RlclNjcm9sbExpc3RlbmVyKHRoaXMuX3VpZCwgKCkgPT4gdGhpcy4kZW1pdCgnc2Nyb2xsJykpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB1bnJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIodGhpcy5fdWlkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2Nyb2xsTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB1bmJpbmRTY3JvbGxMaXN0ZW5lcjtcbiAgICBmdW5jdGlvbiByZWdpc3RlclNjcm9sbExpc3RlbmVyKGlkLCBsaXN0ZW5lcikge1xuICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgPVxuICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgfHxcbiAgICAgIG9uKHdpbmRvdywgJ3Njcm9sbCcsICgpID0+IHNjcm9sbExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSksIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHNjcm9sbExpc3RlbmVycy5zZXQoaWQsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIoaWQpIHtcbiAgICAgIHNjcm9sbExpc3RlbmVycy5kZWxldGUoaWQpO1xuICAgICAgaWYgKHVuYmluZFNjcm9sbExpc3RlbmVyICYmICFzY3JvbGxMaXN0ZW5lcnMuc2l6ZSkge1xuICAgICAgICB1bmJpbmRTY3JvbGxMaXN0ZW5lcigpO1xuICAgICAgICB1bmJpbmRTY3JvbGxMaXN0ZW5lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdyaWQgPSB7XG4gICAgICBleHRlbmRzOiBNYXJnaW4sXG5cbiAgICAgIG1peGluczogW0NsYXNzXSxcblxuICAgICAgbmFtZTogJ2dyaWQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtYXNvbnJ5OiBCb29sZWFuLFxuICAgICAgICBwYXJhbGxheDogTnVtYmVyXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcmdpbjogJ3VrLWdyaWQtbWFyZ2luJyxcbiAgICAgICAgY2xzU3RhY2s6ICd1ay1ncmlkLXN0YWNrJyxcbiAgICAgICAgbWFzb25yeTogZmFsc2UsXG4gICAgICAgIHBhcmFsbGF4OiAwXG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubWFzb25yeSAmJiBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLWZsZXgtdG9wIHVrLWZsZXgtd3JhcC10b3AnKTtcbiAgICAgICAgdGhpcy5wYXJhbGxheCAmJiByZWdpc3RlclNjcm9sbExpc3RlbmVyKHRoaXMuX3VpZCwgKCkgPT4gdGhpcy4kZW1pdCgnc2Nyb2xsJykpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB1bnJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIodGhpcy5fdWlkKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICB3cml0ZSh7IGNvbHVtbnMgfSkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc1N0YWNrLCBjb2x1bW5zLmxlbmd0aCA8IDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICByZWFkKGRhdGEpIHtcbiAgICAgICAgICBsZXQgeyBjb2x1bW5zLCByb3dzIH0gPSBkYXRhO1xuXG4gICAgICAgICAgLy8gRmlsdGVyIGNvbXBvbmVudCBtYWtlcyBlbGVtZW50cyBwb3NpdGlvbmVkIGFic29sdXRlXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICFjb2x1bW5zLmxlbmd0aCB8fFxuICAgICAgICAgICF0aGlzLm1hc29ucnkgJiYgIXRoaXMucGFyYWxsYXggfHxcbiAgICAgICAgICBwb3NpdGlvbmVkQWJzb2x1dGUodGhpcy4kZWwpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEudHJhbnNsYXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB0cmFuc2xhdGVzID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKHRoaXMuJGVsKTtcbiAgICAgICAgICBjb25zdCBjb2x1bW5IZWlnaHRzID0gY29sdW1ucy5tYXAoKGNvbHVtbikgPT4gc3VtQnkoY29sdW1uLCAnb2Zmc2V0SGVpZ2h0JykpO1xuICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IGdldE1hcmdpblRvcChub2RlcywgdGhpcy5tYXJnaW4pICogKHJvd3MubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgY29uc3QgZWxIZWlnaHQgPSBNYXRoLm1heCguLi5jb2x1bW5IZWlnaHRzKSArIG1hcmdpbjtcblxuICAgICAgICAgIGlmICh0aGlzLm1hc29ucnkpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLm1hcCgoY29sdW1uKSA9PiBzb3J0QnkkMShjb2x1bW4sICdvZmZzZXRUb3AnKSk7XG4gICAgICAgICAgICB0cmFuc2xhdGVzID0gZ2V0VHJhbnNsYXRlcyhyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcGFkZGluZyA9IE1hdGguYWJzKHRoaXMucGFyYWxsYXgpO1xuICAgICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gY29sdW1uSGVpZ2h0cy5yZWR1Y2UoXG4gICAgICAgICAgICAobmV3UGFkZGluZywgaGd0LCBpKSA9PiBNYXRoLm1heChcbiAgICAgICAgICAgIG5ld1BhZGRpbmcsXG4gICAgICAgICAgICBoZ3QgKyBtYXJnaW4gKyAoaSAlIDIgPyBwYWRkaW5nIDogcGFkZGluZyAvIDgpIC0gZWxIZWlnaHQpLFxuXG4gICAgICAgICAgICAwKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IHBhZGRpbmcsIGNvbHVtbnMsIHRyYW5zbGF0ZXMsIGhlaWdodDogdHJhbnNsYXRlcyA/IGVsSGVpZ2h0IDogJycgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZSh7IGhlaWdodCwgcGFkZGluZyB9KSB7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAncGFkZGluZ0JvdHRvbScsIHBhZGRpbmcgfHwgJycpO1xuICAgICAgICAgIGhlaWdodCAhPT0gZmFsc2UgJiYgY3NzKHRoaXMuJGVsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ11cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5wYXJhbGxheCAmJiBwb3NpdGlvbmVkQWJzb2x1dGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjcm9sbGVkOiB0aGlzLnBhcmFsbGF4ID9cbiAgICAgICAgICAgIHNjcm9sbGVkT3Zlcih0aGlzLiRlbCkgKiBNYXRoLmFicyh0aGlzLnBhcmFsbGF4KSA6XG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoeyBjb2x1bW5zLCBzY3JvbGxlZCwgdHJhbnNsYXRlcyB9KSB7XG4gICAgICAgICAgaWYgKHNjcm9sbGVkID09PSBmYWxzZSAmJiAhdHJhbnNsYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uLCBpKSA9PiBjb2x1bW4uZm9yRWFjaCgoZWwsIGopID0+IGNzcyhcbiAgICAgICAgICBlbCxcbiAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAhc2Nyb2xsZWQgJiYgIXRyYW5zbGF0ZXMgP1xuICAgICAgICAgICcnIDpcbiAgICAgICAgICBgdHJhbnNsYXRlWSgke1xuICAgICAgKHRyYW5zbGF0ZXMgJiYgLXRyYW5zbGF0ZXNbaV1bal0pICsgKFxuICAgICAgc2Nyb2xsZWQgPyBpICUgMiA/IHNjcm9sbGVkIDogc2Nyb2xsZWQgLyA4IDogMClcbiAgICAgIH1weClgKSkpO1xuXG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydzY3JvbGwnLCAncmVzaXplJ11cbiAgICAgIH1dXG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9zaXRpb25lZEFic29sdXRlKGVsKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4oZWwpLnNvbWUoKGVsKSA9PiBjc3MoZWwsICdwb3NpdGlvbicpID09PSAnYWJzb2x1dGUnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2xhdGVzKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgIGNvbnN0IHJvd0hlaWdodHMgPSByb3dzLm1hcCgocm93KSA9PiBNYXRoLm1heCguLi5yb3cubWFwKChlbCkgPT4gZWwub2Zmc2V0SGVpZ2h0KSkpO1xuXG4gICAgICByZXR1cm4gY29sdW1ucy5tYXAoKGVsZW1lbnRzKSA9PiB7XG4gICAgICAgIGxldCBwcmV2ID0gMDtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLm1hcChcbiAgICAgICAgKGVsZW1lbnQsIHJvdykgPT4gcHJldiArPSByb3cgPyByb3dIZWlnaHRzW3JvdyAtIDFdIC0gZWxlbWVudHNbcm93IC0gMV0ub2Zmc2V0SGVpZ2h0IDogMCk7XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1hcmdpblRvcChub2RlcywgY2xzKSB7XG4gICAgICBjb25zdCBbbm9kZV0gPSBub2Rlcy5maWx0ZXIoKGVsKSA9PiBoYXNDbGFzcyhlbCwgY2xzKSk7XG5cbiAgICAgIHJldHVybiB0b0Zsb2F0KG5vZGUgPyBjc3Mobm9kZSwgJ21hcmdpblRvcCcpIDogY3NzKG5vZGVzWzBdLCAncGFkZGluZ0xlZnQnKSk7XG4gICAgfVxuXG4gICAgdmFyIGhlaWdodE1hdGNoID0ge1xuICAgICAgbWl4aW5zOiBbUmVzaXplXSxcblxuICAgICAgYXJnczogJ3RhcmdldCcsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICByb3c6IEJvb2xlYW5cbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiAnPiAqJyxcbiAgICAgICAgcm93OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgIGdldCh7IHRhcmdldCB9LCAkZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkJCh0YXJnZXQsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgdGhpcy4kcmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIC4uLnRoaXMuZWxlbWVudHNdO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvd3M6ICh0aGlzLnJvdyA/IGdldFJvd3ModGhpcy5lbGVtZW50cykgOiBbdGhpcy5lbGVtZW50c10pLm1hcChtYXRjaCQxKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoeyByb3dzIH0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgaGVpZ2h0cywgZWxlbWVudHMgfSBvZiByb3dzKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCwgaSkgPT4gY3NzKGVsLCAnbWluSGVpZ2h0JywgaGVpZ2h0c1tpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ11cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF0Y2gkMShlbGVtZW50cykge1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0czogWycnXSwgZWxlbWVudHMgfTtcbiAgICAgIH1cblxuICAgICAgY3NzKGVsZW1lbnRzLCAnbWluSGVpZ2h0JywgJycpO1xuICAgICAgbGV0IGhlaWdodHMgPSBlbGVtZW50cy5tYXAoZ2V0SGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLmhlaWdodHMpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHRzOiBlbGVtZW50cy5tYXAoKGVsLCBpKSA9PiBoZWlnaHRzW2ldLnRvRml4ZWQoMikgPT09IG1heC50b0ZpeGVkKDIpID8gJycgOiBtYXgpLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIZWlnaHQoZWxlbWVudCkge1xuICAgICAgbGV0IHN0eWxlID0gZmFsc2U7XG4gICAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICBzdHlsZSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgY3NzKGVsZW1lbnQsICdkaXNwbGF5JywgJ2Jsb2NrJywgJ2ltcG9ydGFudCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoZWlnaHQgPSBkaW1lbnNpb25zJDEoZWxlbWVudCkuaGVpZ2h0IC0gYm94TW9kZWxBZGp1c3QoZWxlbWVudCwgJ2hlaWdodCcsICdjb250ZW50LWJveCcpO1xuXG4gICAgICBpZiAoc3R5bGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGNzcyhlbGVtZW50LCAnZGlzcGxheScsIHN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgaGVpZ2h0Vmlld3BvcnQgPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBleHBhbmQ6IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldFRvcDogQm9vbGVhbixcbiAgICAgICAgb2Zmc2V0Qm90dG9tOiBCb29sZWFuLFxuICAgICAgICBtaW5IZWlnaHQ6IE51bWJlclxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBleHBhbmQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXRUb3A6IGZhbHNlLFxuICAgICAgICBvZmZzZXRCb3R0b206IGZhbHNlLFxuICAgICAgICBtaW5IZWlnaHQ6IDBcbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBvZmZzZXRUb3AgY2hhbmdlXG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIC4uLnNjcm9sbFBhcmVudHModGhpcy4kZWwsIC9hdXRvfHNjcm9sbC8pXTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKHsgbWluSGVpZ2h0OiBwcmV2IH0pIHtcbiAgICAgICAgICBpZiAoIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbWluSGVpZ2h0ID0gJyc7XG4gICAgICAgICAgY29uc3QgYm94ID0gYm94TW9kZWxBZGp1c3QodGhpcy4kZWwsICdoZWlnaHQnLCAnY29udGVudC1ib3gnKTtcblxuICAgICAgICAgIGNvbnN0IHsgYm9keSwgc2Nyb2xsaW5nRWxlbWVudCB9ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgY29uc3QgW3Njcm9sbEVsZW1lbnRdID0gc2Nyb2xsUGFyZW50cyh0aGlzLiRlbCwgL2F1dG98c2Nyb2xsLyk7XG4gICAgICAgICAgY29uc3QgeyBoZWlnaHQ6IHZpZXdwb3J0SGVpZ2h0IH0gPSBvZmZzZXRWaWV3cG9ydChcbiAgICAgICAgICBzY3JvbGxFbGVtZW50ID09PSBib2R5ID8gc2Nyb2xsaW5nRWxlbWVudCA6IHNjcm9sbEVsZW1lbnQpO1xuXG5cbiAgICAgICAgICBpZiAodGhpcy5leHBhbmQpIHtcbiAgICAgICAgICAgIG1pbkhlaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdmlld3BvcnRIZWlnaHQgLSAoXG4gICAgICAgICAgICBkaW1lbnNpb25zJDEoc2Nyb2xsRWxlbWVudCkuaGVpZ2h0IC0gZGltZW5zaW9ucyQxKHRoaXMuJGVsKS5oZWlnaHQpIC1cbiAgICAgICAgICAgIGJveCxcbiAgICAgICAgICAgIDApO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU2Nyb2xsaW5nRWxlbWVudCA9XG4gICAgICAgICAgICBzY3JvbGxpbmdFbGVtZW50ID09PSBzY3JvbGxFbGVtZW50IHx8IGJvZHkgPT09IHNjcm9sbEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIG9uIG1vYmlsZSBkZXZpY2VzIChpT1MgYW5kIEFuZHJvaWQpIHdpbmRvdy5pbm5lckhlaWdodCAhPT0gMTAwdmhcbiAgICAgICAgICAgIG1pbkhlaWdodCA9IGBjYWxjKCR7aXNTY3JvbGxpbmdFbGVtZW50ID8gJzEwMHZoJyA6IGAke3ZpZXdwb3J0SGVpZ2h0fXB4YH1gO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRUb3ApIHtcbiAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IG9mZnNldFBvc2l0aW9uKHRoaXMuJGVsKVswXSAtIG9mZnNldFBvc2l0aW9uKHNjcm9sbEVsZW1lbnQpWzBdO1xuICAgICAgICAgICAgICAgIG1pbkhlaWdodCArPSB0b3AgPiAwICYmIHRvcCA8IHZpZXdwb3J0SGVpZ2h0IC8gMiA/IGAgLSAke3RvcH1weGAgOiAnJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQgKz0gYCAtICR7Y3NzKHNjcm9sbEVsZW1lbnQsICdwYWRkaW5nVG9wJyl9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRCb3R0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IGAgLSAke2RpbWVuc2lvbnMkMSh0aGlzLiRlbC5uZXh0RWxlbWVudFNpYmxpbmcpLmhlaWdodH1weGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTnVtZXJpYyh0aGlzLm9mZnNldEJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IGAgLSAke3RoaXMub2Zmc2V0Qm90dG9tfXZoYDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vZmZzZXRCb3R0b20gJiYgZW5kc1dpdGgodGhpcy5vZmZzZXRCb3R0b20sICdweCcpKSB7XG4gICAgICAgICAgICAgIG1pbkhlaWdodCArPSBgIC0gJHt0b0Zsb2F0KHRoaXMub2Zmc2V0Qm90dG9tKX1weGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHRoaXMub2Zmc2V0Qm90dG9tKSkge1xuICAgICAgICAgICAgICBtaW5IZWlnaHQgKz0gYCAtICR7ZGltZW5zaW9ucyQxKHF1ZXJ5KHRoaXMub2Zmc2V0Qm90dG9tLCB0aGlzLiRlbCkpLmhlaWdodH1weGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkhlaWdodCArPSBgJHtib3ggPyBgIC0gJHtib3h9cHhgIDogJyd9KWA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgbWluSGVpZ2h0LCBwcmV2IH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoeyBtaW5IZWlnaHQgfSkge1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBtaW5IZWlnaHQgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5taW5IZWlnaHQgJiYgdG9GbG9hdChjc3ModGhpcy4kZWwsICdtaW5IZWlnaHQnKSkgPCB0aGlzLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCAnbWluSGVpZ2h0JywgdGhpcy5taW5IZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ11cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFNWRyA9IHtcbiAgICAgIGFyZ3M6ICdzcmMnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBpZDogQm9vbGVhbixcbiAgICAgICAgaWNvbjogU3RyaW5nLFxuICAgICAgICBzcmM6IFN0cmluZyxcbiAgICAgICAgc3R5bGU6IFN0cmluZyxcbiAgICAgICAgd2lkdGg6IE51bWJlcixcbiAgICAgICAgaGVpZ2h0OiBOdW1iZXIsXG4gICAgICAgIHJhdGlvOiBOdW1iZXIsXG4gICAgICAgIGNsYXNzOiBTdHJpbmcsXG4gICAgICAgIHN0cm9rZUFuaW1hdGlvbjogQm9vbGVhbixcbiAgICAgICAgYXR0cmlidXRlczogJ2xpc3QnXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJhdGlvOiAxLFxuICAgICAgICBpbmNsdWRlOiBbJ3N0eWxlJywgJ2NsYXNzJ10sXG4gICAgICAgIGNsYXNzOiAnJyxcbiAgICAgICAgc3Ryb2tlQW5pbWF0aW9uOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbGFzcyArPSAnIHVrLXN2Zyc7XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pY29uICYmIGluY2x1ZGVzKHRoaXMuc3JjLCAnIycpKSB7XG4gICAgICAgICAgW3RoaXMuc3JjLCB0aGlzLmljb25dID0gdGhpcy5zcmMuc3BsaXQoJyMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnID0gdGhpcy5nZXRTdmcoKS50aGVuKChlbCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGluc2VydFNWRyhlbCwgdGhpcy4kZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdmdFbCAmJiBzdmcgIT09IHRoaXMuc3ZnRWwpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlJDEodGhpcy5zdmdFbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHN2ZywgZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdmdFbCA9IHN2ZztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG5vb3ApO1xuXG4gICAgICAgIGlmICh0aGlzLnN0cm9rZUFuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuc3ZnLnRoZW4oKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIGFwcGx5QW5pbWF0aW9uKGVsKTtcbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKGVsLCAocmVjb3Jkcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhcHBseUFuaW1hdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN2Zy50aGVuKChzdmcpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzVm9pZEVsZW1lbnQodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmUkMShzdmcpO1xuICAgICAgICAgIHRoaXMuc3ZnRWwgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN2ZyA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGdldFN2ZygpIHtcbiAgICAgICAgICBpZiAoaXNUYWcodGhpcy4kZWwsICdpbWcnKSAmJiAhdGhpcy4kZWwuY29tcGxldGUgJiYgdGhpcy4kZWwubG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IG9uY2UodGhpcy4kZWwsICdsb2FkJywgKCkgPT4gcmVzb2x2ZSh0aGlzLmdldFN2ZygpKSkpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhcnNlU1ZHKGF3YWl0IGxvYWRTVkcodGhpcy5zcmMpLCB0aGlzLmljb24pIHx8IFByb21pc2UucmVqZWN0KCdTVkcgbm90IGZvdW5kLicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFwcGx5QXR0cmlidXRlcyhlbCwgcmVmKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHRoaXMuJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLmluY2x1ZGUsIHByb3ApICYmIHByb3AgaW4gdGhpcykge1xuICAgICAgICAgICAgICBhdHRyKGVsLCBwcm9wLCB0aGlzW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wLCB2YWx1ZV0gPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlXS5zcGxpdCgnOicsIDIpO1xuICAgICAgICAgICAgYXR0cihlbCwgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgcmVtb3ZlQXR0cihlbCwgJ2lkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJvcHMgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuICAgICAgICAgIGxldCBkaW1lbnNpb25zID0gcHJvcHMubWFwKChwcm9wKSA9PiB0aGlzW3Byb3BdKTtcblxuICAgICAgICAgIGlmICghZGltZW5zaW9ucy5zb21lKCh2YWwpID0+IHZhbCkpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBwcm9wcy5tYXAoKHByb3ApID0+IGF0dHIocmVmLCBwcm9wKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgdmlld0JveCA9IGF0dHIocmVmLCAndmlld0JveCcpO1xuICAgICAgICAgIGlmICh2aWV3Qm94ICYmICFkaW1lbnNpb25zLnNvbWUoKHZhbCkgPT4gdmFsKSkge1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IHZpZXdCb3guc3BsaXQoJyAnKS5zbGljZSgyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaW1lbnNpb25zLmZvckVhY2goKHZhbCwgaSkgPT4gYXR0cihlbCwgcHJvcHNbaV0sIHRvRmxvYXQodmFsKSAqIHRoaXMucmF0aW8gfHwgbnVsbCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGxvYWRTVkcgPSBtZW1vaXplKGFzeW5jIChzcmMpID0+IHtcbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgoc3JjLCAnZGF0YTonKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3JjLnNwbGl0KCcsJylbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoYXdhaXQgZmV0Y2goc3JjKSkudGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU1ZHKHN2ZywgaWNvbikge3ZhciBfc3ZnO1xuICAgICAgaWYgKGljb24gJiYgaW5jbHVkZXMoc3ZnLCAnPHN5bWJvbCcpKSB7XG4gICAgICAgIHN2ZyA9IHBhcnNlU3ltYm9scyhzdmcsIGljb24pIHx8IHN2ZztcbiAgICAgIH1cblxuICAgICAgc3ZnID0gJChzdmcuc3Vic3RyKHN2Zy5pbmRleE9mKCc8c3ZnJykpKTtcbiAgICAgIHJldHVybiAoKF9zdmcgPSBzdmcpID09IG51bGwgPyB2b2lkIDAgOiBfc3ZnLmhhc0NoaWxkTm9kZXMoKSkgJiYgc3ZnO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bWJvbFJlID0gLzxzeW1ib2woW15dKj9pZD0oWydcIl0pKC4rPylcXDJbXl0qPzxcXC8pc3ltYm9sPi9nO1xuICAgIGNvbnN0IHN5bWJvbHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3ltYm9scyhzdmcsIGljb24pIHtcbiAgICAgIGlmICghc3ltYm9sc1tzdmddKSB7XG4gICAgICAgIHN5bWJvbHNbc3ZnXSA9IHt9O1xuXG4gICAgICAgIHN5bWJvbFJlLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBzeW1ib2xSZS5leGVjKHN2ZykpIHtcbiAgICAgICAgICBzeW1ib2xzW3N2Z11bbWF0Y2hbM11dID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJHttYXRjaFsxXX1zdmc+YDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ltYm9sc1tzdmddW2ljb25dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uKGVsKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBnZXRNYXhQYXRoTGVuZ3RoKGVsKTtcblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS11ay1hbmltYXRpb24tc3Ryb2tlJywgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXhQYXRoTGVuZ3RoKGVsKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgLi4uJCQoJ1tzdHJva2VdJywgZWwpLm1hcCgoc3Ryb2tlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHN0cm9rZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydFNWRyhlbCwgcm9vdCkge1xuICAgICAgaWYgKGlzVm9pZEVsZW1lbnQocm9vdCkgfHwgaXNUYWcocm9vdCwgJ2NhbnZhcycpKSB7XG4gICAgICAgIHJvb3QuaGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBuZXh0ID0gcm9vdC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIHJldHVybiBlcXVhbHMoZWwsIG5leHQpID8gbmV4dCA6IGFmdGVyKHJvb3QsIGVsKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFzdCA9IHJvb3QubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHJldHVybiBlcXVhbHMoZWwsIGxhc3QpID8gbGFzdCA6IGFwcGVuZChyb290LCBlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWxzKGVsLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAnc3ZnJykgJiYgaXNUYWcob3RoZXIsICdzdmcnKSAmJiBlbC5pbm5lckhUTUwgPT09IG90aGVyLmlubmVySFRNTDtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VJY29uID0gXCI8c3ZnIHdpZHRoPVxcXCIxNFxcXCIgaGVpZ2h0PVxcXCIxNFxcXCIgdmlld0JveD1cXFwiMCAwIDE0IDE0XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHgxPVxcXCIxXFxcIiB5MT1cXFwiMVxcXCIgeDI9XFxcIjEzXFxcIiB5Mj1cXFwiMTNcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMTNcXFwiIHkxPVxcXCIxXFxcIiB4Mj1cXFwiMVxcXCIgeTI9XFxcIjEzXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgY2xvc2VMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiB4MT1cXFwiMVxcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxOVxcXCIgeTI9XFxcIjE5XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgeDE9XFxcIjE5XFxcIiB5MT1cXFwiMVxcXCIgeDI9XFxcIjFcXFwiIHkyPVxcXCIxOVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG1hcmtlciA9IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCI5XFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIxMVxcXCIvPjxyZWN0IHg9XFxcIjRcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIxMVxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgbmF2UGFyZW50SWNvbiA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIxMlxcXCIgaGVpZ2h0PVxcXCIxMlxcXCIgdmlld0JveD1cXFwiMCAwIDEyIDEyXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgcG9pbnRzPVxcXCIxIDMuNSA2IDguNSAxMSAzLjVcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBuYXZQYXJlbnRJY29uTGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjE0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTQgMTRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHBvaW50cz1cXFwiMSA0IDcgMTAgMTMgNFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdmJhclBhcmVudEljb24gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMTJcXFwiIHZpZXdCb3g9XFxcIjAgMCAxMiAxMlxcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHBvaW50cz1cXFwiMSAzLjUgNiA4LjUgMTEgMy41XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgbmF2YmFyVG9nZ2xlSWNvbiA9IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48c3R5bGU+LnVrLW5hdmJhci10b2dnbGUtYW5pbWF0ZSBzdmc+W2NsYXNzKj1saW5lLV17dHJhbnNpdGlvbjouMnMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm0sb3BhY2l0eTt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlcjtvcGFjaXR5OjF9LnVrLW5hdmJhci10b2dnbGUgc3ZnPi5saW5lLTN7b3BhY2l0eTowfS51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD10cnVlXSBzdmc+LmxpbmUtM3tvcGFjaXR5OjF9LnVrLW5hdmJhci10b2dnbGUtYW5pbWF0ZVthcmlhLWV4cGFuZGVkPXRydWVdIHN2Zz4ubGluZS0ye3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD10cnVlXSBzdmc+LmxpbmUtM3t0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9LnVrLW5hdmJhci10b2dnbGUtYW5pbWF0ZVthcmlhLWV4cGFuZGVkPXRydWVdIHN2Zz4ubGluZS0xLC51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD10cnVlXSBzdmc+LmxpbmUtNHtvcGFjaXR5OjB9LnVrLW5hdmJhci10b2dnbGUtYW5pbWF0ZVthcmlhLWV4cGFuZGVkPXRydWVdIHN2Zz4ubGluZS0xe3RyYW5zZm9ybTp0cmFuc2xhdGVZKDZweCkgc2NhbGVYKDApfS51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD10cnVlXSBzdmc+LmxpbmUtNHt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNnB4KSBzY2FsZVgoMCl9PC9zdHlsZT48cmVjdCBjbGFzcz1cXFwibGluZS0xXFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IGNsYXNzPVxcXCJsaW5lLTJcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgY2xhc3M9XFxcImxpbmUtM1xcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCBjbGFzcz1cXFwibGluZS00XFxcIiB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBvdmVybGF5SWNvbiA9IFwiPHN2ZyB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCA0MCA0MFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIxOVxcXCIgeT1cXFwiMFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiNDBcXFwiLz48cmVjdCB4PVxcXCIwXFxcIiB5PVxcXCIxOVxcXCIgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBwYWdpbmF0aW9uTmV4dCA9IFwiPHN2ZyB3aWR0aD1cXFwiN1xcXCIgaGVpZ2h0PVxcXCIxMlxcXCIgdmlld0JveD1cXFwiMCAwIDcgMTJcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIHBvaW50cz1cXFwiMSAxIDYgNiAxIDExXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgcGFnaW5hdGlvblByZXZpb3VzID0gXCI8c3ZnIHdpZHRoPVxcXCI3XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgNyAxMlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgcG9pbnRzPVxcXCI2IDEgMSA2IDYgMTFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzZWFyY2hJY29uID0gXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjlcXFwiIGN5PVxcXCI5XFxcIiByPVxcXCI3XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE0LDE0IEwxOCwxOCBMMTQsMTQgWlxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNlYXJjaExhcmdlID0gXCI8c3ZnIHdpZHRoPVxcXCI0MFxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIgdmlld0JveD1cXFwiMCAwIDQwIDQwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuOFxcXCIgY3g9XFxcIjE3LjVcXFwiIGN5PVxcXCIxNy41XFxcIiByPVxcXCIxNi41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuOFxcXCIgeDE9XFxcIjM4XFxcIiB5MT1cXFwiMzlcXFwiIHgyPVxcXCIyOVxcXCIgeTI9XFxcIjMwXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2VhcmNoTmF2YmFyID0gXCI8c3ZnIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwLjVcXFwiIGN5PVxcXCIxMC41XFxcIiByPVxcXCI5LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMjNcXFwiIHkxPVxcXCIyM1xcXCIgeDI9XFxcIjE3XFxcIiB5Mj1cXFwiMTdcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzbGlkZW5hdk5leHQgPSBcIjxzdmcgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTQgMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHBvaW50cz1cXFwiMS4yMjUsMjMgMTIuNzc1LDEyIDEuMjI1LDEgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2xpZGVuYXZOZXh0TGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjI1XFxcIiBoZWlnaHQ9XFxcIjQwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjUgNDBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBwb2ludHM9XFxcIjQuMDAyLDM4LjU0NyAyMi41MjcsMjAuMDI0IDQsMS41IFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2UHJldmlvdXMgPSBcIjxzdmcgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTQgMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHBvaW50cz1cXFwiMTIuNzc1LDEgMS4yMjUsMTIgMTIuNzc1LDIzIFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2UHJldmlvdXNMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiMjVcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNSA0MFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIHBvaW50cz1cXFwiMjAuNTI3LDEuNSAyLDIwLjAyNCAyMC41MjUsMzguNTQ3IFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNwaW5uZXIgPSBcIjxzdmcgd2lkdGg9XFxcIjMwXFxcIiBoZWlnaHQ9XFxcIjMwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzAgMzBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxNVxcXCIgY3k9XFxcIjE1XFxcIiByPVxcXCIxNFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHRvdG9wID0gXCI8c3ZnIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxMFxcXCIgdmlld0JveD1cXFwiMCAwIDE4IDEwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBwb2ludHM9XFxcIjEgOSA5IDEgMTcgOSBcXFwiLz48L3N2Zz5cIjtcblxuICAgIGNvbnN0IGljb25zID0ge1xuICAgICAgc3Bpbm5lcixcbiAgICAgIHRvdG9wLFxuICAgICAgbWFya2VyLFxuICAgICAgJ2Nsb3NlLWljb24nOiBjbG9zZUljb24sXG4gICAgICAnY2xvc2UtbGFyZ2UnOiBjbG9zZUxhcmdlLFxuICAgICAgJ25hdi1wYXJlbnQtaWNvbic6IG5hdlBhcmVudEljb24sXG4gICAgICAnbmF2LXBhcmVudC1pY29uLWxhcmdlJzogbmF2UGFyZW50SWNvbkxhcmdlLFxuICAgICAgJ25hdmJhci1wYXJlbnQtaWNvbic6IG5hdmJhclBhcmVudEljb24sXG4gICAgICAnbmF2YmFyLXRvZ2dsZS1pY29uJzogbmF2YmFyVG9nZ2xlSWNvbixcbiAgICAgICdvdmVybGF5LWljb24nOiBvdmVybGF5SWNvbixcbiAgICAgICdwYWdpbmF0aW9uLW5leHQnOiBwYWdpbmF0aW9uTmV4dCxcbiAgICAgICdwYWdpbmF0aW9uLXByZXZpb3VzJzogcGFnaW5hdGlvblByZXZpb3VzLFxuICAgICAgJ3NlYXJjaC1pY29uJzogc2VhcmNoSWNvbixcbiAgICAgICdzZWFyY2gtbGFyZ2UnOiBzZWFyY2hMYXJnZSxcbiAgICAgICdzZWFyY2gtbmF2YmFyJzogc2VhcmNoTmF2YmFyLFxuICAgICAgJ3NsaWRlbmF2LW5leHQnOiBzbGlkZW5hdk5leHQsXG4gICAgICAnc2xpZGVuYXYtbmV4dC1sYXJnZSc6IHNsaWRlbmF2TmV4dExhcmdlLFxuICAgICAgJ3NsaWRlbmF2LXByZXZpb3VzJzogc2xpZGVuYXZQcmV2aW91cyxcbiAgICAgICdzbGlkZW5hdi1wcmV2aW91cy1sYXJnZSc6IHNsaWRlbmF2UHJldmlvdXNMYXJnZVxuICAgIH07XG5cbiAgICBjb25zdCBJY29uID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCQzLFxuXG4gICAgICBleHRlbmRzOiBTVkcsXG5cbiAgICAgIGFyZ3M6ICdpY29uJyxcblxuICAgICAgcHJvcHM6IFsnaWNvbiddLFxuXG4gICAgICBkYXRhOiB7IGluY2x1ZGU6IFtdIH0sXG5cbiAgICAgIGlzSWNvbjogdHJ1ZSxcblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1pY29uJyk7XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGdldFN2ZygpIHtcbiAgICAgICAgICBjb25zdCBpY29uID0gZ2V0SWNvbih0aGlzLmljb24pO1xuXG4gICAgICAgICAgaWYgKCFpY29uKSB7XG4gICAgICAgICAgICB0aHJvdyAnSWNvbiBub3QgZm91bmQuJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBJY29uQ29tcG9uZW50ID0ge1xuICAgICAgYXJnczogZmFsc2UsXG5cbiAgICAgIGV4dGVuZHM6IEljb24sXG5cbiAgICAgIGRhdGE6ICh2bSkgPT4gKHtcbiAgICAgICAgaWNvbjogaHlwaGVuYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMubmFtZSlcbiAgICAgIH0pLFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy4kb3B0aW9ucy5pZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IE5hdlBhcmVudEljb24gPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBjb25zdCBpY29uID0gdGhpcy4kcHJvcHMuaWNvbjtcbiAgICAgICAgdGhpcy5pY29uID0gY2xvc2VzdCh0aGlzLiRlbCwgJy51ay1uYXYtcHJpbWFyeScpID8gYCR7aWNvbn0tbGFyZ2VgIDogaWNvbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgU2xpZGVuYXYgPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLXNsaWRlbmF2Jyk7XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLiRwcm9wcy5pY29uO1xuICAgICAgICB0aGlzLmljb24gPSBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLXNsaWRlbmF2LWxhcmdlJykgPyBgJHtpY29ufS1sYXJnZWAgOiBpY29uO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBTZWFyY2ggPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmljb24gPVxuICAgICAgICBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLXNlYXJjaC1pY29uJykgJiYgcGFyZW50cyh0aGlzLiRlbCwgJy51ay1zZWFyY2gtbGFyZ2UnKS5sZW5ndGggP1xuICAgICAgICAnc2VhcmNoLWxhcmdlJyA6XG4gICAgICAgIHBhcmVudHModGhpcy4kZWwsICcudWstc2VhcmNoLW5hdmJhcicpLmxlbmd0aCA/XG4gICAgICAgICdzZWFyY2gtbmF2YmFyJyA6XG4gICAgICAgIHRoaXMuJHByb3BzLmljb247XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IENsb3NlID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5pY29uID0gYGNsb3NlLSR7aGFzQ2xhc3ModGhpcy4kZWwsICd1ay1jbG9zZS1sYXJnZScpID8gJ2xhcmdlJyA6ICdpY29uJ31gO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBTcGlubmVyID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBnZXRTdmcoKSB7XG4gICAgICAgICAgY29uc3QgaWNvbiA9IGF3YWl0IEljb24ubWV0aG9kcy5nZXRTdmcuY2FsbCh0aGlzKTtcblxuICAgICAgICAgIGlmICh0aGlzLnJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICBjc3MoJCgnY2lyY2xlJywgaWNvbiksICdzdHJva2VXaWR0aCcsIDEgLyB0aGlzLnJhdGlvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgICBmdW5jdGlvbiBpbnN0YWxsJDMoVUlraXQpIHtcbiAgICAgIFVJa2l0Lmljb24uYWRkID0gKG5hbWUsIHN2ZykgPT4ge1xuICAgICAgICBjb25zdCBhZGRlZCA9IGlzU3RyaW5nKG5hbWUpID8geyBbbmFtZV06IHN2ZyB9IDogbmFtZTtcbiAgICAgICAgZWFjaChhZGRlZCwgKHN2ZywgbmFtZSkgPT4ge1xuICAgICAgICAgIGljb25zW25hbWVdID0gc3ZnO1xuICAgICAgICAgIGRlbGV0ZSBwYXJzZWRbbmFtZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChVSWtpdC5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBhcHBseShkb2N1bWVudC5ib2R5LCAoZWwpID0+IGVhY2goVUlraXQuZ2V0Q29tcG9uZW50cyhlbCksIChjbXApID0+IHtcbiAgICAgICAgICAgIGNtcC4kb3B0aW9ucy5pc0ljb24gJiYgY21wLmljb24gaW4gYWRkZWQgJiYgY21wLiRyZXNldCgpO1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEljb24oaWNvbikge1xuICAgICAgaWYgKCFpY29uc1tpY29uXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJzZWRbaWNvbl0pIHtcbiAgICAgICAgcGFyc2VkW2ljb25dID0gJCgoaWNvbnNbYXBwbHlSdGwoaWNvbildIHx8IGljb25zW2ljb25dKS50cmltKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkW2ljb25dLmNsb25lTm9kZSh0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVJ0bChpY29uKSB7XG4gICAgICByZXR1cm4gaXNSdGwgPyBzd2FwKHN3YXAoaWNvbiwgJ2xlZnQnLCAncmlnaHQnKSwgJ3ByZXZpb3VzJywgJ25leHQnKSA6IGljb247XG4gICAgfVxuXG4gICAgY29uc3QgbmF0aXZlTGF6eUxvYWQgPSBpbkJyb3dzZXIgJiYgJ2xvYWRpbmcnIGluIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgdmFyIGltZyA9IHtcbiAgICAgIGFyZ3M6ICdkYXRhU3JjJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGF0YVNyYzogU3RyaW5nLFxuICAgICAgICBzb3VyY2VzOiBTdHJpbmcsXG4gICAgICAgIG1hcmdpbjogU3RyaW5nLFxuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgbG9hZGluZzogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRhdGFTcmM6ICcnLFxuICAgICAgICBzb3VyY2VzOiBmYWxzZSxcbiAgICAgICAgbWFyZ2luOiAnNTAlJyxcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgbG9hZGluZzogJ2xhenknXG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmcgIT09ICdsYXp5Jykge1xuICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IFt0aGlzLiRlbCwgLi4ucXVlcnlBbGwodGhpcy4kcHJvcHMudGFyZ2V0LCB0aGlzLiRlbCldO1xuXG4gICAgICAgIGlmIChuYXRpdmVMYXp5TG9hZCAmJiBpc0ltZyh0aGlzLiRlbCkpIHtcbiAgICAgICAgICB0aGlzLiRlbC5sb2FkaW5nID0gJ2xhenknO1xuICAgICAgICAgIHNldFNyY0F0dHJzKHRoaXMuJGVsKTtcblxuICAgICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZW5zdXJlU3JjQXR0cmlidXRlKHRoaXMuJGVsKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9LFxuICAgICAgICB7IHJvb3RNYXJnaW46IHRoaXMubWFyZ2luIH0pKTtcblxuXG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmltYWdlKSB7XG4gICAgICAgICAgdGhpcy5fZGF0YS5pbWFnZS5vbmxvYWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBsb2FkKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pbWFnZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpbWFnZSA9IGlzSW1nKHRoaXMuJGVsKSA/XG4gICAgICAgICAgdGhpcy4kZWwgOlxuICAgICAgICAgIGdldEltYWdlRnJvbUVsZW1lbnQodGhpcy4kZWwsIHRoaXMuZGF0YVNyYywgdGhpcy5zb3VyY2VzKTtcblxuICAgICAgICAgIHJlbW92ZUF0dHIoaW1hZ2UsICdsb2FkaW5nJyk7XG4gICAgICAgICAgc2V0U3JjQXR0cnModGhpcy4kZWwsIGltYWdlLmN1cnJlbnRTcmMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2V0U3JjQXR0cnMoZWwsIHNyYykge1xuICAgICAgaWYgKGlzSW1nKGVsKSkge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcGFyZW50KGVsKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBpc1BpY3R1cmUocGFyZW50Tm9kZSkgPyBjaGlsZHJlbihwYXJlbnROb2RlKSA6IFtlbF07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiBzZXRTb3VyY2VQcm9wcyhlbCwgZWwpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9ICFpbmNsdWRlcyhlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UsIHNyYyk7XG4gICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICBjc3MoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnLCBgdXJsKCR7ZXNjYXBlKHNyYyl9KWApO1xuICAgICAgICAgIHRyaWdnZXIoZWwsIGNyZWF0ZUV2ZW50KCdsb2FkJywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNyY1Byb3BzID0gWydkYXRhLXNyYycsICdkYXRhLXNyY3NldCcsICdzaXplcyddO1xuICAgIGZ1bmN0aW9uIHNldFNvdXJjZVByb3BzKHNvdXJjZUVsLCB0YXJnZXRFbCkge1xuICAgICAgc3JjUHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGEoc291cmNlRWwsIHByb3ApO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBhdHRyKHRhcmdldEVsLCBwcm9wLnJlcGxhY2UoL14oZGF0YS0pKy8sICcnKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbWFnZUZyb21FbGVtZW50KGVsLCBzcmMsIHNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICB3cmFwSW5QaWN0dXJlKGltZywgc291cmNlcyk7XG4gICAgICBzZXRTb3VyY2VQcm9wcyhlbCwgaW1nKTtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHNldFNyY0F0dHJzKGVsLCBpbWcuY3VycmVudFNyYyk7XG4gICAgICB9O1xuICAgICAgYXR0cihpbWcsICdzcmMnLCBzcmMpO1xuICAgICAgcmV0dXJuIGltZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwSW5QaWN0dXJlKGltZywgc291cmNlcykge1xuICAgICAgc291cmNlcyA9IHBhcnNlU291cmNlcyhzb3VyY2VzKTtcblxuICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBpY3R1cmUgPSBmcmFnbWVudCgnPHBpY3R1cmU+Jyk7XG4gICAgICAgIGZvciAoY29uc3QgYXR0cnMgb2Ygc291cmNlcykge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGZyYWdtZW50KCc8c291cmNlPicpO1xuICAgICAgICAgIGF0dHIoc291cmNlLCBhdHRycyk7XG4gICAgICAgICAgYXBwZW5kKHBpY3R1cmUsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKHBpY3R1cmUsIGltZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTb3VyY2VzKHNvdXJjZXMpIHtcbiAgICAgIGlmICghc291cmNlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydHNXaXRoKHNvdXJjZXMsICdbJykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzb3VyY2VzID0gSlNPTi5wYXJzZShzb3VyY2VzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlcyA9IHBhcnNlT3B0aW9ucyhzb3VyY2VzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FycmF5KHNvdXJjZXMpKSB7XG4gICAgICAgIHNvdXJjZXMgPSBbc291cmNlc107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VyY2VzLmZpbHRlcigoc291cmNlKSA9PiAhaXNFbXB0eShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbnN1cmVTcmNBdHRyaWJ1dGUoZWwpIHtcbiAgICAgIGlmIChpc0ltZyhlbCkgJiYgIWhhc0F0dHIoZWwsICdzcmMnKSkge1xuICAgICAgICBhdHRyKGVsLCAnc3JjJywgJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjwvc3ZnPicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUGljdHVyZShlbCkge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAncGljdHVyZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1nKGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsICdpbWcnKTtcbiAgICB9XG5cbiAgICB2YXIgTWVkaWEgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBtZWRpYTogQm9vbGVhblxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBtZWRpYTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0b01lZGlhKHRoaXMubWVkaWEsIHRoaXMuJGVsKTtcbiAgICAgICAgdGhpcy5tYXRjaE1lZGlhID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYU9iaiA9IHdpbmRvdy5tYXRjaE1lZGlhKG1lZGlhKTtcbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXRjaE1lZGlhID0gdGhpcy5tZWRpYU9iai5tYXRjaGVzO1xuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgY3JlYXRlRXZlbnQoJ21lZGlhY2hhbmdlJywgZmFsc2UsIHRydWUsIFt0aGlzLm1lZGlhT2JqXSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5vZmZNZWRpYU9iaiA9IG9uKHRoaXMubWVkaWFPYmosICdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdyZXNpemUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHt2YXIgX3RoaXMkb2ZmTWVkaWFPYmo7XG4gICAgICAgIChfdGhpcyRvZmZNZWRpYU9iaiA9IHRoaXMub2ZmTWVkaWFPYmopID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvZmZNZWRpYU9iai5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b01lZGlhKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmIChzdGFydHNXaXRoKHZhbHVlLCAnQCcpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b0Zsb2F0KGNzcyhlbGVtZW50LCBgLS11ay1icmVha3BvaW50LSR7dmFsdWUuc3Vic3RyKDEpfWApKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlICYmIGlzTnVtZXJpYyh2YWx1ZSkgPyBgKG1pbi13aWR0aDogJHt2YWx1ZX1weClgIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIGxlYWRlciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBNZWRpYSwgUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZmlsbDogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZpbGw6ICcnLFxuICAgICAgICBjbHNXcmFwcGVyOiAndWstbGVhZGVyLWZpbGwnLFxuICAgICAgICBjbHNIaWRlOiAndWstbGVhZGVyLWhpZGUnLFxuICAgICAgICBhdHRyRmlsbDogJ2RhdGEtZmlsbCdcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGZpbGwoeyBmaWxsIH0pIHtcbiAgICAgICAgICByZXR1cm4gZmlsbCB8fCBjc3ModGhpcy4kZWwsICctLXVrLWxlYWRlci1maWxsLWNvbnRlbnQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBbdGhpcy53cmFwcGVyXSA9IHdyYXBJbm5lcih0aGlzLiRlbCwgYDxzcGFuIGNsYXNzPVwiJHt0aGlzLmNsc1dyYXBwZXJ9XCI+YCk7XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHVud3JhcCh0aGlzLndyYXBwZXIuY2hpbGROb2Rlcyk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgudHJ1bmModGhpcy4kZWwub2Zmc2V0V2lkdGggLyAyKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgIGhpZGU6ICF0aGlzLm1hdGNoTWVkaWFcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKHsgd2lkdGgsIGZpbGwsIGhpZGUgfSkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMud3JhcHBlciwgdGhpcy5jbHNIaWRlLCBoaWRlKTtcbiAgICAgICAgICBhdHRyKHRoaXMud3JhcHBlciwgdGhpcy5hdHRyRmlsbCwgbmV3IEFycmF5KHdpZHRoKS5qb2luKGZpbGwpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ11cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1vZGFsID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCQyLFxuXG4gICAgICBtaXhpbnM6IFtNb2RhbF0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2xzUGFnZTogJ3VrLW1vZGFsLXBhZ2UnLFxuICAgICAgICBzZWxQYW5lbDogJy51ay1tb2RhbC1kaWFsb2cnLFxuICAgICAgICBzZWxDbG9zZTpcbiAgICAgICAgJy51ay1tb2RhbC1jbG9zZSwgLnVrLW1vZGFsLWNsb3NlLWRlZmF1bHQsIC51ay1tb2RhbC1jbG9zZS1vdXRzaWRlLCAudWstbW9kYWwtY2xvc2UtZnVsbCdcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChoYXNDbGFzcyh0aGlzLnBhbmVsLCAndWstbWFyZ2luLWF1dG8tdmVydGljYWwnKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1mbGV4Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoZWlnaHQodGhpcy4kZWwpOyAvLyBmb3JjZSByZWZsb3dcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZGVuJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgJ3VrLWZsZXgnKTtcbiAgICAgICAgfVxuICAgICAgfV1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsJDIoeyBtb2RhbCB9KSB7XG4gICAgICBtb2RhbC5kaWFsb2cgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkaWFsb2cgPSBtb2RhbChcbiAgICAgICAgYDxkaXYgY2xhc3M9XCJ1ay1tb2RhbFwiPiA8ZGl2IGNsYXNzPVwidWstbW9kYWwtZGlhbG9nXCI+JHtjb250ZW50fTwvZGl2PiA8L2Rpdj5gLFxuICAgICAgICBvcHRpb25zKTtcblxuXG4gICAgICAgIGRpYWxvZy5zaG93KCk7XG5cbiAgICAgICAgb24oXG4gICAgICAgIGRpYWxvZy4kZWwsXG4gICAgICAgICdoaWRkZW4nLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgZGlhbG9nLiRkZXN0cm95KHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cblxuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgICAgfTtcblxuICAgICAgbW9kYWwuYWxlcnQgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3BlbkRpYWxvZyhcbiAgICAgICAgKHsgbGFiZWxzIH0pID0+IGA8ZGl2IGNsYXNzPVwidWstbW9kYWwtYm9keVwiPiR7XG4gICAgaXNTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogaHRtbChtZXNzYWdlKVxuICAgIH08L2Rpdj4gPGRpdiBjbGFzcz1cInVrLW1vZGFsLWZvb3RlciB1ay10ZXh0LXJpZ2h0XCI+IDxidXR0b24gY2xhc3M9XCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnkgdWstbW9kYWwtY2xvc2VcIiBhdXRvZm9jdXM+JHtcbiAgICBsYWJlbHMub2tcbiAgICB9PC9idXR0b24+IDwvZGl2PmAsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChkZWZlcnJlZCkgPT4gZGVmZXJyZWQucmVzb2x2ZSgpKTtcblxuICAgICAgfTtcblxuICAgICAgbW9kYWwuY29uZmlybSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcGVuRGlhbG9nKFxuICAgICAgICAoeyBsYWJlbHMgfSkgPT4gYDxmb3JtPiA8ZGl2IGNsYXNzPVwidWstbW9kYWwtYm9keVwiPiR7aXNTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogaHRtbChtZXNzYWdlKX08L2Rpdj4gPGRpdiBjbGFzcz1cInVrLW1vZGFsLWZvb3RlciB1ay10ZXh0LXJpZ2h0XCI+IDxidXR0b24gY2xhc3M9XCJ1ay1idXR0b24gdWstYnV0dG9uLWRlZmF1bHQgdWstbW9kYWwtY2xvc2VcIiB0eXBlPVwiYnV0dG9uXCI+JHtcbiAgICBsYWJlbHMuY2FuY2VsXG4gICAgfTwvYnV0dG9uPiA8YnV0dG9uIGNsYXNzPVwidWstYnV0dG9uIHVrLWJ1dHRvbi1wcmltYXJ5XCIgYXV0b2ZvY3VzPiR7bGFiZWxzLm9rfTwvYnV0dG9uPiA8L2Rpdj4gPC9mb3JtPmAsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChkZWZlcnJlZCkgPT4gZGVmZXJyZWQucmVqZWN0KCkpO1xuXG4gICAgICB9O1xuXG4gICAgICBtb2RhbC5wcm9tcHQgPSBmdW5jdGlvbiAobWVzc2FnZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5EaWFsb2coXG4gICAgICAgICh7IGxhYmVscyB9KSA9PiBgPGZvcm0gY2xhc3M9XCJ1ay1mb3JtLXN0YWNrZWRcIj4gPGRpdiBjbGFzcz1cInVrLW1vZGFsLWJvZHlcIj4gPGxhYmVsPiR7aXNTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogaHRtbChtZXNzYWdlKX08L2xhYmVsPiA8aW5wdXQgY2xhc3M9XCJ1ay1pbnB1dFwiIHZhbHVlPVwiJHt2YWx1ZSB8fCAnJ31cIiBhdXRvZm9jdXM+IDwvZGl2PiA8ZGl2IGNsYXNzPVwidWstbW9kYWwtZm9vdGVyIHVrLXRleHQtcmlnaHRcIj4gPGJ1dHRvbiBjbGFzcz1cInVrLWJ1dHRvbiB1ay1idXR0b24tZGVmYXVsdCB1ay1tb2RhbC1jbG9zZVwiIHR5cGU9XCJidXR0b25cIj4ke1xuICAgIGxhYmVscy5jYW5jZWxcbiAgICB9PC9idXR0b24+IDxidXR0b24gY2xhc3M9XCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnlcIj4ke2xhYmVscy5va308L2J1dHRvbj4gPC9kaXY+IDwvZm9ybT5gLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAoZGVmZXJyZWQpID0+IGRlZmVycmVkLnJlc29sdmUobnVsbCksXG4gICAgICAgIChkaWFsb2cpID0+ICQoJ2lucHV0JywgZGlhbG9nLiRlbCkudmFsdWUpO1xuXG4gICAgICB9O1xuXG4gICAgICBtb2RhbC5sYWJlbHMgPSB7XG4gICAgICAgIG9rOiAnT2snLFxuICAgICAgICBjYW5jZWw6ICdDYW5jZWwnXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBvcGVuRGlhbG9nKHRtcGwsIG9wdGlvbnMsIGhpZGVGbiwgc3VibWl0Rm4pIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgYmdDbG9zZTogZmFsc2UsIGVzY0Nsb3NlOiB0cnVlLCBsYWJlbHM6IG1vZGFsLmxhYmVscywgLi4ub3B0aW9ucyB9O1xuXG4gICAgICAgIGNvbnN0IGRpYWxvZyA9IG1vZGFsLmRpYWxvZyh0bXBsKG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgICBvbihkaWFsb2cuJGVsLCAnc3VibWl0JywgJ2Zvcm0nLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHN1Ym1pdEZuID09IG51bGwgPyB2b2lkIDAgOiBzdWJtaXRGbihkaWFsb2cpKTtcbiAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgZGlhbG9nLmhpZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb24oZGlhbG9nLiRlbCwgJ2hpZGUnLCAoKSA9PiAhcmVzb2x2ZWQgJiYgaGlkZUZuKGRlZmVycmVkKSk7XG5cbiAgICAgICAgZGVmZXJyZWQucHJvbWlzZS5kaWFsb2cgPSBkaWFsb2c7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5hdiA9IHtcbiAgICAgIGV4dGVuZHM6IEFjY29yZGlvbixcblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXRzOiAnPiAudWstcGFyZW50JyxcbiAgICAgICAgdG9nZ2xlOiAnPiBhJyxcbiAgICAgICAgY29udGVudDogJz4gdWwnXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBuYXZiYXIgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgQ29udGFpbmVyXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZHJvcGRvd246IFN0cmluZyxcbiAgICAgICAgYWxpZ246IFN0cmluZyxcbiAgICAgICAgY2xzRHJvcDogU3RyaW5nLFxuICAgICAgICBib3VuZGFyeTogQm9vbGVhbixcbiAgICAgICAgZHJvcGJhcjogQm9vbGVhbixcbiAgICAgICAgZHJvcGJhckFuY2hvcjogQm9vbGVhbixcbiAgICAgICAgZHVyYXRpb246IE51bWJlcixcbiAgICAgICAgbW9kZTogQm9vbGVhbixcbiAgICAgICAgb2Zmc2V0OiBCb29sZWFuLFxuICAgICAgICBzdHJldGNoOiBCb29sZWFuLFxuICAgICAgICBkZWxheVNob3c6IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5SGlkZTogQm9vbGVhbixcbiAgICAgICAgdGFyZ2V0OiBCb29sZWFuLFxuICAgICAgICB0YXJnZXRYOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXRZOiBCb29sZWFuLFxuICAgICAgICBhbmltYXRpb246IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGVPdXQ6IEJvb2xlYW5cbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZHJvcGRvd246ICcudWstbmF2YmFyLW5hdiA+IGxpID4gYSwgLnVrLW5hdmJhci1pdGVtLCAudWstbmF2YmFyLXRvZ2dsZScsXG4gICAgICAgIGFsaWduOiBpc1J0bCA/ICdyaWdodCcgOiAnbGVmdCcsXG4gICAgICAgIGNsc0Ryb3A6ICd1ay1uYXZiYXItZHJvcGRvd24nLFxuICAgICAgICBib3VuZGFyeTogdHJ1ZSxcbiAgICAgICAgZHJvcGJhcjogZmFsc2UsXG4gICAgICAgIGRyb3BiYXJBbmNob3I6IGZhbHNlLFxuICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBkcm9wYmFyQW5jaG9yKHsgZHJvcGJhckFuY2hvciB9LCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnkoZHJvcGJhckFuY2hvciwgJGVsKSB8fCAkZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJvcGJhcjoge1xuICAgICAgICAgIGdldCh7IGRyb3BiYXIgfSkge1xuICAgICAgICAgICAgaWYgKCFkcm9wYmFyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkcm9wYmFyID1cbiAgICAgICAgICAgIHRoaXMuX2Ryb3BiYXIgfHxcbiAgICAgICAgICAgIHF1ZXJ5KGRyb3BiYXIsIHRoaXMuJGVsKSB8fFxuICAgICAgICAgICAgJCgnKyAudWstbmF2YmFyLWRyb3BiYXInLCB0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBkcm9wYmFyID8gZHJvcGJhciA6IHRoaXMuX2Ryb3BiYXIgPSAkKCc8ZGl2PjwvZGl2PicpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChkcm9wYmFyKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhkcm9wYmFyLCAndWstZHJvcGJhcicsICd1ay1kcm9wYmFyLXRvcCcsICd1ay1uYXZiYXItZHJvcGJhcicpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBkcm9wQ29udGFpbmVyKF8sICRlbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lciB8fCAkZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJvcGRvd25zOiB7XG4gICAgICAgICAgZ2V0KHsgY2xzRHJvcCB9LCAkZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyb3Bkb3ducyA9ICQkKGAuJHtjbHNEcm9wfWAsICRlbCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRyb3BDb250YWluZXIgIT09ICRlbCkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mICQkKGAuJHtjbHNEcm9wfWAsIHRoaXMuZHJvcENvbnRhaW5lcikpIHt2YXIgX3RoaXMkZ2V0RHJvcGRvd247XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKF90aGlzJGdldERyb3Bkb3duID0gdGhpcy5nZXREcm9wZG93bihlbCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRnZXREcm9wZG93bi50YXJnZXRFbDtcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVzKGRyb3Bkb3ducywgZWwpICYmIHRhcmdldCAmJiB3aXRoaW4odGFyZ2V0LCB0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgICAgICAgIGRyb3Bkb3ducy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRyb3Bkb3ducztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZHJvcGRvd25zKSB7XG4gICAgICAgICAgICB0aGlzLiRjcmVhdGUoXG4gICAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgICBkcm9wZG93bnMuZmlsdGVyKChlbCkgPT4gIXRoaXMuZ2V0RHJvcGRvd24oZWwpKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4udGhpcy4kcHJvcHMsXG4gICAgICAgICAgICAgIGZsaXA6IGZhbHNlLFxuICAgICAgICAgICAgICBzaGlmdDogdHJ1ZSxcbiAgICAgICAgICAgICAgcG9zOiBgYm90dG9tLSR7dGhpcy5hbGlnbn1gLFxuICAgICAgICAgICAgICBib3VuZGFyeTogdGhpcy5ib3VuZGFyeSA9PT0gdHJ1ZSA/IHRoaXMuJGVsIDogdGhpcy5ib3VuZGFyeVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlczoge1xuICAgICAgICAgIGdldCh7IGRyb3Bkb3duIH0sICRlbCkge1xuICAgICAgICAgICAgcmV0dXJuICQkKGRyb3Bkb3duLCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGp1c3RpZnkgPSBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLW5hdmJhci1qdXN0aWZ5Jyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiAkJChcbiAgICAgICAgICAgICcudWstbmF2YmFyLW5hdiwgLnVrLW5hdmJhci1sZWZ0LCAudWstbmF2YmFyLXJpZ2h0JyxcbiAgICAgICAgICAgIHRoaXMuJGVsKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY3NzKGNvbnRhaW5lciwgJ2ZsZXhHcm93JywganVzdGlmeSA/ICQkKHRoaXMuZHJvcGRvd24sIGNvbnRhaW5lcikubGVuZ3RoIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmRyb3BiYXIgJiYgcmVtb3ZlJDEodGhpcy5kcm9wYmFyKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Ryb3BiYXI7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21vdXNlb3ZlciBmb2N1c2luJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKHsgY3VycmVudCB9KSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgYWN0aXZlICYmXG4gICAgICAgICAgaW5jbHVkZXMoYWN0aXZlLm1vZGUsICdob3ZlcicpICYmXG4gICAgICAgICAgYWN0aXZlLnRhcmdldEVsICYmXG4gICAgICAgICAgIXdpdGhpbihhY3RpdmUudGFyZ2V0RWwsIGN1cnJlbnQpICYmXG4gICAgICAgICAgIWFjdGl2ZS5pc0RlbGF5aW5nKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjdGl2ZS5oaWRlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2tleWRvd24nLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSB9ID0gZTtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5ET1dOICYmIGhhc0F0dHIoY3VycmVudCwgJ2FyaWEtZXhwYW5kZWQnKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZSB8fCBhY3RpdmUudGFyZ2V0RWwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5jbGljaygpO1xuICAgICAgICAgICAgICBvbmNlKHRoaXMuZHJvcENvbnRhaW5lciwgJ3Nob3cnLCAoeyB0YXJnZXQgfSkgPT4gZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQodGFyZ2V0KSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50KGFjdGl2ZS4kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZU5hdkl0ZW1OYXZpZ2F0aW9uKGUsIHRoaXMudG9nZ2xlcywgYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAna2V5ZG93bicsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gYC4ke3RoaXMuY2xzRHJvcH1gO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSB9ID0gZTtcblxuICAgICAgICAgIGlmICghaW5jbHVkZXModGhpcy5kcm9wZG93bnMsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICAgICAgICBjb25zdCBlbGVtZW50cyA9ICQkKHNlbEZvY3VzYWJsZSwgY3VycmVudCk7XG4gICAgICAgICAgY29uc3QgaSA9IGZpbmRJbmRleChlbGVtZW50cywgKGVsKSA9PiBtYXRjaGVzKGVsLCAnOmZvY3VzJykpO1xuXG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5VUCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzW2kgLSAxXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRE9XTikge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGkgPCBlbGVtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzW2kgKyAxXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRVNDKSB7dmFyIF9hY3RpdmUkdGFyZ2V0RWw7XG4gICAgICAgICAgICAoX2FjdGl2ZSR0YXJnZXRFbCA9IGFjdGl2ZS50YXJnZXRFbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hY3RpdmUkdGFyZ2V0RWwuZm9jdXMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVOYXZJdGVtTmF2aWdhdGlvbihlLCB0aGlzLnRvZ2dsZXMsIGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21vdXNlbGVhdmUnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdGl2ZSAmJlxuICAgICAgICAgIGluY2x1ZGVzKGFjdGl2ZS5tb2RlLCAnaG92ZXInKSAmJlxuICAgICAgICAgICF0aGlzLmRyb3Bkb3ducy5zb21lKChlbCkgPT4gbWF0Y2hlcyhlbCwgJzpob3ZlcicpKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY3RpdmUuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3Jlc2hvdycsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKHsgdGFyZ2V0IH0pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNEcm9wYmFyRHJvcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZHJvcGJhci5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICE9PSB0aGlzLmRyb3BiYXJBbmNob3IpIHtcbiAgICAgICAgICAgIGFmdGVyKHRoaXMuZHJvcGJhckFuY2hvciwgdGhpcy5kcm9wYmFyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRDbGFzcyh0YXJnZXQsIGAke3RoaXMuY2xzRHJvcH0tZHJvcGJhcmApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoeyB0YXJnZXQgfSkge1xuICAgICAgICAgIGlmICghdGhpcy5pc0Ryb3BiYXJEcm9wKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkcm9wID0gdGhpcy5nZXREcm9wZG93bih0YXJnZXQpO1xuICAgICAgICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZVJlc2l6ZShbZHJvcC4kZWwsIC4uLmRyb3AudGFyZ2V0XSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0cyA9IHBhcmVudHModGFyZ2V0LCBgLiR7dGhpcy5jbHNEcm9wfWApLlxuICAgICAgICAgICAgY29uY2F0KHRhcmdldCkuXG4gICAgICAgICAgICBtYXAoKGVsKSA9PiBvZmZzZXQoZWwpKTtcbiAgICAgICAgICAgIGNvbnN0IG1pblRvcCA9IE1hdGgubWluKC4uLnRhcmdldE9mZnNldHMubWFwKCh7IHRvcCB9KSA9PiB0b3ApKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJvdHRvbSA9IE1hdGgubWF4KC4uLnRhcmdldE9mZnNldHMubWFwKCh7IGJvdHRvbSB9KSA9PiBib3R0b20pKTtcbiAgICAgICAgICAgIGNvbnN0IGRyb3BiYXJPZmZzZXQgPSBvZmZzZXQodGhpcy5kcm9wYmFyKTtcbiAgICAgICAgICAgIGNzcyh0aGlzLmRyb3BiYXIsICd0b3AnLCB0aGlzLmRyb3BiYXIub2Zmc2V0VG9wIC0gKGRyb3BiYXJPZmZzZXQudG9wIC0gbWluVG9wKSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcbiAgICAgICAgICAgIG1heEJvdHRvbSAtIG1pblRvcCArIHRvRmxvYXQoY3NzKHRhcmdldCwgJ21hcmdpbkJvdHRvbScpKSxcbiAgICAgICAgICAgIHRhcmdldCk7XG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3JlaGlkZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIG1hdGNoZXModGhpcy5kcm9wYmFyLCAnOmhvdmVyJykgJiZcbiAgICAgICAgICBhY3RpdmUuJGVsID09PSBlLnRhcmdldCAmJlxuICAgICAgICAgICF0aGlzLnRvZ2dsZXMuc29tZSgoZWwpID0+IGFjdGl2ZS50YXJnZXRFbCAhPT0gZWwgJiYgbWF0Y2hlcyhlbCwgJzpmb2N1cycpKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoeyB0YXJnZXQgfSkge3ZhciBfdGhpcyRfb2JzZXJ2ZXI7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzRHJvcGJhckRyb3AodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIChfdGhpcyRfb2JzZXJ2ZXIgPSB0aGlzLl9vYnNlcnZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJF9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKCFhY3RpdmUgfHwgYWN0aXZlLiRlbCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbygwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1dLFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0QWN0aXZlKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLmRyb3Bkb3ducywgYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuJGVsKSAmJiBhY3RpdmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvblRvKG5ld0hlaWdodCwgZWwpIHtcbiAgICAgICAgICBjb25zdCB7IGRyb3BiYXIgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gaGVpZ2h0KGRyb3BiYXIpO1xuXG4gICAgICAgICAgZWwgPSBvbGRIZWlnaHQgPCBuZXdIZWlnaHQgJiYgZWw7XG5cbiAgICAgICAgICBjc3MoZWwsICdjbGlwUGF0aCcsIGBwb2x5Z29uKDAgMCwxMDAlIDAsMTAwJSAke29sZEhlaWdodH1weCwwICR7b2xkSGVpZ2h0fXB4KWApO1xuXG4gICAgICAgICAgaGVpZ2h0KGRyb3BiYXIsIG9sZEhlaWdodCk7XG5cbiAgICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbChbZWwsIGRyb3BiYXJdKTtcbiAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChkcm9wYmFyLCB7IGhlaWdodDogbmV3SGVpZ2h0IH0sIHRoaXMuZHVyYXRpb24pLFxuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xpcFBhdGg6IGBwb2x5Z29uKDAgMCwxMDAlIDAsMTAwJSAke25ld0hlaWdodH1weCwwICR7bmV3SGVpZ2h0fXB4KWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMuZHVyYXRpb24pXSkuXG5cblxuICAgICAgICAgIGNhdGNoKG5vb3ApLlxuICAgICAgICAgIHRoZW4oKCkgPT4gY3NzKGVsLCB7IGNsaXBQYXRoOiAnJyB9KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RHJvcGRvd24oZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kZ2V0Q29tcG9uZW50KGVsLCAnZHJvcCcpIHx8IHRoaXMuJGdldENvbXBvbmVudChlbCwgJ2Ryb3Bkb3duJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNEcm9wYmFyRHJvcChlbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldERyb3Bkb3duKGVsKSAmJiBoYXNDbGFzcyhlbCwgdGhpcy5jbHNEcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVOYXZJdGVtTmF2aWdhdGlvbihlLCB0b2dnbGVzLCBhY3RpdmUpIHtcbiAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSB9ID0gZTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGFjdGl2ZS50YXJnZXRFbCB8fCBjdXJyZW50O1xuICAgICAgY29uc3QgaSA9IHRvZ2dsZXMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgICAvLyBMZWZ0XG4gICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkxFRlQgJiYgaSA+IDApIHtcbiAgICAgICAgYWN0aXZlLmhpZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5oaWRlKGZhbHNlKTtcbiAgICAgICAgdG9nZ2xlc1tpIC0gMV0uZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmlnaHRcbiAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuUklHSFQgJiYgaSA8IHRvZ2dsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBhY3RpdmUuaGlkZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmhpZGUoZmFsc2UpO1xuICAgICAgICB0b2dnbGVzW2kgKyAxXS5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLlRBQikge1xuICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgYWN0aXZlLmhpZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5oaWRlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudChlbCkge1xuICAgICAgaWYgKCEkKCc6Zm9jdXMnLCBlbCkpIHt2YXIgXyQ7XG4gICAgICAgIChfJCA9ICQoc2VsRm9jdXNhYmxlLCBlbCkpID09IG51bGwgPyB2b2lkIDAgOiBfJC5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGtleU1hcCA9IHtcbiAgICAgIFRBQjogOSxcbiAgICAgIEVTQzogMjcsXG4gICAgICBMRUZUOiAzNyxcbiAgICAgIFVQOiAzOCxcbiAgICAgIFJJR0hUOiAzOSxcbiAgICAgIERPV046IDQwXG4gICAgfTtcblxuICAgIHZhciBTd2lwZSA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHN3aXBpbmc6IEJvb2xlYW5cbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc3dpcGluZzogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc3dpcGVUYXJnZXQocHJvcHMsICRlbCkge1xuICAgICAgICAgIHJldHVybiAkZWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN3aXBpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckV2ZW50KHRoaXMsIHtcbiAgICAgICAgICBlbDogdGhpcy5zd2lwZVRhcmdldCxcbiAgICAgICAgICBuYW1lOiBwb2ludGVyRG93biQxLFxuICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgU3dpcGUgR2VzdHVyZVxuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXZlbnRQb3MoZSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAndGFnTmFtZScgaW4gZS50YXJnZXQgPyBlLnRhcmdldCA6IHBhcmVudChlLnRhcmdldCk7XG4gICAgICAgICAgICBvbmNlKGRvY3VtZW50LCBgJHtwb2ludGVyVXAkMX0gJHtwb2ludGVyQ2FuY2VsfSBzY3JvbGxgLCAoZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zKGUpO1xuXG4gICAgICAgICAgICAgIC8vIHN3aXBlXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZS50eXBlICE9PSAnc2Nyb2xsJyAmJiB0YXJnZXQgJiYgeCAmJiBNYXRoLmFicyhwb3MueCAtIHgpID4gMTAwIHx8XG4gICAgICAgICAgICAgIHkgJiYgTWF0aC5hYnMocG9zLnkgLSB5KSA+IDEwMClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsICdzd2lwZScpO1xuICAgICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIGBzd2lwZSR7c3dpcGVEaXJlY3Rpb24ocG9zLngsIHBvcy55LCB4LCB5KX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc3dpcGVEaXJlY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA+PSBNYXRoLmFicyh5MSAtIHkyKSA/XG4gICAgICB4MSAtIHgyID4gMCA/XG4gICAgICAnTGVmdCcgOlxuICAgICAgJ1JpZ2h0JyA6XG4gICAgICB5MSAtIHkyID4gMCA/XG4gICAgICAnVXAnIDpcbiAgICAgICdEb3duJztcbiAgICB9XG5cbiAgICB2YXIgb2ZmY2FudmFzID0ge1xuICAgICAgbWl4aW5zOiBbTW9kYWwsIFN3aXBlXSxcblxuICAgICAgYXJnczogJ21vZGUnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtb2RlOiBTdHJpbmcsXG4gICAgICAgIGZsaXA6IEJvb2xlYW4sXG4gICAgICAgIG92ZXJsYXk6IEJvb2xlYW5cbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbW9kZTogJ3NsaWRlJyxcbiAgICAgICAgZmxpcDogZmFsc2UsXG4gICAgICAgIG92ZXJsYXk6IGZhbHNlLFxuICAgICAgICBjbHNQYWdlOiAndWstb2ZmY2FudmFzLXBhZ2UnLFxuICAgICAgICBjbHNDb250YWluZXI6ICd1ay1vZmZjYW52YXMtY29udGFpbmVyJyxcbiAgICAgICAgc2VsUGFuZWw6ICcudWstb2ZmY2FudmFzLWJhcicsXG4gICAgICAgIGNsc0ZsaXA6ICd1ay1vZmZjYW52YXMtZmxpcCcsXG4gICAgICAgIGNsc0NvbnRhaW5lckFuaW1hdGlvbjogJ3VrLW9mZmNhbnZhcy1jb250YWluZXItYW5pbWF0aW9uJyxcbiAgICAgICAgY2xzU2lkZWJhckFuaW1hdGlvbjogJ3VrLW9mZmNhbnZhcy1iYXItYW5pbWF0aW9uJyxcbiAgICAgICAgY2xzTW9kZTogJ3VrLW9mZmNhbnZhcycsXG4gICAgICAgIGNsc092ZXJsYXk6ICd1ay1vZmZjYW52YXMtb3ZlcmxheScsXG4gICAgICAgIHNlbENsb3NlOiAnLnVrLW9mZmNhbnZhcy1jbG9zZScsXG4gICAgICAgIGNvbnRhaW5lcjogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsc0ZsaXAoeyBmbGlwLCBjbHNGbGlwIH0pIHtcbiAgICAgICAgICByZXR1cm4gZmxpcCA/IGNsc0ZsaXAgOiAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBjbHNPdmVybGF5KHsgb3ZlcmxheSwgY2xzT3ZlcmxheSB9KSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJsYXkgPyBjbHNPdmVybGF5IDogJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xzTW9kZSh7IG1vZGUsIGNsc01vZGUgfSkge1xuICAgICAgICAgIHJldHVybiBgJHtjbHNNb2RlfS0ke21vZGV9YDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbHNTaWRlYmFyQW5pbWF0aW9uKHsgbW9kZSwgY2xzU2lkZWJhckFuaW1hdGlvbiB9KSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdub25lJyB8fCBtb2RlID09PSAncmV2ZWFsJyA/ICcnIDogY2xzU2lkZWJhckFuaW1hdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBjbHNDb250YWluZXJBbmltYXRpb24oeyBtb2RlLCBjbHNDb250YWluZXJBbmltYXRpb24gfSkge1xuICAgICAgICAgIHJldHVybiBtb2RlICE9PSAncHVzaCcgJiYgbW9kZSAhPT0gJ3JldmVhbCcgPyAnJyA6IGNsc0NvbnRhaW5lckFuaW1hdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudCh7IG1vZGUgfSkge1xuICAgICAgICAgIHJldHVybiBtb2RlID09PSAncmV2ZWFsJyA/IHBhcmVudCh0aGlzLnBhbmVsKSA6IHRoaXMucGFuZWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmICFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddXG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvdWNobW92ZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdyZXZlYWwnICYmICFoYXNDbGFzcyhwYXJlbnQodGhpcy5wYW5lbCksIHRoaXMuY2xzTW9kZSkpIHtcbiAgICAgICAgICAgIHdyYXBBbGwodGhpcy5wYW5lbCwgJzxkaXY+Jyk7XG4gICAgICAgICAgICBhZGRDbGFzcyhwYXJlbnQodGhpcy5wYW5lbCksIHRoaXMuY2xzTW9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBib2R5LCBzY3JvbGxpbmdFbGVtZW50IH0gPSBkb2N1bWVudDtcblxuICAgICAgICAgIGFkZENsYXNzKGJvZHksIHRoaXMuY2xzQ29udGFpbmVyLCB0aGlzLmNsc0ZsaXApO1xuICAgICAgICAgIGNzcyhib2R5LCAndG91Y2gtYWN0aW9uJywgJ3Bhbi15IHBpbmNoLXpvb20nKTtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgICAgY3NzKHRoaXMucGFuZWwsICdtYXhXaWR0aCcsIHNjcm9sbGluZ0VsZW1lbnQuY2xpZW50V2lkdGgpO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc092ZXJsYXkpO1xuICAgICAgICAgIGFkZENsYXNzKFxuICAgICAgICAgIHRoaXMucGFuZWwsXG4gICAgICAgICAgdGhpcy5jbHNTaWRlYmFyQW5pbWF0aW9uLFxuICAgICAgICAgIHRoaXMubW9kZSA9PT0gJ3JldmVhbCcgPyAnJyA6IHRoaXMuY2xzTW9kZSk7XG5cblxuICAgICAgICAgIGhlaWdodChib2R5KTsgLy8gZm9yY2UgcmVmbG93XG4gICAgICAgICAgYWRkQ2xhc3MoYm9keSwgdGhpcy5jbHNDb250YWluZXJBbmltYXRpb24pO1xuXG4gICAgICAgICAgdGhpcy5jbHNDb250YWluZXJBbmltYXRpb24gJiYgc3VwcHJlc3NVc2VyU2NhbGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY2xzQ29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3RvdWNoLWFjdGlvbicsICcnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZGVuJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5jbHNDb250YWluZXJBbmltYXRpb24gJiYgcmVzdW1lVXNlclNjYWxlKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSAncmV2ZWFsJykge1xuICAgICAgICAgICAgdW53cmFwKHRoaXMucGFuZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMucGFuZWwsIHRoaXMuY2xzU2lkZWJhckFuaW1hdGlvbiwgdGhpcy5jbHNNb2RlKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNPdmVybGF5KTtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsICdkaXNwbGF5JywgJycpO1xuICAgICAgICAgIGNzcyh0aGlzLnBhbmVsLCAnbWF4V2lkdGgnLCAnJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgdGhpcy5jbHNDb250YWluZXIsIHRoaXMuY2xzRmxpcCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3N3aXBlTGVmdCBzd2lwZVJpZ2h0JyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiBlbmRzV2l0aChlLnR5cGUsICdMZWZ0JykgXiB0aGlzLmZsaXApIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfV1cblxuICAgIH07XG5cbiAgICAvLyBDaHJvbWUgaW4gcmVzcG9uc2l2ZSBtb2RlIHpvb21zIHBhZ2UgdXBvbiBvcGVuaW5nIG9mZmNhbnZhc1xuICAgIGZ1bmN0aW9uIHN1cHByZXNzVXNlclNjYWxlKCkge1xuICAgICAgZ2V0Vmlld3BvcnQoKS5jb250ZW50ICs9ICcsdXNlci1zY2FsYWJsZT0wJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWVVc2VyU2NhbGUoKSB7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0KCk7XG4gICAgICB2aWV3cG9ydC5jb250ZW50ID0gdmlld3BvcnQuY29udGVudC5yZXBsYWNlKC8sdXNlci1zY2FsYWJsZT0wJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICQoJ21ldGFbbmFtZT1cInZpZXdwb3J0XCJdJywgZG9jdW1lbnQuaGVhZCkgfHwgYXBwZW5kKGRvY3VtZW50LmhlYWQsICc8bWV0YSBuYW1lPVwidmlld3BvcnRcIj4nKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgb3ZlcmZsb3dBdXRvID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFJlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNlbENvbnRhaW5lcjogU3RyaW5nLFxuICAgICAgICBzZWxDb250ZW50OiBTdHJpbmcsXG4gICAgICAgIG1pbkhlaWdodDogTnVtYmVyXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNlbENvbnRhaW5lcjogJy51ay1tb2RhbCcsXG4gICAgICAgIHNlbENvbnRlbnQ6ICcudWstbW9kYWwtZGlhbG9nJyxcbiAgICAgICAgbWluSGVpZ2h0OiAxNTBcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbnRhaW5lcih7IHNlbENvbnRhaW5lciB9LCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCgkZWwsIHNlbENvbnRhaW5lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGVudCh7IHNlbENvbnRlbnQgfSwgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3QoJGVsLCBzZWxDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmNvbnRhaW5lciwgdGhpcy5jb250ZW50XTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICghdGhpcy5jb250ZW50IHx8ICF0aGlzLmNvbnRhaW5lciB8fCAhaXNWaXNpYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXg6IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpcy5taW5IZWlnaHQsXG4gICAgICAgICAgICBoZWlnaHQodGhpcy5jb250YWluZXIpIC0gKGRpbWVuc2lvbnMkMSh0aGlzLmNvbnRlbnQpLmhlaWdodCAtIGhlaWdodCh0aGlzLiRlbCkpKVxuXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZSh7IG1heCB9KSB7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCB7IG1pbkhlaWdodDogdGhpcy5taW5IZWlnaHQsIG1heEhlaWdodDogbWF4IH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzcG9uc2l2ZSA9IHtcbiAgICAgIG1peGluczogW1Jlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiBbJ3dpZHRoJywgJ2hlaWdodCddLFxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCBwYXJlbnQodGhpcy4kZWwpXTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1yZXNwb25zaXZlLXdpZHRoJyk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4gaXNWaXNpYmxlKHRoaXMuJGVsKSAmJiB0aGlzLndpZHRoICYmIHRoaXMuaGVpZ2h0ID9cbiAgICAgICAgICB7IHdpZHRoOiB3aWR0aChwYXJlbnQodGhpcy4kZWwpKSwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9IDpcbiAgICAgICAgICBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShkaW0pIHtcbiAgICAgICAgICBoZWlnaHQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgRGltZW5zaW9ucy5jb250YWluKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGltKS5cbiAgICAgICAgICBoZWlnaHQpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzY3JvbGwgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBvZmZzZXQ6IE51bWJlclxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmVnaXN0ZXJDbGljayh0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdW5yZWdpc3RlckNsaWNrKHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBzY3JvbGxUbyhlbCkge1xuICAgICAgICAgIGVsID0gZWwgJiYgJChlbCkgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgICAgICAgIGlmICh0cmlnZ2VyKHRoaXMuJGVsLCAnYmVmb3Jlc2Nyb2xsJywgW3RoaXMsIGVsXSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNjcm9sbEludG9WaWV3KGVsLCB7IG9mZnNldDogdGhpcy5vZmZzZXQgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnc2Nyb2xsZWQnLCBbdGhpcywgZWxdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgY29tcG9uZW50cyQyID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQ2xpY2soY21wKSB7XG4gICAgICBpZiAoIWNvbXBvbmVudHMkMi5zaXplKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnY2xpY2snLCBjbGlja0hhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzJDIuYWRkKGNtcCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5yZWdpc3RlckNsaWNrKGNtcCkge1xuICAgICAgY29tcG9uZW50cyQyLmRlbGV0ZShjbXApO1xuXG4gICAgICBpZiAoIWNvbXBvbmVudHMkMi5zaXplKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2NsaWNrJywgY2xpY2tIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIGNvbXBvbmVudHMkMikge1xuICAgICAgICBpZiAod2l0aGluKGUudGFyZ2V0LCBjb21wb25lbnQuJGVsKSAmJiBpc1NhbWVTaXRlTGluayhjb21wb25lbnQuJGVsKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjb21wb25lbnQuc2Nyb2xsVG8oZ2V0VGFyZ2V0RWxlbWVudChjb21wb25lbnQuJGVsKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVTaXRlTGluayhlbCkge1xuICAgICAgcmV0dXJuIFsnb3JpZ2luJywgJ3BhdGhuYW1lJywgJ3NlYXJjaCddLmV2ZXJ5KChwYXJ0KSA9PiBsb2NhdGlvbltwYXJ0XSA9PT0gZWxbcGFydF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRhcmdldEVsZW1lbnQoZWwpIHtcbiAgICAgIGlmIChpc1NhbWVTaXRlTGluayhlbCkpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlY29kZVVSSUNvbXBvbmVudChlbC5oYXNoKS5zdWJzdHJpbmcoMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzY3JvbGxzcHkgPSB7XG4gICAgICBtaXhpbnM6IFtTY3JvbGxdLFxuXG4gICAgICBhcmdzOiAnY2xzJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xzOiBTdHJpbmcsXG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICBoaWRkZW46IEJvb2xlYW4sXG4gICAgICAgIG1hcmdpbjogU3RyaW5nLFxuICAgICAgICByZXBlYXQ6IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5OiBOdW1iZXJcbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6ICgpID0+ICh7XG4gICAgICAgIGNsczogJycsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgbWFyZ2luOiAnLTFweCcsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBpblZpZXdDbGFzczogJ3VrLXNjcm9sbHNweS1pbnZpZXcnXG4gICAgICB9KSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICBnZXQoeyB0YXJnZXQgfSwgJGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0ID8gJCQodGFyZ2V0LCAkZWwpIDogWyRlbF07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGVsZW1lbnRzLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgLy8gdXNlIGBvcGFjaXR5OjBgIGluc3RlYWQgb2YgYHZpc2liaWxpdHk6aGlkZGVuYCB0byBtYWtlIGNvbnRlbnQgZm9jdXNhYmxlIHdpdGgga2V5Ym9hcmRcbiAgICAgICAgICAgICAgY3NzKGZpbHRlciQxKGVsZW1lbnRzLCBgOm5vdCguJHt0aGlzLmluVmlld0NsYXNzfSlgKSwgJ29wYWNpdHknLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKGVsZW1lbnRzLCBwcmV2KSkge1xuICAgICAgICAgICAgICB0aGlzLiRyZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLl9kYXRhLmVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oXG4gICAgICAgIHRoaXMuZWxlbWVudHMsXG4gICAgICAgIChyZWNvcmRzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9kYXRhLmVsZW1lbnRzO1xuICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQ6IGVsLCBpc0ludGVyc2VjdGluZyB9IG9mIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHMuaGFzKGVsKSkge1xuICAgICAgICAgICAgICBlbGVtZW50cy5zZXQoZWwsIHtcbiAgICAgICAgICAgICAgICBjbHM6IGRhdGEoZWwsICd1ay1zY3JvbGxzcHktY2xhc3MnKSB8fCB0aGlzLmNsc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlbGVtZW50cy5nZXQoZWwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcGVhdCAmJiBzdGF0ZS5zaG93KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5zaG93ID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICB7IHJvb3RNYXJnaW46IHRoaXMubWFyZ2luIH0sXG4gICAgICAgIGZhbHNlKSk7XG5cblxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtlbCwgc3RhdGVdIG9mIHRoaXMuX2RhdGEuZWxlbWVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIHRoaXMuaW5WaWV3Q2xhc3MsIChzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuY2xzKSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZWwsIHN0YXRlXSBvZiBkYXRhLmVsZW1lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNob3cgJiYgIXN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnF1ZXVlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZGF0YS5wcm9taXNlID0gKGRhdGEucHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkuXG4gICAgICAgICAgICAgIHRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy5kZWxheSkpKS5cbiAgICAgICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGUoZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgc3RhdGUucXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5zaG93ICYmIHN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkICYmIHRoaXMucmVwZWF0KSB7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGVsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHRvZ2dsZShlbCwgaW52aWV3KSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9kYXRhLmVsZW1lbnRzLmdldChlbCk7XG5cbiAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdGUub2ZmID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5vZmYoKTtcblxuICAgICAgICAgIGNzcyhlbCwgJ29wYWNpdHknLCAhaW52aWV3ICYmIHRoaXMuaGlkZGVuID8gMCA6ICcnKTtcblxuICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmluVmlld0NsYXNzLCBpbnZpZXcpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzdGF0ZS5jbHMpO1xuXG4gICAgICAgICAgaWYgKC9cXGJ1ay1hbmltYXRpb24tLy50ZXN0KHN0YXRlLmNscykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUFuaW1hdGlvbkNsYXNzZXMgPSAoKSA9PiByZW1vdmVDbGFzc2VzKGVsLCAndWstYW5pbWF0aW9uLVtcXFxcdy1dKycpO1xuICAgICAgICAgICAgaWYgKGludmlldykge1xuICAgICAgICAgICAgICBzdGF0ZS5vZmYgPSBvbmNlKGVsLCAnYW5pbWF0aW9uY2FuY2VsIGFuaW1hdGlvbmVuZCcsIHJlbW92ZUFuaW1hdGlvbkNsYXNzZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQW5pbWF0aW9uQ2xhc3NlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXIoZWwsIGludmlldyA/ICdpbnZpZXcnIDogJ291dHZpZXcnKTtcblxuICAgICAgICAgIHN0YXRlLmludmlldyA9IGludmlldztcblxuICAgICAgICAgIC8vIGNoYW5nZSB0byBgdmlzaWJpbGl0eTogaGlkZGVuYCBkb2VzIG5vdCB0cmlnZ2VyIG9ic2VydmVyc1xuICAgICAgICAgIHRoaXMuJHVwZGF0ZShlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNjcm9sbHNweU5hdiA9IHtcbiAgICAgIG1peGluczogW1Njcm9sbF0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsczogU3RyaW5nLFxuICAgICAgICBjbG9zZXN0OiBTdHJpbmcsXG4gICAgICAgIHNjcm9sbDogQm9vbGVhbixcbiAgICAgICAgb3ZlcmZsb3c6IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldDogTnVtYmVyXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsczogJ3VrLWFjdGl2ZScsXG4gICAgICAgIGNsb3Nlc3Q6IGZhbHNlLFxuICAgICAgICBzY3JvbGw6IGZhbHNlLFxuICAgICAgICBvdmVyZmxvdzogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBsaW5rczoge1xuICAgICAgICAgIGdldChfLCAkZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkJCgnYVtocmVmKj1cIiNcIl0nLCAkZWwpLmZpbHRlcigoZWwpID0+IGVsLmhhc2ggJiYgaXNTYW1lU2l0ZUFuY2hvcihlbCkpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChsaW5rcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsKSB7XG4gICAgICAgICAgICAgIHRoaXMuJGNyZWF0ZSgnc2Nyb2xsJywgbGlua3MsIHsgb2Zmc2V0OiB0aGlzLm9mZnNldCB8fCAwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBlbGVtZW50cyh7IGNsb3Nlc3Q6IHNlbGVjdG9yIH0pIHtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCh0aGlzLmxpbmtzLCBzZWxlY3RvciB8fCAnKicpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IFtcbiAgICAgIHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRzID0gdGhpcy5saW5rcy5tYXAoZ2V0VGFyZ2V0RWxlbWVudCkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHRhcmdldHM7XG5cbiAgICAgICAgICBpZiAoIWxlbmd0aCB8fCAhaXNWaXNpYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IFtzY3JvbGxFbGVtZW50XSA9IHNjcm9sbFBhcmVudHModGFyZ2V0cywgL2F1dG98c2Nyb2xsLywgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCB9ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IG9mZnNldFZpZXdwb3J0KHNjcm9sbEVsZW1lbnQpO1xuICAgICAgICAgIGNvbnN0IG1heCA9IHNjcm9sbEhlaWdodCAtIHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgICBsZXQgYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSBtYXgpIHtcbiAgICAgICAgICAgIGFjdGl2ZSA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0KHRhcmdldHNbaV0pLnRvcCAtIHZpZXdwb3J0LnRvcCAtIHRoaXMub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFjdGl2ZSA9ICtpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWN0aXZlID09PSBmYWxzZSAmJiB0aGlzLm92ZXJmbG93KSB7XG4gICAgICAgICAgICAgIGFjdGl2ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgYWN0aXZlIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoeyBhY3RpdmUgfSkge1xuICAgICAgICAgIGNvbnN0IGNoYW5nZWQgPSBhY3RpdmUgIT09IGZhbHNlICYmICFoYXNDbGFzcyh0aGlzLmVsZW1lbnRzW2FjdGl2ZV0sIHRoaXMuY2xzKTtcblxuICAgICAgICAgIHRoaXMubGlua3MuZm9yRWFjaCgoZWwpID0+IGVsLmJsdXIoKSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLmVsZW1lbnRzW2ldLCB0aGlzLmNscywgK2kgPT09IGFjdGl2ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdhY3RpdmUnLCBbYWN0aXZlLCB0aGlzLmVsZW1lbnRzW2FjdGl2ZV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Njcm9sbCcsICdyZXNpemUnXVxuICAgICAgfV1cblxuICAgIH07XG5cbiAgICB2YXIgc3RpY2t5ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIE1lZGlhLCBSZXNpemUsIFNjcm9sbF0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIHRvcDogbnVsbCxcbiAgICAgICAgYm90dG9tOiBudWxsLFxuICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IFN0cmluZyxcbiAgICAgICAgb3ZlcmZsb3dGbGlwOiBCb29sZWFuLFxuICAgICAgICBhbmltYXRpb246IFN0cmluZyxcbiAgICAgICAgY2xzQWN0aXZlOiBTdHJpbmcsXG4gICAgICAgIGNsc0luYWN0aXZlOiBTdHJpbmcsXG4gICAgICAgIGNsc0ZpeGVkOiBTdHJpbmcsXG4gICAgICAgIGNsc0JlbG93OiBTdHJpbmcsXG4gICAgICAgIHNlbFRhcmdldDogU3RyaW5nLFxuICAgICAgICBzaG93T25VcDogQm9vbGVhbixcbiAgICAgICAgdGFyZ2V0T2Zmc2V0OiBOdW1iZXJcbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICBib3R0b206IGZhbHNlLFxuICAgICAgICBzdGFydDogZmFsc2UsXG4gICAgICAgIGVuZDogZmFsc2UsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgb3ZlcmZsb3dGbGlwOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiAnJyxcbiAgICAgICAgY2xzQWN0aXZlOiAndWstYWN0aXZlJyxcbiAgICAgICAgY2xzSW5hY3RpdmU6ICcnLFxuICAgICAgICBjbHNGaXhlZDogJ3VrLXN0aWNreS1maXhlZCcsXG4gICAgICAgIGNsc0JlbG93OiAndWstc3RpY2t5LWJlbG93JyxcbiAgICAgICAgc2VsVGFyZ2V0OiAnJyxcbiAgICAgICAgc2hvd09uVXA6IGZhbHNlLFxuICAgICAgICB0YXJnZXRPZmZzZXQ6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBzZWxUYXJnZXQoeyBzZWxUYXJnZXQgfSwgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbFRhcmdldCAmJiAkKHNlbFRhcmdldCwgJGVsKSB8fCAkZWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBjb2VyY2UodGhpcy5zdGFydCB8fCB0aGlzLnRvcCk7XG4gICAgICAgIHRoaXMuZW5kID0gY29lcmNlKHRoaXMuZW5kIHx8IHRoaXMuYm90dG9tKTtcblxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID1cbiAgICAgICAgJCgnKyAudWstc3RpY2t5LXBsYWNlaG9sZGVyJywgdGhpcy4kZWwpIHx8XG4gICAgICAgICQoJzxkaXYgY2xhc3M9XCJ1ay1zdGlja3ktcGxhY2Vob2xkZXJcIj48L2Rpdj4nKTtcbiAgICAgICAgdGhpcy5pc0ZpeGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIob2JzZXJ2ZVJlc2l6ZSh0aGlzLiRlbCwgKCkgPT4gIXRoaXMuaXNGaXhlZCAmJiB0aGlzLiRlbWl0KCdyZXNpemUnKSkpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5zZWxUYXJnZXQsIHRoaXMuY2xzSW5hY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0KHRoaXMuJGVsKTtcblxuICAgICAgICByZW1vdmUkMSh0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Jlc2l6ZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIFt3aW5kb3csIHdpbmRvdy52aXN1YWxWaWV3cG9ydF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdyZXNpemVWaWV3cG9ydCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnbG9hZCBoYXNoY2hhbmdlIHBvcHN0YXRlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRPZmZzZXQgIT09IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgY29uc3QgeyBzY3JvbGxpbmdFbGVtZW50IH0gPSBkb2N1bWVudDtcblxuICAgICAgICAgIGlmICghbG9jYXRpb24uaGFzaCB8fCBzY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KCQobG9jYXRpb24uaGFzaCkpO1xuICAgICAgICAgICAgY29uc3QgZWxPZmZzZXQgPSBvZmZzZXQodGhpcy4kZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpeGVkICYmIGludGVyc2VjdFJlY3QodGFyZ2V0T2Zmc2V0LCBlbE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgPVxuICAgICAgICAgICAgICB0YXJnZXRPZmZzZXQudG9wIC1cbiAgICAgICAgICAgICAgZWxPZmZzZXQuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgdG9QeCh0aGlzLnRhcmdldE9mZnNldCwgJ2hlaWdodCcsIHRoaXMucGxhY2Vob2xkZXIpIC1cbiAgICAgICAgICAgICAgdG9QeCh0aGlzLm9mZnNldCwgJ2hlaWdodCcsIHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XSxcblxuXG4gICAgICB1cGRhdGU6IFtcbiAgICAgIHtcbiAgICAgICAgcmVhZCh7IGhlaWdodDogaGVpZ2h0JDEsIHdpZHRoLCBtYXJnaW4sIHN0aWNreSB9LCB0eXBlcykge1xuICAgICAgICAgIHRoaXMuaW5hY3RpdmUgPSAhdGhpcy5tYXRjaE1lZGlhIHx8ICFpc1Zpc2libGUodGhpcy4kZWwpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaW5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoaWRlID0gdGhpcy5pc0ZpeGVkICYmIHR5cGVzLmhhcygncmVzaXplJykgJiYgIXN0aWNreTtcbiAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgY3NzKHRoaXMuc2VsVGFyZ2V0LCAndHJhbnNpdGlvbicsICcwcycpO1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgKHsgaGVpZ2h0OiBoZWlnaHQkMSwgd2lkdGggfSA9IG9mZnNldCh0aGlzLiRlbCkpO1xuICAgICAgICAgICAgbWFyZ2luID0gY3NzKHRoaXMuJGVsLCAnbWFyZ2luJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNzcyh0aGlzLnNlbFRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdG9QeCgnMTAwdmgnLCAnaGVpZ2h0Jyk7XG4gICAgICAgICAgY29uc3QgZHluYW1pY1ZpZXdwb3J0ID0gaGVpZ2h0KHdpbmRvdyk7XG4gICAgICAgICAgY29uc3QgbWF4U2Nyb2xsSGVpZ2h0ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQgLSB2aWV3cG9ydDtcblxuICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgaWYgKHRoaXMub3ZlcmZsb3dGbGlwICYmIGhlaWdodCQxID4gdmlld3BvcnQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5pc0ZpeGVkID8gdGhpcy5wbGFjZWhvbGRlciA6IHRoaXMuJGVsO1xuICAgICAgICAgIGxldCBvZmZzZXQkMSA9IHRvUHgodGhpcy5vZmZzZXQsICdoZWlnaHQnLCBzdGlja3kgPyB0aGlzLiRlbCA6IHJlZmVyZW5jZUVsZW1lbnQpO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgJiYgKGhlaWdodCQxIDwgZHluYW1pY1ZpZXdwb3J0IHx8IHRoaXMub3ZlcmZsb3dGbGlwKSkge1xuICAgICAgICAgICAgb2Zmc2V0JDEgKz0gZHluYW1pY1ZpZXdwb3J0IC0gaGVpZ2h0JDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSB0aGlzLm92ZXJmbG93RmxpcCA/IDAgOiBNYXRoLm1heCgwLCBoZWlnaHQkMSArIG9mZnNldCQxIC0gdmlld3BvcnQpO1xuICAgICAgICAgIGNvbnN0IHRvcE9mZnNldCA9IG9mZnNldChyZWZlcmVuY2VFbGVtZW50KS50b3A7XG4gICAgICAgICAgY29uc3QgZWxIZWlnaHQgPSBvZmZzZXQodGhpcy4kZWwpLmhlaWdodDtcblxuICAgICAgICAgIGNvbnN0IHN0YXJ0ID1cbiAgICAgICAgICAodGhpcy5zdGFydCA9PT0gZmFsc2UgP1xuICAgICAgICAgIHRvcE9mZnNldCA6XG4gICAgICAgICAgcGFyc2VQcm9wKHRoaXMuc3RhcnQsIHRoaXMuJGVsLCB0b3BPZmZzZXQpKSAtIG9mZnNldCQxO1xuICAgICAgICAgIGNvbnN0IGVuZCA9XG4gICAgICAgICAgdGhpcy5lbmQgPT09IGZhbHNlID9cbiAgICAgICAgICBtYXhTY3JvbGxIZWlnaHQgOlxuICAgICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIG1heFNjcm9sbEhlaWdodCxcbiAgICAgICAgICBwYXJzZVByb3AodGhpcy5lbmQsIHRoaXMuJGVsLCB0b3BPZmZzZXQgKyBoZWlnaHQkMSwgdHJ1ZSkgLVxuICAgICAgICAgIGVsSGVpZ2h0IC1cbiAgICAgICAgICBvZmZzZXQkMSArXG4gICAgICAgICAgb3ZlcmZsb3cpO1xuXG5cbiAgICAgICAgICBzdGlja3kgPVxuICAgICAgICAgIG1heFNjcm9sbEhlaWdodCAmJlxuICAgICAgICAgICF0aGlzLnNob3dPblVwICYmXG4gICAgICAgICAgc3RhcnQgKyBvZmZzZXQkMSA9PT0gdG9wT2Zmc2V0ICYmXG4gICAgICAgICAgZW5kID09PVxuICAgICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIG1heFNjcm9sbEhlaWdodCxcbiAgICAgICAgICBwYXJzZVByb3AoJyEqJywgdGhpcy4kZWwsIDAsIHRydWUpIC0gZWxIZWlnaHQgLSBvZmZzZXQkMSArIG92ZXJmbG93KTtcblxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQkMSxcbiAgICAgICAgICAgIG92ZXJmbG93LFxuICAgICAgICAgICAgdG9wT2Zmc2V0LFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQkMSxcbiAgICAgICAgICAgIGVsSGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICB0b3A6IG9mZnNldFBvc2l0aW9uKHJlZmVyZW5jZUVsZW1lbnQpWzBdLFxuICAgICAgICAgICAgc3RpY2t5XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZSh7IGhlaWdodCwgd2lkdGgsIG1hcmdpbiwgb2Zmc2V0LCBzdGlja3kgfSkge1xuICAgICAgICAgIGlmICh0aGlzLmluYWN0aXZlIHx8IHN0aWNreSB8fCAhdGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgICByZXNldCh0aGlzLiRlbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuaW5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RpY2t5KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCA9IG1hcmdpbiA9IDA7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgcG9zaXRpb246ICdzdGlja3knLCB0b3A6IG9mZnNldCB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IHBsYWNlaG9sZGVyIH0gPSB0aGlzO1xuXG4gICAgICAgICAgY3NzKHBsYWNlaG9sZGVyLCB7IGhlaWdodCwgd2lkdGgsIG1hcmdpbiB9KTtcblxuICAgICAgICAgIGlmICghd2l0aGluKHBsYWNlaG9sZGVyLCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIChzdGlja3kgPyBiZWZvcmUgOiBhZnRlcikodGhpcy4kZWwsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJywgJ3Jlc2l6ZVZpZXdwb3J0J11cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgcmVhZCh7XG4gICAgICAgICAgc2Nyb2xsOiBwcmV2U2Nyb2xsID0gMCxcbiAgICAgICAgICBkaXI6IHByZXZEaXIgPSAnZG93bicsXG4gICAgICAgICAgb3ZlcmZsb3csXG4gICAgICAgICAgb3ZlcmZsb3dTY3JvbGwgPSAwLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZFxuICAgICAgICB9KSB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgY29uc3QgZGlyID0gcHJldlNjcm9sbCA8PSBzY3JvbGwgPyAnZG93bicgOiAndXAnO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgIHByZXZEaXIsXG4gICAgICAgICAgICBzY3JvbGwsXG4gICAgICAgICAgICBwcmV2U2Nyb2xsLFxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50VG9wOiBvZmZzZXQoXG4gICAgICAgICAgICAodGhpcy5pc0ZpeGVkID8gdGhpcy5wbGFjZWhvbGRlciA6IHRoaXMuJGVsKS5vZmZzZXRQYXJlbnQpLlxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgb3ZlcmZsb3dTY3JvbGw6IGNsYW1wKFxuICAgICAgICAgICAgb3ZlcmZsb3dTY3JvbGwgKyBjbGFtcChzY3JvbGwsIHN0YXJ0LCBlbmQpIC0gY2xhbXAocHJldlNjcm9sbCwgc3RhcnQsIGVuZCksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3ZlcmZsb3cpXG5cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKGRhdGEsIHR5cGVzKSB7XG4gICAgICAgICAgY29uc3QgaXNTY3JvbGxVcGRhdGUgPSB0eXBlcy5oYXMoJ3Njcm9sbCcpO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGluaXRUaW1lc3RhbXAgPSAwLFxuICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgcHJldkRpcixcbiAgICAgICAgICAgIHNjcm9sbCxcbiAgICAgICAgICAgIHByZXZTY3JvbGwgPSAwLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICB0b3BPZmZzZXQsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICB9ID0gZGF0YTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBzY3JvbGwgPCAwIHx8XG4gICAgICAgICAgc2Nyb2xsID09PSBwcmV2U2Nyb2xsICYmIGlzU2Nyb2xsVXBkYXRlIHx8XG4gICAgICAgICAgdGhpcy5zaG93T25VcCAmJiAhaXNTY3JvbGxVcGRhdGUgJiYgIXRoaXMuaXNGaXhlZClcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBpZiAobm93IC0gaW5pdFRpbWVzdGFtcCA+IDMwMCB8fCBkaXIgIT09IHByZXZEaXIpIHtcbiAgICAgICAgICAgIGRhdGEuaW5pdFNjcm9sbCA9IHNjcm9sbDtcbiAgICAgICAgICAgIGRhdGEuaW5pdFRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5zaG93T25VcCAmJlxuICAgICAgICAgICF0aGlzLmlzRml4ZWQgJiZcbiAgICAgICAgICBNYXRoLmFicyhkYXRhLmluaXRTY3JvbGwgLSBzY3JvbGwpIDw9IDMwICYmXG4gICAgICAgICAgTWF0aC5hYnMocHJldlNjcm9sbCAtIHNjcm9sbCkgPD0gMTApXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmluYWN0aXZlIHx8XG4gICAgICAgICAgc2Nyb2xsIDwgc3RhcnQgfHxcbiAgICAgICAgICB0aGlzLnNob3dPblVwICYmIChcbiAgICAgICAgICBzY3JvbGwgPD0gc3RhcnQgfHxcbiAgICAgICAgICBkaXIgPT09ICdkb3duJyAmJiBpc1Njcm9sbFVwZGF0ZSB8fFxuICAgICAgICAgIGRpciA9PT0gJ3VwJyAmJiAhdGhpcy5pc0ZpeGVkICYmIHNjcm9sbCA8PSB0b3BPZmZzZXQgKyBoZWlnaHQpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgICAgIGlmIChBbmltYXRpb24uaW5Qcm9ncmVzcyh0aGlzLiRlbCkgJiYgdG9wID4gc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbiAmJiBzY3JvbGwgPiB0b3BPZmZzZXQpIHtcbiAgICAgICAgICAgICAgQW5pbWF0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgICAgICAgIEFuaW1hdGlvbi5vdXQodGhpcy4kZWwsIHRoaXMuYW5pbWF0aW9uKS50aGVuKCgpID0+IHRoaXMuaGlkZSgpLCBub29wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hbmltYXRpb24gJiYgc2Nyb2xsID4gdG9wT2Zmc2V0KSB7XG4gICAgICAgICAgICBBbmltYXRpb24uY2FuY2VsKHRoaXMuJGVsKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgQW5pbWF0aW9uLmluKHRoaXMuJGVsLCB0aGlzLmFuaW1hdGlvbikuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJywgJ3Jlc2l6ZVZpZXdwb3J0JywgJ3Njcm9sbCddXG4gICAgICB9XSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgdGhpcy5pc0ZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICBjb25zdCB7IG9mZnNldCwgc3RpY2t5IH0gPSB0aGlzLl9kYXRhO1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNGaXhlZCwgdGhpcy5jbHNCZWxvdyk7XG4gICAgICAgICAgaWYgKHN0aWNreSkge1xuICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCAndG9wJywgb2Zmc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3A6ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaXNGaXhlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBzY3JvbGwgPSAwLFxuICAgICAgICAgICAgb3ZlcmZsb3csXG4gICAgICAgICAgICBvdmVyZmxvd1Njcm9sbCA9IDAsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIHRvcE9mZnNldCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGVsSGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50VG9wLFxuICAgICAgICAgICAgc3RpY2t5XG4gICAgICAgICAgfSA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gc3RhcnQgIT09IDAgfHwgc2Nyb2xsID4gc3RhcnQ7XG5cbiAgICAgICAgICBpZiAoIXN0aWNreSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgICAgICAgICAgaWYgKHNjcm9sbCA+IGVuZCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZW5kIC0gb2Zmc2V0UGFyZW50VG9wO1xuICAgICAgICAgICAgICBwb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBwb3NpdGlvbiwgd2lkdGggfSk7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsICdtYXJnaW5Ub3AnLCAwLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gb3ZlcmZsb3dTY3JvbGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAndG9wJywgb2Zmc2V0KTtcblxuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKGFjdGl2ZSk7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgdGhpcy5jbHNCZWxvdyxcbiAgICAgICAgICBzY3JvbGwgPiB0b3BPZmZzZXQgKyAoc3RpY2t5ID8gTWF0aC5taW4oaGVpZ2h0LCBlbEhlaWdodCkgOiBoZWlnaHQpKTtcblxuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0ZpeGVkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRBY3RpdmUoYWN0aXZlKSB7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuYWN0aXZlO1xuICAgICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIHJlcGxhY2VDbGFzcyh0aGlzLnNlbFRhcmdldCwgdGhpcy5jbHNJbmFjdGl2ZSwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICAgICAgcHJldiAhPT0gYWN0aXZlICYmIHRyaWdnZXIodGhpcy4kZWwsICdhY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZUNsYXNzKHRoaXMuc2VsVGFyZ2V0LCB0aGlzLmNsc0FjdGl2ZSwgdGhpcy5jbHNJbmFjdGl2ZSk7XG4gICAgICAgICAgICBwcmV2ICE9PSBhY3RpdmUgJiYgdHJpZ2dlcih0aGlzLiRlbCwgJ2luYWN0aXZlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcCh2YWx1ZSwgZWwsIHByb3BPZmZzZXQsIHBhZGRpbmcpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bWVyaWModmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5tYXRjaCgvXi0/XFxkLykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BPZmZzZXQgKyB0b1B4KHZhbHVlLCAnaGVpZ2h0JywgZWwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVmRWxlbWVudCA9IHZhbHVlID09PSB0cnVlID8gcGFyZW50KGVsKSA6IHF1ZXJ5KHZhbHVlLCBlbCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgb2Zmc2V0KHJlZkVsZW1lbnQpLmJvdHRvbSAtIChcbiAgICAgICAgICBwYWRkaW5nICYmIHJlZkVsZW1lbnQgJiYgd2l0aGluKGVsLCByZWZFbGVtZW50KSA/XG4gICAgICAgICAgdG9GbG9hdChjc3MocmVmRWxlbWVudCwgJ3BhZGRpbmdCb3R0b20nKSkgOlxuICAgICAgICAgIDApKTtcblxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvZXJjZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldChlbCkge1xuICAgICAgY3NzKGVsLCB7IHBvc2l0aW9uOiAnJywgdG9wOiAnJywgbWFyZ2luVG9wOiAnJywgd2lkdGg6ICcnIH0pO1xuICAgIH1cblxuICAgIHZhciBTd2l0Y2hlciA9IHtcbiAgICAgIG1peGluczogW0xhenlsb2FkLCBTd2lwZSwgVG9nZ2xhYmxlXSxcblxuICAgICAgYXJnczogJ2Nvbm5lY3QnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjb25uZWN0OiBTdHJpbmcsXG4gICAgICAgIHRvZ2dsZTogU3RyaW5nLFxuICAgICAgICBpdGVtTmF2OiBTdHJpbmcsXG4gICAgICAgIGFjdGl2ZTogTnVtYmVyXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbm5lY3Q6ICd+LnVrLXN3aXRjaGVyJyxcbiAgICAgICAgdG9nZ2xlOiAnPiAqID4gOmZpcnN0LWNoaWxkJyxcbiAgICAgICAgaXRlbU5hdjogZmFsc2UsXG4gICAgICAgIGFjdGl2ZTogMCxcbiAgICAgICAgY2xzOiAndWstYWN0aXZlJyxcbiAgICAgICAgYXR0ckl0ZW06ICd1ay1zd2l0Y2hlci1pdGVtJ1xuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29ubmVjdHM6IHtcbiAgICAgICAgICBnZXQoeyBjb25uZWN0IH0sICRlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5QWxsKGNvbm5lY3QsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGNvbm5lY3RzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zd2lwaW5nKSB7XG4gICAgICAgICAgICAgIGNzcyhjb25uZWN0cywgJ3RvdWNoQWN0aW9uJywgJ3Bhbi15IHBpbmNoLXpvb20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZG9jdW1lbnQ6IHRydWUsXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgY29ubmVjdENoaWxkcmVuOiB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdHMubWFwKChlbCkgPT4gY2hpbGRyZW4oZWwpKS5mbGF0KCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuY29ubmVjdHMpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW4oZWwpLmZvckVhY2goKGNoaWxkLCBpKSA9PiB0b2dnbGVDbGFzcyhjaGlsZCwgdGhpcy5jbHMsIGkgPT09IGluZGV4KSk7XG4gICAgICAgICAgICAgIHRoaXMubGF6eWxvYWQodGhpcy4kZWwsIGNoaWxkcmVuKGVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgICBnZXQoeyB0b2dnbGUgfSwgJGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQodG9nZ2xlLCAkZWwpLmZpbHRlcihcbiAgICAgICAgICAgIChlbCkgPT4gIW1hdGNoZXMoZWwsICcudWstZGlzYWJsZWQgKiwgLnVrLWRpc2FibGVkLCBbZGlzYWJsZWRdJykpO1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKHRvZ2dsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdyh+YWN0aXZlID8gYWN0aXZlIDogdG9nZ2xlc1t0aGlzLmFjdGl2ZV0gfHwgdG9nZ2xlc1swXSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbih0aGlzLiRlbCkuZmlsdGVyKChjaGlsZCkgPT4gdGhpcy50b2dnbGVzLnNvbWUoKHRvZ2dsZSkgPT4gd2l0aGluKHRvZ2dsZSwgY2hpbGQpKSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzd2lwZVRhcmdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0cztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3coZS5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RzLmNvbmNhdCh0aGlzLml0ZW1OYXYgPyBxdWVyeUFsbCh0aGlzLml0ZW1OYXYsIHRoaXMuJGVsKSA6IFtdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gYFske3RoaXMuYXR0ckl0ZW19XSxbZGF0YS0ke3RoaXMuYXR0ckl0ZW19XWA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvdyhkYXRhKGUuY3VycmVudCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzd2lwZVJpZ2h0IHN3aXBlTGVmdCcsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN3aXBpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcih7IHR5cGUgfSkge1xuICAgICAgICAgIHRoaXMuc2hvdyhlbmRzV2l0aCh0eXBlLCAnTGVmdCcpID8gJ25leHQnIDogJ3ByZXZpb3VzJyk7XG4gICAgICAgIH1cbiAgICAgIH1dLFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaW5kZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRJbmRleCh0aGlzLmNoaWxkcmVuLCAoZWwpID0+IGhhc0NsYXNzKGVsLCB0aGlzLmNscykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3coaXRlbSkge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLmluZGV4KCk7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IGdldEluZGV4KGl0ZW0sIHRoaXMudG9nZ2xlcywgcHJldik7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gZ2V0SW5kZXgodGhpcy5jaGlsZHJlbltuZXh0XSwgY2hpbGRyZW4odGhpcy4kZWwpKTtcbiAgICAgICAgICBjaGlsZHJlbih0aGlzLiRlbCkuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGNoaWxkLCB0aGlzLmNscywgYWN0aXZlID09PSBpKTtcbiAgICAgICAgICAgIGF0dHIodGhpcy50b2dnbGVzW2ldLCAnYXJpYS1leHBhbmRlZCcsIGFjdGl2ZSA9PT0gaSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBhbmltYXRlID0gcHJldiA+PSAwICYmIHByZXYgIT09IG5leHQ7XG4gICAgICAgICAgdGhpcy5jb25uZWN0cy5mb3JFYWNoKGFzeW5jICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudChcbiAgICAgICAgICAgIHRvTm9kZXMoY2hpbGRyZW4pLmZpbHRlcigoY2hpbGQpID0+IGhhc0NsYXNzKGNoaWxkLCB0aGlzLmNscykpLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBhbmltYXRlKTtcblxuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KGNoaWxkcmVuW2FjdGl2ZV0sIHRydWUsIGFuaW1hdGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0YWIgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG5cbiAgICAgIGV4dGVuZHM6IFN3aXRjaGVyLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtZWRpYTogQm9vbGVhblxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBtZWRpYTogOTYwLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXRhYi1pdGVtJ1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBjbHMgPSBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLXRhYi1sZWZ0JykgP1xuICAgICAgICAndWstdGFiLWxlZnQnIDpcbiAgICAgICAgaGFzQ2xhc3ModGhpcy4kZWwsICd1ay10YWItcmlnaHQnKSA/XG4gICAgICAgICd1ay10YWItcmlnaHQnIDpcbiAgICAgICAgZmFsc2U7XG5cbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgIHRoaXMuJGNyZWF0ZSgndG9nZ2xlJywgdGhpcy4kZWwsIHsgY2xzLCBtb2RlOiAnbWVkaWEnLCBtZWRpYTogdGhpcy5tZWRpYSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBLRVlfU1BBQ0UgPSAzMjtcblxuICAgIHZhciB0b2dnbGUgPSB7XG4gICAgICBtaXhpbnM6IFtMYXp5bG9hZCwgTWVkaWEsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICd0YXJnZXQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBocmVmOiBTdHJpbmcsXG4gICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgbW9kZTogJ2xpc3QnLFxuICAgICAgICBxdWV1ZWQ6IEJvb2xlYW5cbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaHJlZjogZmFsc2UsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIG1vZGU6ICdjbGljaycsXG4gICAgICAgIHF1ZXVlZDogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgZ2V0KHsgaHJlZiwgdGFyZ2V0IH0sICRlbCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gcXVlcnlBbGwodGFyZ2V0IHx8IGhyZWYsICRlbCk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aCAmJiB0YXJnZXQgfHwgWyRlbF07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBcmlhKCk7XG4gICAgICAgICAgICB0aGlzLmxhenlsb2FkKHRoaXMuJGVsLCB0aGlzLnRhcmdldCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRvY3VtZW50OiB0cnVlLFxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICghaW5jbHVkZXModGhpcy5tb2RlLCAnbWVkaWEnKSAmJiAhaXNGb2N1c2FibGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJEb3duJDEsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIHRoaXMuX3ByZXZlbnRDbGljayA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoIWlzVG91Y2goZSkgfHwgdGhpcy5fc2hvd1N0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2xpY2tpbmcgYSBidXR0b24gZG9lcyBub3QgZ2l2ZSBpdCBmb2N1cyBvbiBhbGwgYnJvd3NlcnMgYW5kIHBsYXRmb3Jtc1xuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9idXR0b24jY2xpY2tpbmdfYW5kX2ZvY3VzXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2ZvY3VzJyk7XG4gICAgICAgICAgb25jZShcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICBwb2ludGVyRG93biQxLFxuICAgICAgICAgICgpID0+IHRyaWdnZXIodGhpcy4kZWwsICdibHVyJyksXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAoZSkgPT4gIXdpdGhpbihlLnRhcmdldCwgdGhpcy4kZWwpKTtcblxuXG4gICAgICAgICAgLy8gUHJldmVudCBpbml0aWFsIGNsaWNrIHRvIHByZXZlbnQgZG91YmxlIHRvZ2dsZSB0aHJvdWdoIGZvY3VzICsgY2xpY2tcbiAgICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5tb2RlLCAnY2xpY2snKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmVudENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogYCR7cG9pbnRlckVudGVyfSAke3BvaW50ZXJMZWF2ZX0gZm9jdXMgYmx1cmAsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc2hvdyA9IGluY2x1ZGVzKFtwb2ludGVyRW50ZXIsICdmb2N1cyddLCBlLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnKTtcblxuICAgICAgICAgIC8vIFNraXAgaGlkZSBpZiBzdGlsbCBob3ZlcmVkIG9yIGZvY3VzZWRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXNob3cgJiYgKFxuICAgICAgICAgIGUudHlwZSA9PT0gcG9pbnRlckxlYXZlICYmIG1hdGNoZXModGhpcy4kZWwsICc6Zm9jdXMnKSB8fFxuICAgICAgICAgIGUudHlwZSA9PT0gJ2JsdXInICYmIG1hdGNoZXModGhpcy4kZWwsICc6aG92ZXInKSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNraXAgaWYgc3RhdGUgZG9lcyBub3QgY2hhbmdlIGUuZy4gaG92ZXIgKyBmb2N1cyByZWNlaXZlZFxuICAgICAgICAgIGlmICh0aGlzLl9zaG93U3RhdGUgJiYgc2hvdyAmJiBleHBhbmRlZCAhPT0gdGhpcy5fc2hvd1N0YXRlKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgcmVzZXQgaWYgc3RhdGUgaGFzIGNoYW5nZWQgdGhyb3VnaCBjbGlja1xuICAgICAgICAgICAgaWYgKCFzaG93KSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3dTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc2hvd1N0YXRlID0gc2hvdyA/IGV4cGFuZGVkIDogbnVsbDtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlKGB0b2dnbGUke3Nob3cgPyAnc2hvdycgOiAnaGlkZSd9YCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2tleWRvd24nLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZXModGhpcy5tb2RlLCAnY2xpY2snKSAmJiAhaXNUYWcodGhpcy4kZWwsICdpbnB1dCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWV9TUEFDRSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy4kZWwuY2xpY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIFsnY2xpY2snLCAnaG92ZXInXS5zb21lKChtb2RlKSA9PiBpbmNsdWRlcyh0aGlzLm1vZGUsIG1vZGUpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBsZXQgbGluaztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5fcHJldmVudENsaWNrIHx8XG4gICAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZj1cIiNcIl0sIGFbaHJlZj1cIlwiXScpIHx8XG4gICAgICAgICAgKGxpbmsgPSBjbG9zZXN0KGUudGFyZ2V0LCAnYVtocmVmXScpKSAmJiAoXG4gICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnKSAhPT0gJ3RydWUnIHx8XG4gICAgICAgICAgbGluay5oYXNoICYmIG1hdGNoZXModGhpcy50YXJnZXQsIGxpbmsuaGFzaCkpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3ByZXZlbnRDbGljayAmJiBpbmNsdWRlcyh0aGlzLm1vZGUsICdjbGljaycpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZSBzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKHsgdGFyZ2V0LCB0eXBlIH0pIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUFyaWEodGFyZ2V0ID09PSB0aGlzLnRhcmdldFswXSAmJiB0eXBlID09PSAnc2hvdycpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdtZWRpYWNoYW5nZScsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdtZWRpYScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUsIG1lZGlhT2JqKSB7XG4gICAgICAgICAgaWYgKG1lZGlhT2JqLm1hdGNoZXMgXiB0aGlzLmlzVG9nZ2xlZCh0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHRvZ2dsZSh0eXBlKSB7XG4gICAgICAgICAgaWYgKCF0cmlnZ2VyKHRoaXMudGFyZ2V0LCB0eXBlIHx8ICd0b2dnbGUnLCBbdGhpc10pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRhcmdldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbGVhdmluZyA9IHRoaXMudGFyZ2V0LmZpbHRlcigoZWwpID0+IGhhc0NsYXNzKGVsLCB0aGlzLmNsc0xlYXZlKSk7XG5cbiAgICAgICAgICBpZiAobGVhdmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaXNMZWF2aW5nID0gaW5jbHVkZXMobGVhdmluZywgZWwpO1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQoZWwsIGlzTGVhdmluZywgaXNMZWF2aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0b2dnbGVkID0gdGhpcy50YXJnZXQuZmlsdGVyKHRoaXMuaXNUb2dnbGVkKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQodG9nZ2xlZCwgZmFsc2UpO1xuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudChcbiAgICAgICAgICB0aGlzLnRhcmdldC5maWx0ZXIoKGVsKSA9PiAhaW5jbHVkZXModG9nZ2xlZCwgZWwpKSxcbiAgICAgICAgICB0cnVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUFyaWEodG9nZ2xlZCkge1xuICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLm1vZGUsICdtZWRpYScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cihcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCcsXG4gICAgICAgICAgaXNCb29sZWFuKHRvZ2dsZWQpID8gdG9nZ2xlZCA6IHRoaXMuaXNUb2dnbGVkKHRoaXMudGFyZ2V0KSk7XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY29tcG9uZW50cyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIEFjY29yZGlvbjogQWNjb3JkaW9uLFxuICAgICAgICBBbGVydDogYWxlcnQsXG4gICAgICAgIENvdmVyOiBjb3ZlcixcbiAgICAgICAgRHJvcDogZHJvcCxcbiAgICAgICAgRHJvcGRvd246IGRyb3AsXG4gICAgICAgIEZvcm1DdXN0b206IGZvcm1DdXN0b20sXG4gICAgICAgIEdyaWQ6IGdyaWQsXG4gICAgICAgIEhlaWdodE1hdGNoOiBoZWlnaHRNYXRjaCxcbiAgICAgICAgSGVpZ2h0Vmlld3BvcnQ6IGhlaWdodFZpZXdwb3J0LFxuICAgICAgICBJY29uOiBJY29uLFxuICAgICAgICBJbWc6IGltZyxcbiAgICAgICAgTGVhZGVyOiBsZWFkZXIsXG4gICAgICAgIE1hcmdpbjogTWFyZ2luLFxuICAgICAgICBNb2RhbDogbW9kYWwsXG4gICAgICAgIE5hdjogbmF2LFxuICAgICAgICBOYXZiYXI6IG5hdmJhcixcbiAgICAgICAgT2ZmY2FudmFzOiBvZmZjYW52YXMsXG4gICAgICAgIE92ZXJmbG93QXV0bzogb3ZlcmZsb3dBdXRvLFxuICAgICAgICBSZXNwb25zaXZlOiByZXNwb25zaXZlLFxuICAgICAgICBTY3JvbGw6IHNjcm9sbCxcbiAgICAgICAgU2Nyb2xsc3B5OiBzY3JvbGxzcHksXG4gICAgICAgIFNjcm9sbHNweU5hdjogc2Nyb2xsc3B5TmF2LFxuICAgICAgICBTdGlja3k6IHN0aWNreSxcbiAgICAgICAgU3ZnOiBTVkcsXG4gICAgICAgIFN3aXRjaGVyOiBTd2l0Y2hlcixcbiAgICAgICAgVGFiOiB0YWIsXG4gICAgICAgIFRvZ2dsZTogdG9nZ2xlLFxuICAgICAgICBWaWRlbzogVmlkZW8sXG4gICAgICAgIENsb3NlOiBDbG9zZSxcbiAgICAgICAgU3Bpbm5lcjogU3Bpbm5lcixcbiAgICAgICAgTmF2UGFyZW50SWNvbjogTmF2UGFyZW50SWNvbixcbiAgICAgICAgU2xpZGVuYXZOZXh0OiBTbGlkZW5hdixcbiAgICAgICAgU2xpZGVuYXZQcmV2aW91czogU2xpZGVuYXYsXG4gICAgICAgIFNlYXJjaEljb246IFNlYXJjaCxcbiAgICAgICAgTWFya2VyOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBOYXZiYXJQYXJlbnRJY29uOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBOYXZiYXJUb2dnbGVJY29uOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBPdmVybGF5SWNvbjogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgUGFnaW5hdGlvbk5leHQ6IEljb25Db21wb25lbnQsXG4gICAgICAgIFBhZ2luYXRpb25QcmV2aW91czogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgVG90b3A6IEljb25Db21wb25lbnRcbiAgICB9KTtcblxuICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudHNcbiAgICBlYWNoKGNvbXBvbmVudHMkMSwgKGNvbXBvbmVudCwgbmFtZSkgPT4gVUlraXQuY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkpO1xuXG4gICAgYm9vdChVSWtpdCk7XG5cbiAgICBjb25zdCB1bml0cyA9IFsnZGF5cycsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXTtcblxuICAgIHZhciBjb3VudGRvd24gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRhdGU6IFN0cmluZyxcbiAgICAgICAgY2xzV3JhcHBlcjogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRhdGU6ICcnLFxuICAgICAgICBjbHNXcmFwcGVyOiAnLnVrLWNvdW50ZG93bi0ldW5pdCUnXG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IERhdGUucGFyc2UodGhpcy4kcHJvcHMuZGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Zpc2liaWxpdHljaGFuZ2UnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMudXBkYXRlLCAxMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wKCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlKCkge1xuICAgICAgICAgIGNvbnN0IHRpbWVzcGFuID0gZ2V0VGltZVNwYW4odGhpcy5kYXRlKTtcblxuICAgICAgICAgIGlmICghdGhpcy5kYXRlIHx8IHRpbWVzcGFuLnRvdGFsIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgICAgICB0aW1lc3Bhbi5kYXlzID0gdGltZXNwYW4uaG91cnMgPSB0aW1lc3Bhbi5taW51dGVzID0gdGltZXNwYW4uc2Vjb25kcyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCB1bml0IG9mIHVuaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9ICQodGhpcy5jbHNXcmFwcGVyLnJlcGxhY2UoJyV1bml0JScsIHVuaXQpLCB0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkaWdpdHMgPSBTdHJpbmcoTWF0aC50cnVuYyh0aW1lc3Bhblt1bml0XSkpO1xuXG4gICAgICAgICAgICBkaWdpdHMgPSBkaWdpdHMubGVuZ3RoIDwgMiA/IGAwJHtkaWdpdHN9YCA6IGRpZ2l0cztcblxuICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSBkaWdpdHMpIHtcbiAgICAgICAgICAgICAgZGlnaXRzID0gZGlnaXRzLnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICBpZiAoZGlnaXRzLmxlbmd0aCAhPT0gZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaHRtbChlbCwgZGlnaXRzLm1hcCgoKSA9PiAnPHNwYW4+PC9zcGFuPicpLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRpZ2l0cy5mb3JFYWNoKChkaWdpdCwgaSkgPT4gZWwuY2hpbGRyZW5baV0udGV4dENvbnRlbnQgPSBkaWdpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFRpbWVTcGFuKGRhdGUpIHtcbiAgICAgIGNvbnN0IHRvdGFsID0gZGF0ZSAtIERhdGUubm93KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvdGFsLFxuICAgICAgICBzZWNvbmRzOiB0b3RhbCAvIDEwMDAgJSA2MCxcbiAgICAgICAgbWludXRlczogdG90YWwgLyAxMDAwIC8gNjAgJSA2MCxcbiAgICAgICAgaG91cnM6IHRvdGFsIC8gMTAwMCAvIDYwIC8gNjAgJSAyNCxcbiAgICAgICAgZGF5czogdG90YWwgLyAxMDAwIC8gNjAgLyA2MCAvIDI0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGNsc0xlYXZlID0gJ3VrLXRyYW5zaXRpb24tbGVhdmUnO1xuICAgIGNvbnN0IGNsc0VudGVyID0gJ3VrLXRyYW5zaXRpb24tZW50ZXInO1xuXG4gICAgZnVuY3Rpb24gZmFkZShhY3Rpb24sIHRhcmdldCwgZHVyYXRpb24sIHN0YWdnZXIgPSAwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRyYW5zaXRpb25JbmRleCh0YXJnZXQsIHRydWUpO1xuICAgICAgY29uc3QgcHJvcHNJbiA9IHsgb3BhY2l0eTogMSB9O1xuICAgICAgY29uc3QgcHJvcHNPdXQgPSB7IG9wYWNpdHk6IDAgfTtcblxuICAgICAgY29uc3Qgd3JhcEluZGV4Rm4gPSAoZm4pID0+ICgpID0+IGluZGV4ID09PSB0cmFuc2l0aW9uSW5kZXgodGFyZ2V0KSA/IGZuKCkgOiBQcm9taXNlLnJlamVjdCgpO1xuXG4gICAgICBjb25zdCBsZWF2ZUZuID0gd3JhcEluZGV4Rm4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBhZGRDbGFzcyh0YXJnZXQsIGNsc0xlYXZlKTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgZ2V0VHJhbnNpdGlvbk5vZGVzKHRhcmdldCkubWFwKFxuICAgICAgICAoY2hpbGQsIGkpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiBUcmFuc2l0aW9uLnN0YXJ0KGNoaWxkLCBwcm9wc091dCwgZHVyYXRpb24gLyAyLCAnZWFzZScpLnRoZW4oXG4gICAgICAgIHJlc29sdmUpLFxuXG4gICAgICAgIGkgKiBzdGFnZ2VyKSkpKTtcblxuXG5cblxuXG4gICAgICAgIHJlbW92ZUNsYXNzKHRhcmdldCwgY2xzTGVhdmUpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVudGVyRm4gPSB3cmFwSW5kZXhGbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZEhlaWdodCA9IGhlaWdodCh0YXJnZXQpO1xuXG4gICAgICAgIGFkZENsYXNzKHRhcmdldCwgY2xzRW50ZXIpO1xuICAgICAgICBhY3Rpb24oKTtcblxuICAgICAgICBjc3MoY2hpbGRyZW4odGFyZ2V0KSwgeyBvcGFjaXR5OiAwIH0pO1xuXG4gICAgICAgIC8vIEVuc3VyZSBVSWtpdCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZFxuICAgICAgICBhd2FpdCBhd2FpdEZyYW1lJDEoKTtcblxuICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IGhlaWdodCh0YXJnZXQpO1xuXG4gICAgICAgIC8vIEVuc3VyZSBHcmlkIGNlbGxzIGRvIG5vdCBzdHJldGNoIHdoZW4gaGVpZ2h0IGlzIGFwcGxpZWRcbiAgICAgICAgY3NzKHRhcmdldCwgJ2FsaWduQ29udGVudCcsICdmbGV4LXN0YXJ0Jyk7XG4gICAgICAgIGhlaWdodCh0YXJnZXQsIG9sZEhlaWdodCk7XG5cbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbk5vZGVzID0gZ2V0VHJhbnNpdGlvbk5vZGVzKHRhcmdldCk7XG4gICAgICAgIGNzcyhub2RlcywgcHJvcHNPdXQpO1xuXG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25zID0gdHJhbnNpdGlvbk5vZGVzLm1hcChhc3luYyAoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgICBhd2FpdCBhd2FpdFRpbWVvdXQoaSAqIHN0YWdnZXIpO1xuICAgICAgICAgIGF3YWl0IFRyYW5zaXRpb24uc3RhcnQoY2hpbGQsIHByb3BzSW4sIGR1cmF0aW9uIC8gMiwgJ2Vhc2UnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9sZEhlaWdodCAhPT0gbmV3SGVpZ2h0KSB7XG4gICAgICAgICAgdHJhbnNpdGlvbnMucHVzaChcbiAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICB7IGhlaWdodDogbmV3SGVpZ2h0IH0sXG4gICAgICAgICAgZHVyYXRpb24gLyAyICsgdHJhbnNpdGlvbk5vZGVzLmxlbmd0aCAqIHN0YWdnZXIsXG4gICAgICAgICAgJ2Vhc2UnKSk7XG5cblxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNpdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRhcmdldCwgY2xzRW50ZXIpO1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gdHJhbnNpdGlvbkluZGV4KHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNzcyh0YXJnZXQsIHsgaGVpZ2h0OiAnJywgYWxpZ25Db250ZW50OiAnJyB9KTtcbiAgICAgICAgICAgIGNzcyhub2RlcywgeyBvcGFjaXR5OiAnJyB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGhhc0NsYXNzKHRhcmdldCwgY2xzTGVhdmUpID9cbiAgICAgIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkudGhlbihlbnRlckZuKSA6XG4gICAgICBoYXNDbGFzcyh0YXJnZXQsIGNsc0VudGVyKSA/XG4gICAgICB3YWl0VHJhbnNpdGlvbmVuZCh0YXJnZXQpLnRoZW4obGVhdmVGbikudGhlbihlbnRlckZuKSA6XG4gICAgICBsZWF2ZUZuKCkudGhlbihlbnRlckZuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uSW5kZXgodGFyZ2V0LCBuZXh0KSB7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICB0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uID0gMSArIHRyYW5zaXRpb25JbmRleCh0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9OdW1iZXIodGFyZ2V0LmRhdGFzZXQudHJhbnNpdGlvbikgfHwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YWl0VHJhbnNpdGlvbmVuZCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIGNoaWxkcmVuKHRhcmdldCkuXG4gICAgICBmaWx0ZXIoVHJhbnNpdGlvbi5pblByb2dyZXNzKS5cbiAgICAgIG1hcChcbiAgICAgIChlbCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25jYW5jZWxlZCcsIHJlc29sdmUpKSkpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0Um93cyhjaGlsZHJlbih0YXJnZXQpKS5yZWR1Y2UoXG4gICAgICAobm9kZXMsIHJvdykgPT4gbm9kZXMuY29uY2F0KFxuICAgICAgc29ydEJ5JDEoXG4gICAgICByb3cuZmlsdGVyKChlbCkgPT4gaXNJblZpZXcoZWwpKSxcbiAgICAgICdvZmZzZXRMZWZ0JykpLFxuXG5cbiAgICAgIFtdKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF3YWl0RnJhbWUkMSgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhd2FpdFRpbWVvdXQodGltZW91dCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBzbGlkZSAoYWN0aW9uLCB0YXJnZXQsIGR1cmF0aW9uKSB7XG4gICAgICBhd2FpdCBhd2FpdEZyYW1lKCk7XG5cbiAgICAgIGxldCBub2RlcyA9IGNoaWxkcmVuKHRhcmdldCk7XG5cbiAgICAgIC8vIEdldCBjdXJyZW50IHN0YXRlXG4gICAgICBjb25zdCBjdXJyZW50UHJvcHMgPSBub2Rlcy5tYXAoKGVsKSA9PiBnZXRQcm9wcyhlbCwgdHJ1ZSkpO1xuICAgICAgY29uc3QgdGFyZ2V0UHJvcHMgPSB7IC4uLmNzcyh0YXJnZXQsIFsnaGVpZ2h0JywgJ3BhZGRpbmcnXSksIGRpc3BsYXk6ICdibG9jaycgfTtcblxuICAgICAgLy8gQ2FuY2VsIHByZXZpb3VzIGFuaW1hdGlvbnNcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKG5vZGVzLmNvbmNhdCh0YXJnZXQpLm1hcChUcmFuc2l0aW9uLmNhbmNlbCkpO1xuXG4gICAgICAvLyBBZGRpbmcsIHNvcnRpbmcsIHJlbW92aW5nIG5vZGVzXG4gICAgICBhY3Rpb24oKTtcblxuICAgICAgLy8gRmluZCBuZXcgbm9kZXNcbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNoaWxkcmVuKHRhcmdldCkuZmlsdGVyKChlbCkgPT4gIWluY2x1ZGVzKG5vZGVzLCBlbCkpKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdXBkYXRlIHRvIHByb3BhZ2F0ZVxuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICAgIC8vIEZvcmNlIHVwZGF0ZVxuICAgICAgZmFzdGRvbS5mbHVzaCgpO1xuXG4gICAgICAvLyBHZXQgbmV3IHN0YXRlXG4gICAgICBjb25zdCB0YXJnZXRTdHlsZSA9IGF0dHIodGFyZ2V0LCAnc3R5bGUnKTtcbiAgICAgIGNvbnN0IHRhcmdldFByb3BzVG8gPSBjc3ModGFyZ2V0LCBbJ2hlaWdodCcsICdwYWRkaW5nJ10pO1xuICAgICAgY29uc3QgW3Byb3BzVG8sIHByb3BzRnJvbV0gPSBnZXRUcmFuc2l0aW9uUHJvcHModGFyZ2V0LCBub2RlcywgY3VycmVudFByb3BzKTtcbiAgICAgIGNvbnN0IGF0dHJzVG8gPSBub2Rlcy5tYXAoKGVsKSA9PiAoeyBzdHlsZTogYXR0cihlbCwgJ3N0eWxlJykgfSkpO1xuXG4gICAgICAvLyBSZXNldCB0byBwcmV2aW91cyBzdGF0ZVxuICAgICAgbm9kZXMuZm9yRWFjaCgoZWwsIGkpID0+IHByb3BzRnJvbVtpXSAmJiBjc3MoZWwsIHByb3BzRnJvbVtpXSkpO1xuICAgICAgY3NzKHRhcmdldCwgdGFyZ2V0UHJvcHMpO1xuXG4gICAgICAvLyBTdGFydCB0cmFuc2l0aW9ucyBvbiBuZXh0IGZyYW1lXG4gICAgICBhd2FpdCBhd2FpdEZyYW1lKCk7XG5cbiAgICAgIGNvbnN0IHRyYW5zaXRpb25zID0gbm9kZXMuXG4gICAgICBtYXAoKGVsLCBpKSA9PiBwYXJlbnQoZWwpID09PSB0YXJnZXQgJiYgVHJhbnNpdGlvbi5zdGFydChlbCwgcHJvcHNUb1tpXSwgZHVyYXRpb24sICdlYXNlJykpLlxuICAgICAgY29uY2F0KFRyYW5zaXRpb24uc3RhcnQodGFyZ2V0LCB0YXJnZXRQcm9wc1RvLCBkdXJhdGlvbiwgJ2Vhc2UnKSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYW5zaXRpb25zKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgoZWwsIGkpID0+IHtcbiAgICAgICAgICBhdHRyKGVsLCBhdHRyc1RvW2ldKTtcbiAgICAgICAgICBpZiAocGFyZW50KGVsKSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBjc3MoZWwsICdkaXNwbGF5JywgcHJvcHNUb1tpXS5vcGFjaXR5ID09PSAwID8gJ25vbmUnIDogJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF0dHIodGFyZ2V0LCAnc3R5bGUnLCB0YXJnZXRTdHlsZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGF0dHIobm9kZXMsICdzdHlsZScsICcnKTtcbiAgICAgICAgcmVzZXRQcm9wcyh0YXJnZXQsIHRhcmdldFByb3BzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcm9wcyhlbCwgb3BhY2l0eSkge1xuICAgICAgY29uc3QgekluZGV4ID0gY3NzKGVsLCAnekluZGV4Jyk7XG5cbiAgICAgIHJldHVybiBpc1Zpc2libGUoZWwpID9cbiAgICAgIHtcbiAgICAgICAgZGlzcGxheTogJycsXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHkgPyBjc3MoZWwsICdvcGFjaXR5JykgOiAnMCcsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHpJbmRleDogekluZGV4ID09PSAnYXV0bycgPyBpbmRleChlbCkgOiB6SW5kZXgsXG4gICAgICAgIC4uLmdldFBvc2l0aW9uV2l0aE1hcmdpbihlbClcbiAgICAgIH0gOlxuICAgICAgZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblByb3BzKHRhcmdldCwgbm9kZXMsIGN1cnJlbnRQcm9wcykge1xuICAgICAgY29uc3QgcHJvcHNUbyA9IG5vZGVzLm1hcCgoZWwsIGkpID0+IHBhcmVudChlbCkgJiYgaSBpbiBjdXJyZW50UHJvcHMgP1xuICAgICAgY3VycmVudFByb3BzW2ldID9cbiAgICAgIGlzVmlzaWJsZShlbCkgP1xuICAgICAgZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSA6XG4gICAgICB7IG9wYWNpdHk6IDAgfSA6XG4gICAgICB7IG9wYWNpdHk6IGlzVmlzaWJsZShlbCkgPyAxIDogMCB9IDpcbiAgICAgIGZhbHNlKTtcblxuXG4gICAgICBjb25zdCBwcm9wc0Zyb20gPSBwcm9wc1RvLm1hcCgocHJvcHMsIGkpID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBhcmVudChub2Rlc1tpXSkgPT09IHRhcmdldCAmJiAoY3VycmVudFByb3BzW2ldIHx8IGdldFByb3BzKG5vZGVzW2ldKSk7XG5cbiAgICAgICAgaWYgKCFmcm9tKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgIGRlbGV0ZSBmcm9tLm9wYWNpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoISgnb3BhY2l0eScgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgY29uc3QgeyBvcGFjaXR5IH0gPSBmcm9tO1xuXG4gICAgICAgICAgaWYgKG9wYWNpdHkgJSAxKSB7XG4gICAgICAgICAgICBwcm9wcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGZyb20ub3BhY2l0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gW3Byb3BzVG8sIHByb3BzRnJvbV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXRQcm9wcyhlbCwgcHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBjc3MoZWwsIHByb3AsICcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbldpdGhNYXJnaW4oZWwpIHtcbiAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gb2Zmc2V0KGVsKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgdHJhbnNmb3JtOiAnJyxcbiAgICAgICAgLi4ucG9zaXRpb24oZWwpLFxuICAgICAgICAuLi5jc3MoZWwsIFsnbWFyZ2luVG9wJywgJ21hcmdpbkxlZnQnXSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXdhaXRGcmFtZSgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpKTtcbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0ZSA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIsXG4gICAgICAgIGFuaW1hdGlvbjogQm9vbGVhblxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBkdXJhdGlvbjogMTUwLFxuICAgICAgICBhbmltYXRpb246ICdzbGlkZSdcbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYW5pbWF0ZShhY3Rpb24sIHRhcmdldCA9IHRoaXMuJGVsKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkZuID1cbiAgICAgICAgICBuYW1lID09PSAnZmFkZScgP1xuICAgICAgICAgIGZhZGUgOlxuICAgICAgICAgIG5hbWUgPT09ICdkZWxheWVkLWZhZGUnID9cbiAgICAgICAgICAoLi4uYXJncykgPT4gZmFkZSguLi5hcmdzLCA0MCkgOlxuICAgICAgICAgIG5hbWUgP1xuICAgICAgICAgIHNsaWRlIDpcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBhY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkZuKGFjdGlvbiwgdGFyZ2V0LCB0aGlzLmR1cmF0aW9uKS5jYXRjaChub29wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZmlsdGVyID0ge1xuICAgICAgbWl4aW5zOiBbQW5pbWF0ZV0sXG5cbiAgICAgIGFyZ3M6ICd0YXJnZXQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHNlbEFjdGl2ZTogQm9vbGVhblxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIHNlbEFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGF0dHJJdGVtOiAndWstZmlsdGVyLWNvbnRyb2wnLFxuICAgICAgICBjbHM6ICd1ay1hY3RpdmUnLFxuICAgICAgICBkdXJhdGlvbjogMjUwXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0b2dnbGVzOiB7XG4gICAgICAgICAgZ2V0KHsgYXR0ckl0ZW0gfSwgJGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQoYFske2F0dHJJdGVtfV0sW2RhdGEtJHthdHRySXRlbX1dYCwgJGVsKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlbEFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlcyA9ICQkKHRoaXMuc2VsQWN0aXZlLCB0aGlzLiRlbCk7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlcy5mb3JFYWNoKChlbCkgPT4gdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzLCBpbmNsdWRlcyhhY3RpdmVzLCBlbCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICBnZXQoeyB0YXJnZXQgfSwgJGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQoYCR7dGFyZ2V0fSA+ICpgLCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChsaXN0LCBvbGQpIHtcbiAgICAgICAgICAgIGlmIChvbGQgJiYgIWlzRXF1YWxMaXN0KGxpc3QsIG9sZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIGBbJHt0aGlzLmF0dHJJdGVtfV0sW2RhdGEtJHt0aGlzLmF0dHJJdGVtfV1gO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmFwcGx5KGUuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1dLFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXBwbHkoZWwpIHtcbiAgICAgICAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBtZXJnZVN0YXRlKGVsLCB0aGlzLmF0dHJJdGVtLCB0aGlzLmdldFN0YXRlKCkpO1xuXG4gICAgICAgICAgaWYgKCFpc0VxdWFsU3RhdGUocHJldlN0YXRlLCBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTdGF0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGVzLlxuICAgICAgICAgIGZpbHRlcigoaXRlbSkgPT4gaGFzQ2xhc3MoaXRlbSwgdGhpcy5jbHMpKS5cbiAgICAgICAgICByZWR1Y2UoKHN0YXRlLCBlbCkgPT4gbWVyZ2VTdGF0ZShlbCwgdGhpcy5hdHRySXRlbSwgc3RhdGUpLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IHsgJyc6ICcnIH0sXG4gICAgICAgICAgICBzb3J0OiBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFzeW5jIHNldFN0YXRlKHN0YXRlLCBhbmltYXRlID0gdHJ1ZSkge1xuICAgICAgICAgIHN0YXRlID0geyBmaWx0ZXI6IHsgJyc6ICcnIH0sIHNvcnQ6IFtdLCAuLi5zdGF0ZSB9O1xuXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2JlZm9yZUZpbHRlcicsIFt0aGlzLCBzdGF0ZV0pO1xuXG4gICAgICAgICAgdGhpcy50b2dnbGVzLmZvckVhY2goKGVsKSA9PiB0b2dnbGVDbGFzcyhlbCwgdGhpcy5jbHMsICEhbWF0Y2hGaWx0ZXIoZWwsIHRoaXMuYXR0ckl0ZW0sIHN0YXRlKSkpO1xuXG5cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAkJCh0aGlzLnRhcmdldCwgdGhpcy4kZWwpLm1hcCgodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgYXBwbHlTdGF0ZShzdGF0ZSwgdGFyZ2V0LCBjaGlsZHJlbih0YXJnZXQpKTtcbiAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlKHRoaXMuJGVsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0ZSA/IHRoaXMuYW5pbWF0ZShmaWx0ZXJGbiwgdGFyZ2V0KSA6IGZpbHRlckZuKCk7XG4gICAgICAgICAgfSkpO1xuXG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnYWZ0ZXJGaWx0ZXInLCBbdGhpc10pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICAgIGZhc3Rkb20ud3JpdGUoKCkgPT4gdGhpcy5zZXRTdGF0ZSh0aGlzLmdldFN0YXRlKCksIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RmlsdGVyKGVsLCBhdHRyKSB7XG4gICAgICByZXR1cm4gcGFyc2VPcHRpb25zKGRhdGEoZWwsIGF0dHIpLCBbJ2ZpbHRlciddKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VxdWFsU3RhdGUoc3RhdGVBLCBzdGF0ZUIpIHtcbiAgICAgIHJldHVybiBbJ2ZpbHRlcicsICdzb3J0J10uZXZlcnkoKHByb3ApID0+IGlzRXF1YWwoc3RhdGVBW3Byb3BdLCBzdGF0ZUJbcHJvcF0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVN0YXRlKHN0YXRlLCB0YXJnZXQsIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKHN0YXRlKTtcblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoZWwpID0+IGNzcyhlbCwgJ2Rpc3BsYXknLCBzZWxlY3RvciAmJiAhbWF0Y2hlcyhlbCwgc2VsZWN0b3IpID8gJ25vbmUnIDogJycpKTtcblxuICAgICAgY29uc3QgW3NvcnQsIG9yZGVyXSA9IHN0YXRlLnNvcnQ7XG5cbiAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRJdGVtcyhjaGlsZHJlbiwgc29ydCwgb3JkZXIpO1xuICAgICAgICBpZiAoIWlzRXF1YWwoc29ydGVkLCBjaGlsZHJlbikpIHtcbiAgICAgICAgICBhcHBlbmQodGFyZ2V0LCBzb3J0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VTdGF0ZShlbCwgYXR0ciwgc3RhdGUpIHtcbiAgICAgIGNvbnN0IHsgZmlsdGVyLCBncm91cCwgc29ydCwgb3JkZXIgPSAnYXNjJyB9ID0gZ2V0RmlsdGVyKGVsLCBhdHRyKTtcblxuICAgICAgaWYgKGZpbHRlciB8fCBpc1VuZGVmaW5lZChzb3J0KSkge1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuZmlsdGVyWycnXTtcbiAgICAgICAgICAgIHN0YXRlLmZpbHRlcltncm91cF0gPSBmaWx0ZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5maWx0ZXJbZ3JvdXBdO1xuXG4gICAgICAgICAgICBpZiAoaXNFbXB0eShzdGF0ZS5maWx0ZXIpIHx8ICcnIGluIHN0YXRlLmZpbHRlcikge1xuICAgICAgICAgICAgICBzdGF0ZS5maWx0ZXIgPSB7ICcnOiBmaWx0ZXIgfHwgJycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuZmlsdGVyID0geyAnJzogZmlsdGVyIHx8ICcnIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1VuZGVmaW5lZChzb3J0KSkge1xuICAgICAgICBzdGF0ZS5zb3J0ID0gW3NvcnQsIG9yZGVyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRmlsdGVyKFxuICAgIGVsLFxuICAgIGF0dHIsXG4gICAgeyBmaWx0ZXI6IHN0YXRlRmlsdGVyID0geyAnJzogJycgfSwgc29ydDogW3N0YXRlU29ydCwgc3RhdGVPcmRlcl0gfSlcbiAgICB7XG4gICAgICBjb25zdCB7IGZpbHRlciA9ICcnLCBncm91cCA9ICcnLCBzb3J0LCBvcmRlciA9ICdhc2MnIH0gPSBnZXRGaWx0ZXIoZWwsIGF0dHIpO1xuXG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoc29ydCkgP1xuICAgICAgZ3JvdXAgaW4gc3RhdGVGaWx0ZXIgJiYgZmlsdGVyID09PSBzdGF0ZUZpbHRlcltncm91cF0gfHxcbiAgICAgICFmaWx0ZXIgJiYgZ3JvdXAgJiYgIShncm91cCBpbiBzdGF0ZUZpbHRlcikgJiYgIXN0YXRlRmlsdGVyWycnXSA6XG4gICAgICBzdGF0ZVNvcnQgPT09IHNvcnQgJiYgc3RhdGVPcmRlciA9PT0gb3JkZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbExpc3QobGlzdEEsIGxpc3RCKSB7XG4gICAgICByZXR1cm4gbGlzdEEubGVuZ3RoID09PSBsaXN0Qi5sZW5ndGggJiYgbGlzdEEuZXZlcnkoKGVsKSA9PiBsaXN0Qi5pbmNsdWRlcyhlbCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9yKHsgZmlsdGVyIH0pIHtcbiAgICAgIGxldCBzZWxlY3RvciA9ICcnO1xuICAgICAgZWFjaChmaWx0ZXIsICh2YWx1ZSkgPT4gc2VsZWN0b3IgKz0gdmFsdWUgfHwgJycpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRJdGVtcyhub2Rlcywgc29ydCwgb3JkZXIpIHtcbiAgICAgIHJldHVybiBbLi4ubm9kZXNdLnNvcnQoXG4gICAgICAoYSwgYikgPT4gZGF0YShhLCBzb3J0KS5sb2NhbGVDb21wYXJlKGRhdGEoYiwgc29ydCksIHVuZGVmaW5lZCwgeyBudW1lcmljOiB0cnVlIH0pICogKFxuICAgICAgb3JkZXIgPT09ICdhc2MnIHx8IC0xKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0aW9ucyQyID0ge1xuICAgICAgc2xpZGU6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW3sgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogLTEwMCkgfSwgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkKGN1cnJlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogLTEwMCAqIHBlcmNlbnQpIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZShkaXIgKiAxMDAgKiAoMSAtIHBlcmNlbnQpKSB9XTtcblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZWQoZWwpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhjc3MoZWwsICd0cmFuc2Zvcm0nKS5zcGxpdCgnLCcpWzRdIC8gZWwub2Zmc2V0V2lkdGgpIHx8IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlID0gMCwgdW5pdCA9ICclJykge1xuICAgICAgdmFsdWUgKz0gdmFsdWUgPyB1bml0IDogJyc7XG4gICAgICByZXR1cm4gYHRyYW5zbGF0ZTNkKCR7dmFsdWV9LCAwLCAwKWA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGUzZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGBzY2FsZTNkKCR7dmFsdWV9LCAke3ZhbHVlfSwgMSlgO1xuICAgIH1cblxuICAgIHZhciBBbmltYXRpb25zJDEgPSB7XG4gICAgICAuLi5BbmltYXRpb25zJDIsXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiAxIC0gY3NzKGN1cnJlbnQsICdvcGFjaXR5Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICByZXR1cm4gW3sgb3BhY2l0eTogMSAtIHBlcmNlbnQgfSwgeyBvcGFjaXR5OiBwZXJjZW50IH1dO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzY2FsZToge1xuICAgICAgICBzaG93KCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06IHNjYWxlM2QoMSAtIDAuMikgfSxcbiAgICAgICAgICB7IG9wYWNpdHk6IDEsIHRyYW5zZm9ybTogc2NhbGUzZCgxKSB9XTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiAxIC0gY3NzKGN1cnJlbnQsICdvcGFjaXR5Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgb3BhY2l0eTogMSAtIHBlcmNlbnQsIHRyYW5zZm9ybTogc2NhbGUzZCgxIC0gMC4yICogcGVyY2VudCkgfSxcbiAgICAgICAgICB7IG9wYWNpdHk6IHBlcmNlbnQsIHRyYW5zZm9ybTogc2NhbGUzZCgxIC0gMC4yICsgMC4yICogcGVyY2VudCkgfV07XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uZXIkMShwcmV2LCBuZXh0LCBkaXIsIHsgYW5pbWF0aW9uLCBlYXNpbmcgfSkge1xuICAgICAgY29uc3QgeyBwZXJjZW50LCB0cmFuc2xhdGUsIHNob3cgPSBub29wIH0gPSBhbmltYXRpb247XG4gICAgICBjb25zdCBwcm9wcyA9IHNob3coZGlyKTtcbiAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpcixcblxuICAgICAgICBzaG93KGR1cmF0aW9uLCBwZXJjZW50ID0gMCwgbGluZWFyKSB7XG4gICAgICAgICAgY29uc3QgdGltaW5nID0gbGluZWFyID8gJ2xpbmVhcicgOiBlYXNpbmc7XG4gICAgICAgICAgZHVyYXRpb24gLT0gTWF0aC5yb3VuZChkdXJhdGlvbiAqIGNsYW1wKHBlcmNlbnQsIC0xLCAxKSk7XG5cbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShwZXJjZW50KTtcblxuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShuZXh0LCAnaXRlbWluJywgeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSQxKHByZXYsICdpdGVtb3V0JywgeyBwZXJjZW50OiAxIC0gcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0pO1xuXG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQobmV4dCwgcHJvcHNbMV0sIGR1cmF0aW9uLCB0aW1pbmcpLFxuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQocHJldiwgcHJvcHNbMF0sIGR1cmF0aW9uLCB0aW1pbmcpXSkuXG4gICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfSwgbm9vcCk7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwoW25leHQsIHByZXZdKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHNbMF0pIHtcbiAgICAgICAgICAgIGNzcyhbbmV4dCwgcHJldl0sIHByb3AsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCA9IHRoaXMucGVyY2VudCgpKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwoW25leHQsIHByZXZdKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaG93KGR1cmF0aW9uLCBwZXJjZW50LCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICAgIGNvbnN0IHByb3BzID0gdHJhbnNsYXRlKHBlcmNlbnQsIGRpcik7XG4gICAgICAgICAgY3NzKG5leHQsIHByb3BzWzFdKTtcbiAgICAgICAgICBjc3MocHJldiwgcHJvcHNbMF0pO1xuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShuZXh0LCAnaXRlbXRyYW5zbGF0ZWluJywgeyBwZXJjZW50LCBkaXIgfSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSQxKHByZXYsICdpdGVtdHJhbnNsYXRlb3V0JywgeyBwZXJjZW50OiAxIC0gcGVyY2VudCwgZGlyIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIHBlcmNlbnQocHJldiB8fCBuZXh0LCBuZXh0LCBkaXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldERpc3RhbmNlKCkge1xuICAgICAgICAgIHJldHVybiBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXJVcGRhdGUkMShlbCwgdHlwZSwgZGF0YSkge1xuICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIFNsaWRlckF1dG9wbGF5ID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYXV0b3BsYXk6IEJvb2xlYW4sXG4gICAgICAgIGF1dG9wbGF5SW50ZXJ2YWw6IE51bWJlcixcbiAgICAgICAgcGF1c2VPbkhvdmVyOiBCb29sZWFuXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogNzAwMCxcbiAgICAgICAgcGF1c2VPbkhvdmVyOiB0cnVlXG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuYXV0b3BsYXkgJiYgdGhpcy5zdGFydEF1dG9wbGF5KCk7XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuc3RvcEF1dG9wbGF5KCk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGUoKSB7XG4gICAgICAgIGF0dHIodGhpcy5zbGlkZXMsICd0YWJpbmRleCcsICctMScpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd2aXNpYmlsaXR5Y2hhbmdlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF1dG9wbGF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5zdG9wQXV0b3BsYXkoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydEF1dG9wbGF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0QXV0b3BsYXkoKSB7XG4gICAgICAgICAgdGhpcy5zdG9wQXV0b3BsYXkoKTtcblxuICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAoKSA9PiAoIXRoaXMuZHJhZ2dhYmxlIHx8ICEkKCc6Zm9jdXMnLCB0aGlzLiRlbCkpICYmIChcbiAgICAgICAgICAhdGhpcy5wYXVzZU9uSG92ZXIgfHwgIW1hdGNoZXModGhpcy4kZWwsICc6aG92ZXInKSkgJiZcbiAgICAgICAgICAhdGhpcy5zdGFjay5sZW5ndGggJiZcbiAgICAgICAgICB0aGlzLnNob3coJ25leHQnKSxcbiAgICAgICAgICB0aGlzLmF1dG9wbGF5SW50ZXJ2YWwpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RvcEF1dG9wbGF5KCkge1xuICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBwb2ludGVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IHRydWUgfTtcbiAgICBjb25zdCBwb2ludGVyVXBPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH07XG4gICAgY29uc3QgcG9pbnRlckRvd24gPSAndG91Y2hzdGFydCBtb3VzZWRvd24nO1xuICAgIGNvbnN0IHBvaW50ZXJNb3ZlID0gJ3RvdWNobW92ZSBtb3VzZW1vdmUnO1xuICAgIGNvbnN0IHBvaW50ZXJVcCA9ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZXVwIGNsaWNrIGlucHV0IHNjcm9sbCc7XG5cbiAgICB2YXIgU2xpZGVyRHJhZyA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRyYWdnYWJsZTogQm9vbGVhblxuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIHRocmVzaG9sZDogMTBcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnc3RhcnQnLCAnbW92ZScsICdlbmQnXSkge1xuICAgICAgICAgIGNvbnN0IGZuID0gdGhpc1trZXldO1xuICAgICAgICAgIHRoaXNba2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFdmVudFBvcyhlKS54ICogKGlzUnRsID8gLTEgOiAxKTtcblxuICAgICAgICAgICAgdGhpcy5wcmV2UG9zID0gcG9zID09PSB0aGlzLnBvcyA/IHRoaXMucHJldlBvcyA6IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG5cbiAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRG93bixcblxuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiBgJHt0aGlzLnNlbExpc3R9ID4gKmA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICF0aGlzLmRyYWdnYWJsZSB8fFxuICAgICAgICAgICFpc1RvdWNoKGUpICYmIGhhc1NlbGVjdGFibGVUZXh0KGUudGFyZ2V0KSB8fFxuICAgICAgICAgIGNsb3Nlc3QoZS50YXJnZXQsIHNlbElucHV0KSB8fFxuICAgICAgICAgIGUuYnV0dG9uID4gMCB8fFxuICAgICAgICAgIHRoaXMubGVuZ3RoIDwgMilcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFydChlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZHJhZ3N0YXJ0JyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgLy8gaU9TIHdvcmthcm91bmQgZm9yIHNsaWRlciBzdG9wcGluZyBpZiBzd2lwaW5nIGZhc3RcbiAgICAgICAgbmFtZTogcG9pbnRlck1vdmUsXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZXI6IG5vb3AsXG4gICAgICAgIC4uLnBvaW50ZXJPcHRpb25zXG4gICAgICB9XSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgIHRoaXMuZHJhZyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3RyYW5zaXRpb25lcikge1xuICAgICAgICAgICAgdGhpcy5wZXJjZW50ID0gdGhpcy5fdHJhbnNpdGlvbmVyLnBlcmNlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZyArPSB0aGlzLl90cmFuc2l0aW9uZXIuZ2V0RGlzdGFuY2UoKSAqIHRoaXMucGVyY2VudCAqIHRoaXMuZGlyO1xuXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIudHJhbnNsYXRlKHRoaXMucGVyY2VudCk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSwgcG9pbnRlck9wdGlvbnMpO1xuXG4gICAgICAgICAgLy8gJ2lucHV0JyBldmVudCBpcyB0cmlnZ2VyZWQgYnkgdmlkZW8gY29udHJvbHNcbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlclVwLCB0aGlzLmVuZCwgcG9pbnRlclVwT3B0aW9ucyk7XG5cbiAgICAgICAgICBjc3ModGhpcy5saXN0LCAndXNlclNlbGVjdCcsICdub25lJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZShlKSB7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnBvcyAtIHRoaXMuZHJhZztcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBkaXN0YW5jZSA9PT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJldlBvcyA9PT0gdGhpcy5wb3MgfHxcbiAgICAgICAgICAhdGhpcy5kcmFnZ2luZyAmJiBNYXRoLmFicyhkaXN0YW5jZSkgPCB0aGlzLnRocmVzaG9sZClcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcHJldmVudCBjbGljayBldmVudFxuICAgICAgICAgIGNzcyh0aGlzLmxpc3QsICdwb2ludGVyRXZlbnRzJywgJ25vbmUnKTtcblxuICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRpciA9IGRpc3RhbmNlIDwgMCA/IDEgOiAtMTtcblxuICAgICAgICAgIGNvbnN0IHsgc2xpZGVzIH0gPSB0aGlzO1xuICAgICAgICAgIGxldCB7IHByZXZJbmRleCB9ID0gdGhpcztcbiAgICAgICAgICBsZXQgZGlzID0gTWF0aC5hYnMoZGlzdGFuY2UpO1xuICAgICAgICAgIGxldCBuZXh0SW5kZXggPSB0aGlzLmdldEluZGV4KHByZXZJbmRleCArIHRoaXMuZGlyLCBwcmV2SW5kZXgpO1xuICAgICAgICAgIGxldCB3aWR0aCA9IHRoaXMuX2dldERpc3RhbmNlKHByZXZJbmRleCwgbmV4dEluZGV4KSB8fCBzbGlkZXNbcHJldkluZGV4XS5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgIHdoaWxlIChuZXh0SW5kZXggIT09IHByZXZJbmRleCAmJiBkaXMgPiB3aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnIC09IHdpZHRoICogdGhpcy5kaXI7XG5cbiAgICAgICAgICAgIHByZXZJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIGRpcyAtPSB3aWR0aDtcbiAgICAgICAgICAgIG5leHRJbmRleCA9IHRoaXMuZ2V0SW5kZXgocHJldkluZGV4ICsgdGhpcy5kaXIsIHByZXZJbmRleCk7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX2dldERpc3RhbmNlKHByZXZJbmRleCwgbmV4dEluZGV4KSB8fCBzbGlkZXNbcHJldkluZGV4XS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBlcmNlbnQgPSBkaXMgLyB3aWR0aDtcblxuICAgICAgICAgIGNvbnN0IHByZXYgPSBzbGlkZXNbcHJldkluZGV4XTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gc2xpZGVzW25leHRJbmRleF07XG4gICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuaW5kZXggIT09IG5leHRJbmRleDtcbiAgICAgICAgICBjb25zdCBlZGdlID0gcHJldkluZGV4ID09PSBuZXh0SW5kZXg7XG5cbiAgICAgICAgICBsZXQgaXRlbVNob3duO1xuXG4gICAgICAgICAgW3RoaXMuaW5kZXgsIHRoaXMucHJldkluZGV4XS5cbiAgICAgICAgICBmaWx0ZXIoKGkpID0+ICFpbmNsdWRlcyhbbmV4dEluZGV4LCBwcmV2SW5kZXhdLCBpKSkuXG4gICAgICAgICAgZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICAgICAgdHJpZ2dlcihzbGlkZXNbaV0sICdpdGVtaGlkZGVuJywgW3RoaXNdKTtcblxuICAgICAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgICAgaXRlbVNob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gcHJldkluZGV4ICYmIHRoaXMucHJldkluZGV4ICE9PSBwcmV2SW5kZXggfHwgaXRlbVNob3duKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHNsaWRlc1t0aGlzLmluZGV4XSwgJ2l0ZW1zaG93bicsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gcHJldkluZGV4O1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcblxuICAgICAgICAgICAgIWVkZ2UgJiYgdHJpZ2dlcihwcmV2LCAnYmVmb3JlaXRlbWhpZGUnLCBbdGhpc10pO1xuICAgICAgICAgICAgdHJpZ2dlcihuZXh0LCAnYmVmb3JlaXRlbXNob3cnLCBbdGhpc10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lciA9IHRoaXMuX3RyYW5zbGF0ZShNYXRoLmFicyh0aGlzLnBlcmNlbnQpLCBwcmV2LCAhZWRnZSAmJiBuZXh0KTtcblxuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAhZWRnZSAmJiB0cmlnZ2VyKHByZXYsICdpdGVtaGlkZScsIFt0aGlzXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKG5leHQsICdpdGVtc2hvdycsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJNb3ZlLCB0aGlzLm1vdmUsIHBvaW50ZXJPcHRpb25zKTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJVcCwgdGhpcy5lbmQsIHBvaW50ZXJVcE9wdGlvbnMpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5wcmV2SW5kZXgpIHtcbiAgICAgICAgICAgICAgdGhpcy5wZXJjZW50ID0gMSAtIHRoaXMucGVyY2VudDtcbiAgICAgICAgICAgICAgdGhpcy5kaXIgKj0gLTE7XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3coZmFsc2UsIHRoaXMuaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgZGlyQ2hhbmdlID1cbiAgICAgICAgICAgICAgKGlzUnRsID8gdGhpcy5kaXIgKiAoaXNSdGwgPyAxIDogLTEpIDogdGhpcy5kaXIpIDwgMCA9PT1cbiAgICAgICAgICAgICAgdGhpcy5wcmV2UG9zID4gdGhpcy5wb3M7XG4gICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBkaXJDaGFuZ2UgPyB0aGlzLmluZGV4IDogdGhpcy5wcmV2SW5kZXg7XG5cbiAgICAgICAgICAgICAgaWYgKGRpckNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyY2VudCA9IDEgLSB0aGlzLnBlcmNlbnQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnNob3coXG4gICAgICAgICAgICAgIHRoaXMuZGlyID4gMCAmJiAhZGlyQ2hhbmdlIHx8IHRoaXMuZGlyIDwgMCAmJiBkaXJDaGFuZ2UgP1xuICAgICAgICAgICAgICAnbmV4dCcgOlxuICAgICAgICAgICAgICAncHJldmlvdXMnLFxuICAgICAgICAgICAgICB0cnVlKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNzcyh0aGlzLmxpc3QsIHsgdXNlclNlbGVjdDogJycsIHBvaW50ZXJFdmVudHM6ICcnIH0pO1xuXG4gICAgICAgICAgdGhpcy5kcmFnID0gdGhpcy5wZXJjZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYXNTZWxlY3RhYmxlVGV4dChlbCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3NzKGVsLCAndXNlclNlbGVjdCcpICE9PSAnbm9uZScgJiZcbiAgICAgICAgdG9Ob2RlcyhlbC5jaGlsZE5vZGVzKS5zb21lKChlbCkgPT4gZWwubm9kZVR5cGUgPT09IDMgJiYgZWwudGV4dENvbnRlbnQudHJpbSgpKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyTmF2ID0ge1xuICAgICAgZGF0YToge1xuICAgICAgICBzZWxOYXY6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBuYXYoeyBzZWxOYXYgfSwgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQoc2VsTmF2LCAkZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbE5hdkl0ZW0oeyBhdHRySXRlbSB9KSB7XG4gICAgICAgICAgcmV0dXJuIGBbJHthdHRySXRlbX1dLFtkYXRhLSR7YXR0ckl0ZW19XWA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmF2SXRlbXMoXywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQkKHRoaXMuc2VsTmF2SXRlbSwgJGVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5hdiAmJiB0aGlzLmxlbmd0aCAhPT0gdGhpcy5uYXYuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sKFxuICAgICAgICAgICAgdGhpcy5uYXYsXG4gICAgICAgICAgICB0aGlzLnNsaWRlcy5cbiAgICAgICAgICAgIG1hcCgoXywgaSkgPT4gYDxsaSAke3RoaXMuYXR0ckl0ZW19PVwiJHtpfVwiPjxhIGhyZWY+PC9hPjwvbGk+YCkuXG4gICAgICAgICAgICBqb2luKCcnKSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5hdkl0ZW1zLmNvbmNhdCh0aGlzLm5hdikuZm9yRWFjaCgoZWwpID0+IGVsICYmIChlbC5oaWRkZW4gPSAhdGhpcy5tYXhJbmRleCkpO1xuXG4gICAgICAgICAgdGhpcy51cGRhdGVOYXYoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ11cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbE5hdkl0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvdyhkYXRhKGUuY3VycmVudCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtc2hvdycsXG4gICAgICAgIGhhbmRsZXI6ICd1cGRhdGVOYXYnXG4gICAgICB9XSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHVwZGF0ZU5hdigpIHtcbiAgICAgICAgICBjb25zdCBpID0gdGhpcy5nZXRWYWxpZEluZGV4KCk7XG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLm5hdkl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjbWQgPSBkYXRhKGVsLCB0aGlzLmF0dHJJdGVtKTtcblxuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzQWN0aXZlLCB0b051bWJlcihjbWQpID09PSBpKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAndWstaW52aXNpYmxlJyxcbiAgICAgICAgICAgIHRoaXMuZmluaXRlICYmIChcbiAgICAgICAgICAgIGNtZCA9PT0gJ3ByZXZpb3VzJyAmJiBpID09PSAwIHx8IGNtZCA9PT0gJ25leHQnICYmIGkgPj0gdGhpcy5tYXhJbmRleCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBTbGlkZXIgPSB7XG4gICAgICBtaXhpbnM6IFtTbGlkZXJBdXRvcGxheSwgU2xpZGVyRHJhZywgU2xpZGVyTmF2LCBSZXNpemVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHNBY3RpdmF0ZWQ6IEJvb2xlYW4sXG4gICAgICAgIGVhc2luZzogU3RyaW5nLFxuICAgICAgICBpbmRleDogTnVtYmVyLFxuICAgICAgICBmaW5pdGU6IEJvb2xlYW4sXG4gICAgICAgIHZlbG9jaXR5OiBOdW1iZXJcbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6ICgpID0+ICh7XG4gICAgICAgIGVhc2luZzogJ2Vhc2UnLFxuICAgICAgICBmaW5pdGU6IGZhbHNlLFxuICAgICAgICB2ZWxvY2l0eTogMSxcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIHByZXZJbmRleDogLTEsXG4gICAgICAgIHN0YWNrOiBbXSxcbiAgICAgICAgcGVyY2VudDogMCxcbiAgICAgICAgY2xzQWN0aXZlOiAndWstYWN0aXZlJyxcbiAgICAgICAgY2xzQWN0aXZhdGVkOiBmYWxzZSxcbiAgICAgICAgVHJhbnNpdGlvbmVyOiBmYWxzZSxcbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnM6IHt9XG4gICAgICB9KSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnByZXZJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KHRoaXMuJHByb3BzLmluZGV4KTtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnNsaWRlcywgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZHVyYXRpb24oeyB2ZWxvY2l0eSB9LCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gc3BlZWRVcCgkZWwub2Zmc2V0V2lkdGggLyB2ZWxvY2l0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdCh7IHNlbExpc3QgfSwgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQoc2VsTGlzdCwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXhJbmRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNsaWRlczoge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbih0aGlzLmxpc3QpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGgoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KGluZGV4LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgfHwgIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBzdGFjayB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBxdWV1ZUluZGV4ID0gZm9yY2UgPyAwIDogc3RhY2subGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhY2suc3BsaWNlKHF1ZXVlSW5kZXgsIDEpO1xuXG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2hvdyhzdGFjay5zaGlmdCgpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc3RhY2tbZm9yY2UgPyAndW5zaGlmdCcgOiAncHVzaCddKGluZGV4KTtcblxuICAgICAgICAgIGlmICghZm9yY2UgJiYgc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIuZm9yd2FyZChNYXRoLm1pbih0aGlzLmR1cmF0aW9uLCAyMDApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByZXZJbmRleCA9IHRoaXMuZ2V0SW5kZXgodGhpcy5pbmRleCk7XG4gICAgICAgICAgY29uc3QgcHJldiA9IGhhc0NsYXNzKHRoaXMuc2xpZGVzLCB0aGlzLmNsc0FjdGl2ZSkgJiYgdGhpcy5zbGlkZXNbcHJldkluZGV4XTtcbiAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmdldEluZGV4KGluZGV4LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5zbGlkZXNbbmV4dEluZGV4XTtcblxuICAgICAgICAgIGlmIChwcmV2ID09PSBuZXh0KSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGlyID0gZ2V0RGlyZWN0aW9uKGluZGV4LCBwcmV2SW5kZXgpO1xuICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gcHJldkluZGV4O1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgcHJldiAmJiAhdHJpZ2dlcihwcmV2LCAnYmVmb3JlaXRlbWhpZGUnLCBbdGhpc10pIHx8XG4gICAgICAgICAgIXRyaWdnZXIobmV4dCwgJ2JlZm9yZWl0ZW1zaG93JywgW3RoaXMsIHByZXZdKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5wcmV2SW5kZXg7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9zaG93KHByZXYsIG5leHQsIGZvcmNlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByZXYgJiYgdHJpZ2dlcihwcmV2LCAnaXRlbWhpZGRlbicsIFt0aGlzXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKG5leHQsICdpdGVtc2hvd24nLCBbdGhpc10pO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdyhzdGFjay5zaGlmdCgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcHJldiAmJiB0cmlnZ2VyKHByZXYsICdpdGVtaGlkZScsIFt0aGlzXSk7XG4gICAgICAgICAgdHJpZ2dlcihuZXh0LCAnaXRlbXNob3cnLCBbdGhpc10pO1xuXG4gICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5kZXgoaW5kZXggPSB0aGlzLmluZGV4LCBwcmV2ID0gdGhpcy5pbmRleCkge1xuICAgICAgICAgIHJldHVybiBjbGFtcChnZXRJbmRleChpbmRleCwgdGhpcy5zbGlkZXMsIHByZXYsIHRoaXMuZmluaXRlKSwgMCwgdGhpcy5tYXhJbmRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VmFsaWRJbmRleChpbmRleCA9IHRoaXMuaW5kZXgsIHByZXZJbmRleCA9IHRoaXMucHJldkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHByZXZJbmRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3cocHJldiwgbmV4dCwgZm9yY2UpIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIocHJldiwgbmV4dCwgdGhpcy5kaXIsIHtcbiAgICAgICAgICAgIGVhc2luZzogZm9yY2UgP1xuICAgICAgICAgICAgbmV4dC5vZmZzZXRXaWR0aCA8IDYwMCA/XG4gICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpJyAvKiBlYXNlT3V0UXVhZCAqLyA6XG4gICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAuMTY1LCAwLjg0LCAwLjQ0LCAxKScgLyogZWFzZU91dFF1YXJ0ICovIDpcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nLFxuICAgICAgICAgICAgLi4udGhpcy50cmFuc2l0aW9uT3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFmb3JjZSAmJiAhcHJldikge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0aGlzLnN0YWNrO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uZXJbbGVuZ3RoID4gMSA/ICdmb3J3YXJkJyA6ICdzaG93J10oXG4gICAgICAgICAgbGVuZ3RoID4gMSA/IE1hdGgubWluKHRoaXMuZHVyYXRpb24sIDc1ICsgNzUgLyAobGVuZ3RoIC0gMSkpIDogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aGlzLnBlcmNlbnQpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldERpc3RhbmNlKHByZXYsIG5leHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNpdGlvbmVyKHByZXYsIHByZXYgIT09IG5leHQgJiYgbmV4dCkuZ2V0RGlzdGFuY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdHJhbnNsYXRlKHBlcmNlbnQsIHByZXYgPSB0aGlzLnByZXZJbmRleCwgbmV4dCA9IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uZXIgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIocHJldiAhPT0gbmV4dCA/IHByZXYgOiBmYWxzZSwgbmV4dCk7XG4gICAgICAgICAgdHJhbnNpdGlvbmVyLnRyYW5zbGF0ZShwZXJjZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRUcmFuc2l0aW9uZXIoXG4gICAgICAgIHByZXYgPSB0aGlzLnByZXZJbmRleCxcbiAgICAgICAgbmV4dCA9IHRoaXMuaW5kZXgsXG4gICAgICAgIGRpciA9IHRoaXMuZGlyIHx8IDEsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25PcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlRyYW5zaXRpb25lcihcbiAgICAgICAgICBpc051bWJlcihwcmV2KSA/IHRoaXMuc2xpZGVzW3ByZXZdIDogcHJldixcbiAgICAgICAgICBpc051bWJlcihuZXh0KSA/IHRoaXMuc2xpZGVzW25leHRdIDogbmV4dCxcbiAgICAgICAgICBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpLFxuICAgICAgICAgIG9wdGlvbnMpO1xuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKGluZGV4LCBwcmV2SW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gJ25leHQnID8gMSA6IGluZGV4ID09PSAncHJldmlvdXMnID8gLTEgOiBpbmRleCA8IHByZXZJbmRleCA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGVlZFVwKHgpIHtcbiAgICAgIHJldHVybiAwLjUgKiB4ICsgMzAwOyAvLyBwYXJhYm9sYSB0aHJvdWdoICg0MDAsNTAwOyA2MDAsNjAwOyAxODAwLDEyMDApXG4gICAgfVxuXG4gICAgdmFyIFNsaWRlc2hvdyA9IHtcbiAgICAgIG1peGluczogW1NsaWRlcl0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGFuaW1hdGlvbjogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFuaW1hdGlvbjogJ3NsaWRlJyxcbiAgICAgICAgY2xzQWN0aXZhdGVkOiAndWstdHJhbnNpdGlvbi1hY3RpdmUnLFxuICAgICAgICBBbmltYXRpb25zOiBBbmltYXRpb25zJDIsXG4gICAgICAgIFRyYW5zaXRpb25lcjogVHJhbnNpdGlvbmVyJDFcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGFuaW1hdGlvbih7IGFuaW1hdGlvbiwgQW5pbWF0aW9ucyB9KSB7XG4gICAgICAgICAgcmV0dXJuIHsgLi4uKEFuaW1hdGlvbnNbYW5pbWF0aW9uXSB8fCBBbmltYXRpb25zLnNsaWRlKSwgbmFtZTogYW5pbWF0aW9uIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgYW5pbWF0aW9uOiB0aGlzLmFuaW1hdGlvbiB9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgYmVmb3JlaXRlbXNob3coeyB0YXJnZXQgfSkge1xuICAgICAgICAgIGFkZENsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1zaG93bih7IHRhcmdldCB9KSB7XG4gICAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0FjdGl2YXRlZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbWhpZGRlbih7IHRhcmdldCB9KSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0FjdGl2ZSwgdGhpcy5jbHNBY3RpdmF0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBMaWdodGJveFBhbmVsID0ge1xuICAgICAgbWl4aW5zOiBbQ29udGFpbmVyLCBNb2RhbCwgVG9nZ2xhYmxlLCBTbGlkZXNob3ddLFxuXG4gICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkZWxheUNvbnRyb2xzOiBOdW1iZXIsXG4gICAgICAgIHByZWxvYWQ6IE51bWJlcixcbiAgICAgICAgdmlkZW9BdXRvcGxheTogQm9vbGVhbixcbiAgICAgICAgdGVtcGxhdGU6IFN0cmluZ1xuICAgICAgfSxcblxuICAgICAgZGF0YTogKCkgPT4gKHtcbiAgICAgICAgcHJlbG9hZDogMSxcbiAgICAgICAgdmlkZW9BdXRvcGxheTogZmFsc2UsXG4gICAgICAgIGRlbGF5Q29udHJvbHM6IDMwMDAsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgY2xzOiAndWstb3BlbicsXG4gICAgICAgIGNsc1BhZ2U6ICd1ay1saWdodGJveC1wYWdlJyxcbiAgICAgICAgc2VsTGlzdDogJy51ay1saWdodGJveC1pdGVtcycsXG4gICAgICAgIGF0dHJJdGVtOiAndWstbGlnaHRib3gtaXRlbScsXG4gICAgICAgIHNlbENsb3NlOiAnLnVrLWNsb3NlLWxhcmdlJyxcbiAgICAgICAgc2VsQ2FwdGlvbjogJy51ay1saWdodGJveC1jYXB0aW9uJyxcbiAgICAgICAgcGF1c2VPbkhvdmVyOiBmYWxzZSxcbiAgICAgICAgdmVsb2NpdHk6IDIsXG4gICAgICAgIEFuaW1hdGlvbnM6IEFuaW1hdGlvbnMkMSxcbiAgICAgICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidWstbGlnaHRib3ggdWstb3ZlcmZsb3ctaGlkZGVuXCI+IDx1bCBjbGFzcz1cInVrLWxpZ2h0Ym94LWl0ZW1zXCI+PC91bD4gPGRpdiBjbGFzcz1cInVrLWxpZ2h0Ym94LXRvb2xiYXIgdWstcG9zaXRpb24tdG9wIHVrLXRleHQtcmlnaHQgdWstdHJhbnNpdGlvbi1zbGlkZS10b3AgdWstdHJhbnNpdGlvbi1vcGFxdWVcIj4gPGJ1dHRvbiBjbGFzcz1cInVrLWxpZ2h0Ym94LXRvb2xiYXItaWNvbiB1ay1jbG9zZS1sYXJnZVwiIHR5cGU9XCJidXR0b25cIiB1ay1jbG9zZT48L2J1dHRvbj4gPC9kaXY+IDxhIGNsYXNzPVwidWstbGlnaHRib3gtYnV0dG9uIHVrLXBvc2l0aW9uLWNlbnRlci1sZWZ0IHVrLXBvc2l0aW9uLW1lZGl1bSB1ay10cmFuc2l0aW9uLWZhZGVcIiBocmVmIHVrLXNsaWRlbmF2LXByZXZpb3VzIHVrLWxpZ2h0Ym94LWl0ZW09XCJwcmV2aW91c1wiPjwvYT4gPGEgY2xhc3M9XCJ1ay1saWdodGJveC1idXR0b24gdWstcG9zaXRpb24tY2VudGVyLXJpZ2h0IHVrLXBvc2l0aW9uLW1lZGl1bSB1ay10cmFuc2l0aW9uLWZhZGVcIiBocmVmIHVrLXNsaWRlbmF2LW5leHQgdWstbGlnaHRib3gtaXRlbT1cIm5leHRcIj48L2E+IDxkaXYgY2xhc3M9XCJ1ay1saWdodGJveC10b29sYmFyIHVrLWxpZ2h0Ym94LWNhcHRpb24gdWstcG9zaXRpb24tYm90dG9tIHVrLXRleHQtY2VudGVyIHVrLXRyYW5zaXRpb24tc2xpZGUtYm90dG9tIHVrLXRyYW5zaXRpb24tb3BhcXVlXCI+PC9kaXY+IDwvZGl2PmBcbiAgICAgIH0pLFxuXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICBjb25zdCAkZWwgPSAkKHRoaXMudGVtcGxhdGUpO1xuICAgICAgICBjb25zdCBsaXN0ID0gJCh0aGlzLnNlbExpc3QsICRlbCk7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoKSA9PiBhcHBlbmQobGlzdCwgJzxsaT4nKSk7XG5cbiAgICAgICAgdGhpcy4kbW91bnQoYXBwZW5kKHRoaXMuY29udGFpbmVyLCAkZWwpKTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNhcHRpb24oeyBzZWxDYXB0aW9uIH0sICRlbCkge1xuICAgICAgICAgIHJldHVybiAkKHNlbENhcHRpb24sICRlbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBgJHtwb2ludGVyTW92ZSQxfSAke3BvaW50ZXJEb3duJDF9IGtleWRvd25gLFxuXG4gICAgICAgIGhhbmRsZXI6ICdzaG93Q29udHJvbHMnXG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gYCR7dGhpcy5zZWxMaXN0fSA+ICpgO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3duJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5zaG93Q29udHJvbHMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuaGlkZUNvbnRyb2xzKCk7XG5cbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnNsaWRlcywgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RvcCh0aGlzLnNsaWRlcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuJGRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2tleXVwJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzVG9nZ2xlZCh0aGlzLiRlbCkgfHwgIXRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgIHRoaXMuc2hvdygncHJldmlvdXMnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICB0aGlzLnNob3coJ25leHQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7fVxuXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2JlZm9yZWl0ZW1zaG93JyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUsIGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gQW5pbWF0aW9ucyQxWydzY2FsZSddO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGUudGFyZ2V0LCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICAgICAgdGhpcy5zdGFjay5zcGxpY2UoMSwgMCwgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW1zaG93JyxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGh0bWwodGhpcy5jYXB0aW9uLCB0aGlzLmdldEl0ZW0oKS5jYXB0aW9uIHx8ICcnKTtcblxuICAgICAgICAgIGZvciAobGV0IGogPSAtdGhpcy5wcmVsb2FkOyBqIDw9IHRoaXMucHJlbG9hZDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJdGVtKHRoaXMuaW5kZXggKyBqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW1zaG93bicsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IHRoaXMuJHByb3BzLmRyYWdnYWJsZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbWxvYWQnLFxuXG4gICAgICAgIGFzeW5jIGhhbmRsZXIoXywgaXRlbSkge1xuICAgICAgICAgIGNvbnN0IHsgc291cmNlOiBzcmMsIHR5cGUsIGFsdCA9ICcnLCBwb3N0ZXIsIGF0dHJzID0ge30gfSA9IGl0ZW07XG5cbiAgICAgICAgICB0aGlzLnNldEl0ZW0oaXRlbSwgJzxzcGFuIHVrLXNwaW5uZXI+PC9zcGFuPicpO1xuXG4gICAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgICBjb25zdCBpZnJhbWVBdHRycyA9IHtcbiAgICAgICAgICAgIGFsbG93ZnVsbHNjcmVlbjogJycsXG4gICAgICAgICAgICBzdHlsZTogJ21heC13aWR0aDogMTAwJTsgYm94LXNpemluZzogYm9yZGVyLWJveDsnLFxuICAgICAgICAgICAgJ3VrLXJlc3BvbnNpdmUnOiAnJyxcbiAgICAgICAgICAgICd1ay12aWRlbyc6IGAke3RoaXMudmlkZW9BdXRvcGxheX1gXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEltYWdlXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGUgPT09ICdpbWFnZScgfHxcbiAgICAgICAgICBzcmMubWF0Y2goL1xcLihhdmlmfGpwZT9nfGpmaWZ8YT9wbmd8Z2lmfHN2Z3x3ZWJwKSgkfFxcPykvaSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBhd2FpdCBnZXRJbWFnZShzcmMsIGF0dHJzLnNyY3NldCwgYXR0cnMuc2l6ZSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0SXRlbShpdGVtLCBjcmVhdGVFbCgnaW1nJywgeyBzcmMsIHdpZHRoLCBoZWlnaHQsIGFsdCwgLi4uYXR0cnMgfSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldEVycm9yKGl0ZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWaWRlb1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJyB8fCBzcmMubWF0Y2goL1xcLihtcDR8d2VibXxvZ3YpKCR8XFw/KS9pKSkge1xuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBjcmVhdGVFbCgndmlkZW8nLCB7XG4gICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgcG9zdGVyLFxuICAgICAgICAgICAgICBjb250cm9sczogJycsXG4gICAgICAgICAgICAgIHBsYXlzaW5saW5lOiAnJyxcbiAgICAgICAgICAgICAgJ3VrLXZpZGVvJzogYCR7dGhpcy52aWRlb0F1dG9wbGF5fWBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvbih2aWRlbywgJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgICBhdHRyKHZpZGVvLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHZpZGVvLnZpZGVvV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWRlby52aWRlb0hlaWdodCxcbiAgICAgICAgICAgICAgICAuLi5hdHRyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKGl0ZW0sIHZpZGVvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb24odmlkZW8sICdlcnJvcicsICgpID0+IHRoaXMuc2V0RXJyb3IoaXRlbSkpO1xuXG4gICAgICAgICAgICAvLyBJZnJhbWVcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpZnJhbWUnIHx8IHNyYy5tYXRjaCgvXFwuKGh0bWx8cGhwKSgkfFxcPykvaSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SXRlbShcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBjcmVhdGVFbCgnaWZyYW1lJywge1xuICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgIGFsbG93ZnVsbHNjcmVlbjogJycsXG4gICAgICAgICAgICAgIGNsYXNzOiAndWstbGlnaHRib3gtaWZyYW1lJyxcbiAgICAgICAgICAgICAgLi4uYXR0cnNcbiAgICAgICAgICAgIH0pKTtcblxuXG4gICAgICAgICAgICAvLyBZb3VUdWJlXG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBtYXRjaGVzID0gc3JjLm1hdGNoKFxuICAgICAgICAgIC9cXC9cXC8oPzouKj95b3V0dWJlKC1ub2Nvb2tpZSk/XFwuLio/Wz8mXXY9fHlvdXR1XFwuYmVcXC8pKFtcXHctXXsxMX0pWyY/XT8oLiopPy8pKVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRJdGVtKFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGNyZWF0ZUVsKCdpZnJhbWUnLCB7XG4gICAgICAgICAgICAgIHNyYzogYGh0dHBzOi8vd3d3LnlvdXR1YmUke21hdGNoZXNbMV0gfHwgJyd9LmNvbS9lbWJlZC8ke21hdGNoZXNbMl19JHtcbiAgICAgICAgICBtYXRjaGVzWzNdID8gYD8ke21hdGNoZXNbM119YCA6ICcnXG4gICAgICAgICAgfWAsXG4gICAgICAgICAgICAgIHdpZHRoOiAxOTIwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDEwODAsXG4gICAgICAgICAgICAgIC4uLmlmcmFtZUF0dHJzLFxuICAgICAgICAgICAgICAuLi5hdHRyc1xuICAgICAgICAgICAgfSkpO1xuXG5cbiAgICAgICAgICAgIC8vIFZpbWVvXG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzID0gc3JjLm1hdGNoKC9cXC9cXC8uKj92aW1lb1xcLlthLXpdK1xcLyhcXGQrKVsmP10/KC4qKT8vKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBhd2FpdCAoXG4gICAgICAgICAgICAgIGF3YWl0IGZldGNoKFxuICAgICAgICAgICAgICBgaHR0cHM6Ly92aW1lby5jb20vYXBpL29lbWJlZC5qc29uP21heHdpZHRoPTE5MjAmdXJsPSR7ZW5jb2RlVVJJKFxuICAgICAgICAgIHNyYylcbiAgICAgICAgICB9YCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCdcbiAgICAgICAgICAgICAgfSkpLlxuXG4gICAgICAgICAgICAgIGpzb24oKTtcblxuICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgIGNyZWF0ZUVsKCdpZnJhbWUnLCB7XG4gICAgICAgICAgICAgICAgc3JjOiBgaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLyR7bWF0Y2hlc1sxXX0ke1xuICAgICAgICAgICAgbWF0Y2hlc1syXSA/IGA/JHttYXRjaGVzWzJdfWAgOiAnJ1xuICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIC4uLmlmcmFtZUF0dHJzLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJzXG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldEVycm9yKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfV0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBsb2FkSXRlbShpbmRleCA9IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5nZXRJdGVtKGluZGV4KTtcblxuICAgICAgICAgIGlmICghdGhpcy5nZXRTbGlkZShpdGVtKS5jaGlsZEVsZW1lbnRDb3VudCkge1xuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2l0ZW1sb2FkJywgW2l0ZW1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SXRlbShpbmRleCA9IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tnZXRJbmRleChpbmRleCwgdGhpcy5zbGlkZXMpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRJdGVtKGl0ZW0sIGNvbnRlbnQpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnaXRlbWxvYWRlZCcsIFt0aGlzLCBodG1sKHRoaXMuZ2V0U2xpZGUoaXRlbSksIGNvbnRlbnQpXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2xpZGUoaXRlbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWRlc1t0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSldO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVycm9yKGl0ZW0pIHtcbiAgICAgICAgICB0aGlzLnNldEl0ZW0oaXRlbSwgJzxzcGFuIHVrLWljb249XCJpY29uOiBib2x0OyByYXRpbzogMlwiPjwvc3Bhbj4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93Q29udHJvbHMoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29udHJvbHNUaW1lcik7XG4gICAgICAgICAgdGhpcy5jb250cm9sc1RpbWVyID0gc2V0VGltZW91dCh0aGlzLmhpZGVDb250cm9scywgdGhpcy5kZWxheUNvbnRyb2xzKTtcblxuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAndWstYWN0aXZlJywgJ3VrLXRyYW5zaXRpb24tYWN0aXZlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZUNvbnRyb2xzKCkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCAndWstYWN0aXZlJywgJ3VrLXRyYW5zaXRpb24tYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWwodGFnLCBhdHRycykge1xuICAgICAgY29uc3QgZWwgPSBmcmFnbWVudChgPCR7dGFnfT5gKTtcbiAgICAgIGF0dHIoZWwsIGF0dHJzKTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICB2YXIgbGlnaHRib3ggPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsJDEsXG5cbiAgICAgIHByb3BzOiB7IHRvZ2dsZTogU3RyaW5nIH0sXG5cbiAgICAgIGRhdGE6IHsgdG9nZ2xlOiAnYScgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdG9nZ2xlczoge1xuICAgICAgICAgIGdldCh7IHRvZ2dsZSB9LCAkZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkJCh0b2dnbGUsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIGAke3RoaXMudG9nZ2xlfTpub3QoLnVrLWRpc2FibGVkKWA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvdyhlLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBpdGVtcyA9IHVuaXF1ZUJ5KHRoaXMudG9nZ2xlcy5tYXAodG9JdGVtKSwgJ3NvdXJjZScpO1xuXG4gICAgICAgICAgaWYgKGlzRWxlbWVudChpbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlIH0gPSB0b0l0ZW0oaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSBmaW5kSW5kZXgoaXRlbXMsICh7IHNvdXJjZTogc3JjIH0pID0+IHNvdXJjZSA9PT0gc3JjKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBhbmVsID0gdGhpcy5wYW5lbCB8fCB0aGlzLiRjcmVhdGUoJ2xpZ2h0Ym94UGFuZWwnLCB7IC4uLnRoaXMuJHByb3BzLCBpdGVtcyB9KTtcblxuICAgICAgICAgIG9uKHRoaXMucGFuZWwuJGVsLCAnaGlkZGVuJywgKCkgPT4gdGhpcy5wYW5lbCA9IG51bGwpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWwuc2hvdyhpbmRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZSgpIHt2YXIgX3RoaXMkcGFuZWw7XG4gICAgICAgICAgcmV0dXJuIChfdGhpcyRwYW5lbCA9IHRoaXMucGFuZWwpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwYW5lbC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCQxKFVJa2l0LCBMaWdodGJveCkge1xuICAgICAgaWYgKCFVSWtpdC5saWdodGJveFBhbmVsKSB7XG4gICAgICAgIFVJa2l0LmNvbXBvbmVudCgnbGlnaHRib3hQYW5lbCcsIExpZ2h0Ym94UGFuZWwpO1xuICAgICAgfVxuXG4gICAgICBhc3NpZ24oTGlnaHRib3gucHJvcHMsIFVJa2l0LmNvbXBvbmVudCgnbGlnaHRib3hQYW5lbCcpLm9wdGlvbnMucHJvcHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSXRlbShlbCkge1xuICAgICAgY29uc3QgaXRlbSA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgWydocmVmJywgJ2NhcHRpb24nLCAndHlwZScsICdwb3N0ZXInLCAnYWx0JywgJ2F0dHJzJ10pIHtcbiAgICAgICAgaXRlbVthdHRyID09PSAnaHJlZicgPyAnc291cmNlJyA6IGF0dHJdID0gZGF0YShlbCwgYXR0cik7XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uYXR0cnMgPSBwYXJzZU9wdGlvbnMoaXRlbS5hdHRycyk7XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIHZhciBub3RpZmljYXRpb24gPSB7XG4gICAgICBtaXhpbnM6IFtDb250YWluZXJdLFxuXG4gICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gICAgICBhcmdzOiBbJ21lc3NhZ2UnLCAnc3RhdHVzJ10sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWVzc2FnZTogJycsXG4gICAgICAgIHN0YXR1czogJycsXG4gICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgICBwb3M6ICd0b3AtY2VudGVyJyxcbiAgICAgICAgY2xzQ29udGFpbmVyOiAndWstbm90aWZpY2F0aW9uJyxcbiAgICAgICAgY2xzQ2xvc2U6ICd1ay1ub3RpZmljYXRpb24tY2xvc2UnLFxuICAgICAgICBjbHNNc2c6ICd1ay1ub3RpZmljYXRpb24tbWVzc2FnZSdcbiAgICAgIH0sXG5cbiAgICAgIGluc3RhbGwsXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIG1hcmdpblByb3AoeyBwb3MgfSkge1xuICAgICAgICAgIHJldHVybiBgbWFyZ2luJHtzdGFydHNXaXRoKHBvcywgJ3RvcCcpID8gJ1RvcCcgOiAnQm90dG9tJ31gO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0UHJvcHMoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgb3BhY2l0eTogMCwgW3RoaXMubWFyZ2luUHJvcF06IC10aGlzLiRlbC5vZmZzZXRIZWlnaHQgfTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID1cbiAgICAgICAgJChgLiR7dGhpcy5jbHNDb250YWluZXJ9LSR7dGhpcy5wb3N9YCwgdGhpcy5jb250YWluZXIpIHx8XG4gICAgICAgIGFwcGVuZChcbiAgICAgICAgdGhpcy5jb250YWluZXIsXG4gICAgICAgIGA8ZGl2IGNsYXNzPVwiJHt0aGlzLmNsc0NvbnRhaW5lcn0gJHt0aGlzLmNsc0NvbnRhaW5lcn0tJHt0aGlzLnBvc31cIiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrXCI+PC9kaXY+YCk7XG5cblxuICAgICAgICB0aGlzLiRtb3VudChcbiAgICAgICAgYXBwZW5kKFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGA8ZGl2IGNsYXNzPVwiJHt0aGlzLmNsc01zZ30ke1xuICAgIHRoaXMuc3RhdHVzID8gYCAke3RoaXMuY2xzTXNnfS0ke3RoaXMuc3RhdHVzfWAgOiAnJ1xuICAgIH1cIiByb2xlPVwiYWxlcnRcIj4gPGEgaHJlZiBjbGFzcz1cIiR7dGhpcy5jbHNDbG9zZX1cIiBkYXRhLXVrLWNsb3NlPjwvYT4gPGRpdj4ke3RoaXMubWVzc2FnZX08L2Rpdj4gPC9kaXY+YCkpO1xuXG5cbiAgICAgIH0sXG5cbiAgICAgIGFzeW5jIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgY29uc3QgbWFyZ2luID0gdG9GbG9hdChjc3ModGhpcy4kZWwsIHRoaXMubWFyZ2luUHJvcCkpO1xuICAgICAgICBhd2FpdCBUcmFuc2l0aW9uLnN0YXJ0KGNzcyh0aGlzLiRlbCwgdGhpcy5zdGFydFByb3BzKSwge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgW3RoaXMubWFyZ2luUHJvcF06IG1hcmdpblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5jbG9zZSwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGNsaWNrKGUpIHtcbiAgICAgICAgICBpZiAoY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZj1cIiNcIl0sYVtocmVmPVwiXCJdJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFtwb2ludGVyRW50ZXJdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFtwb2ludGVyTGVhdmVdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2UsIHRoaXMudGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGNsb3NlKGltbWVkaWF0ZSkge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZUZuID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnQoZWwpO1xuXG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2xvc2UnLCBbdGhpc10pO1xuICAgICAgICAgICAgcmVtb3ZlJDEoZWwpO1xuXG4gICAgICAgICAgICBpZiAoIShjb250YWluZXIgIT0gbnVsbCAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSkge1xuICAgICAgICAgICAgICByZW1vdmUkMShjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICBhd2FpdCBUcmFuc2l0aW9uLnN0YXJ0KHRoaXMuJGVsLCB0aGlzLnN0YXJ0UHJvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbW92ZUZuKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKFVJa2l0KSB7XG4gICAgICBVSWtpdC5ub3RpZmljYXRpb24uY2xvc2VBbGwgPSBmdW5jdGlvbiAoZ3JvdXAsIGltbWVkaWF0ZSkge1xuICAgICAgICBhcHBseShkb2N1bWVudC5ib2R5LCAoZWwpID0+IHtcbiAgICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBVSWtpdC5nZXRDb21wb25lbnQoZWwsICdub3RpZmljYXRpb24nKTtcbiAgICAgICAgICBpZiAobm90aWZpY2F0aW9uICYmICghZ3JvdXAgfHwgZ3JvdXAgPT09IG5vdGlmaWNhdGlvbi5ncm91cCkpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5jbG9zZShpbW1lZGlhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgeDogdHJhbnNmb3JtRm4sXG4gICAgICB5OiB0cmFuc2Zvcm1GbixcbiAgICAgIHJvdGF0ZTogdHJhbnNmb3JtRm4sXG4gICAgICBzY2FsZTogdHJhbnNmb3JtRm4sXG4gICAgICBjb2xvcjogY29sb3JGbixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JGbixcbiAgICAgIGJvcmRlckNvbG9yOiBjb2xvckZuLFxuICAgICAgYmx1cjogZmlsdGVyRm4sXG4gICAgICBodWU6IGZpbHRlckZuLFxuICAgICAgZm9wYWNpdHk6IGZpbHRlckZuLFxuICAgICAgZ3JheXNjYWxlOiBmaWx0ZXJGbixcbiAgICAgIGludmVydDogZmlsdGVyRm4sXG4gICAgICBzYXR1cmF0ZTogZmlsdGVyRm4sXG4gICAgICBzZXBpYTogZmlsdGVyRm4sXG4gICAgICBvcGFjaXR5OiBjc3NQcm9wRm4sXG4gICAgICBzdHJva2U6IHN0cm9rZUZuLFxuICAgICAgYmd4OiBiYWNrZ3JvdW5kRm4sXG4gICAgICBiZ3k6IGJhY2tncm91bmRGblxuICAgIH07XG5cbiAgICBjb25zdCB7IGtleXMgfSA9IE9iamVjdDtcblxuICAgIHZhciBQYXJhbGxheCA9IHtcbiAgICAgIG1peGluczogW01lZGlhXSxcblxuICAgICAgcHJvcHM6IGZpbGxPYmplY3Qoa2V5cyhwcm9wcyksICdsaXN0JyksXG5cbiAgICAgIGRhdGE6IGZpbGxPYmplY3Qoa2V5cyhwcm9wcyksIHVuZGVmaW5lZCksXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHByb3BzKHByb3BlcnRpZXMsICRlbCkge1xuICAgICAgICAgIGNvbnN0IHN0b3BzID0ge307XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIHByb3BzICYmICFpc1VuZGVmaW5lZChwcm9wZXJ0aWVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICBzdG9wc1twcm9wXSA9IHByb3BlcnRpZXNbcHJvcF0uc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHN0b3BzKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBwcm9wc1twcm9wXShwcm9wLCAkZWwsIHN0b3BzW3Byb3BdLCBzdG9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBsb2FkKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdGhpcy5nZXRDc3MoMCkpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgcHJvcCwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDc3MocGVyY2VudCkge1xuICAgICAgICAgIGNvbnN0IGNzcyA9IHsgdHJhbnNmb3JtOiAnJywgZmlsdGVyOiAnJyB9O1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzLnByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzW3Byb3BdKGNzcywgcGVyY2VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzcy53aWxsQ2hhbmdlID0gT2JqZWN0LmtleXMoY3NzKS5cbiAgICAgICAgICBmaWx0ZXIoKGtleSkgPT4gY3NzW2tleV0gIT09ICcnKS5cbiAgICAgICAgICBqb2luKCcsJyk7XG4gICAgICAgICAgcmV0dXJuIGNzcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Gbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGxldCB1bml0ID0gZ2V0VW5pdChzdG9wcykgfHwgeyB4OiAncHgnLCB5OiAncHgnLCByb3RhdGU6ICdkZWcnIH1bcHJvcF0gfHwgJyc7XG4gICAgICBsZXQgdHJhbnNmb3JtRm47XG5cbiAgICAgIGlmIChwcm9wID09PSAneCcgfHwgcHJvcCA9PT0gJ3knKSB7XG4gICAgICAgIHByb3AgPSBgdHJhbnNsYXRlJHt1Y2ZpcnN0KHByb3ApfWA7XG4gICAgICAgIHRyYW5zZm9ybUZuID0gKHN0b3ApID0+IHRvRmxvYXQodG9GbG9hdChzdG9wKS50b0ZpeGVkKHVuaXQgPT09ICdweCcgPyAwIDogNikpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnc2NhbGUnKSB7XG4gICAgICAgIHVuaXQgPSAnJztcbiAgICAgICAgdHJhbnNmb3JtRm4gPSAoc3RvcCkgPT4gZ2V0VW5pdChbc3RvcF0pID8gdG9QeChzdG9wLCAnd2lkdGgnLCBlbCwgdHJ1ZSkgLyBlbC5vZmZzZXRXaWR0aCA6IHN0b3A7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdChwcm9wID09PSAnc2NhbGUnID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMsIHRyYW5zZm9ybUZuKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY3NzLnRyYW5zZm9ybSArPSBgICR7cHJvcH0oJHtnZXRWYWx1ZShzdG9wcywgcGVyY2VudCl9JHt1bml0fSlgO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xvckZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KGdldENzc1ZhbHVlKGVsLCBwcm9wLCAnJykpO1xuICAgICAgfVxuXG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMsIChzdG9wKSA9PiBwYXJzZUNvbG9yKGVsLCBzdG9wKSk7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IFtzdGFydCwgZW5kLCBwXSA9IGdldFN0b3Aoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0YXJ0LlxuICAgICAgICBtYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgdmFsdWUgKz0gcCAqIChlbmRbaV0gLSB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGkgPT09IDMgPyB0b0Zsb2F0KHZhbHVlKSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgIH0pLlxuICAgICAgICBqb2luKCcsJyk7XG4gICAgICAgIGNzc1twcm9wXSA9IGByZ2JhKCR7dmFsdWV9KWA7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29sb3IoZWwsIGNvbG9yKSB7XG4gICAgICByZXR1cm4gZ2V0Q3NzVmFsdWUoZWwsICdjb2xvcicsIGNvbG9yKS5cbiAgICAgIHNwbGl0KC9bKCksXS9nKS5cbiAgICAgIHNsaWNlKDEsIC0xKS5cbiAgICAgIGNvbmNhdCgxKS5cbiAgICAgIHNsaWNlKDAsIDQpLlxuICAgICAgbWFwKHRvRmxvYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KDApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bml0ID0gZ2V0VW5pdChzdG9wcykgfHwgeyBibHVyOiAncHgnLCBodWU6ICdkZWcnIH1bcHJvcF0gfHwgJyUnO1xuICAgICAgcHJvcCA9IHsgZm9wYWNpdHk6ICdvcGFjaXR5JywgaHVlOiAnaHVlLXJvdGF0ZScgfVtwcm9wXSB8fCBwcm9wO1xuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCk7XG4gICAgICAgIGNzcy5maWx0ZXIgKz0gYCAke3Byb3B9KCR7dmFsdWUgKyB1bml0fSlgO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3NQcm9wRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoZ2V0Q3NzVmFsdWUoZWwsIHByb3AsICcnKSk7XG4gICAgICB9XG5cbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcyk7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNzc1twcm9wXSA9IGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Ryb2tlRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVuaXQgPSBnZXRVbml0KHN0b3BzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE1heFBhdGhMZW5ndGgoZWwpO1xuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzLnJldmVyc2UoKSwgKHN0b3ApID0+IHtcbiAgICAgICAgc3RvcCA9IHRvRmxvYXQoc3RvcCk7XG4gICAgICAgIHJldHVybiB1bml0ID09PSAnJScgPyBzdG9wICogbGVuZ3RoIC8gMTAwIDogc3RvcDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXN0b3BzLnNvbWUoKFt2YWx1ZV0pID0+IHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgIH1cblxuICAgICAgY3NzKGVsLCAnc3Ryb2tlRGFzaGFycmF5JywgbGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY3NzLnN0cm9rZURhc2hvZmZzZXQgPSBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhY2tncm91bmRGbihwcm9wLCBlbCwgc3RvcHMsIHByb3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHIgPSBwcm9wID09PSAnYmd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgIHByb3BzW3Byb3BdID0gcGFyc2VTdG9wcyhzdG9wcywgKHN0b3ApID0+IHRvUHgoc3RvcCwgYXR0ciwgZWwpKTtcblxuICAgICAgY29uc3QgYmdQcm9wcyA9IFsnYmd4JywgJ2JneSddLmZpbHRlcigocHJvcCkgPT4gcHJvcCBpbiBwcm9wcyk7XG4gICAgICBpZiAoYmdQcm9wcy5sZW5ndGggPT09IDIgJiYgcHJvcCA9PT0gJ2JneCcpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRDc3NWYWx1ZShlbCwgJ2JhY2tncm91bmRTaXplJywgJycpID09PSAnY292ZXInKSB7XG4gICAgICAgIHJldHVybiBiYWNrZ3JvdW5kQ292ZXJGbihwcm9wLCBlbCwgc3RvcHMsIHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcG9zaXRpb25zID0ge307XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYmdQcm9wcykge1xuICAgICAgICBwb3NpdGlvbnNbcHJvcF0gPSBnZXRCYWNrZ3JvdW5kUG9zKGVsLCBwcm9wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldEJhY2tncm91bmRQb3NGbihiZ1Byb3BzLCBwb3NpdGlvbnMsIHByb3BzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYWNrZ3JvdW5kQ292ZXJGbihwcm9wLCBlbCwgc3RvcHMsIHByb3BzKSB7XG4gICAgICBjb25zdCBkaW1JbWFnZSA9IGdldEJhY2tncm91bmRJbWFnZURpbWVuc2lvbnMoZWwpO1xuXG4gICAgICBpZiAoIWRpbUltYWdlLndpZHRoKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaW1FbCA9IHtcbiAgICAgICAgd2lkdGg6IGVsLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsLm9mZnNldEhlaWdodFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYmdQcm9wcyA9IFsnYmd4JywgJ2JneSddLmZpbHRlcigocHJvcCkgPT4gcHJvcCBpbiBwcm9wcyk7XG5cbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGJnUHJvcHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJvcHNbcHJvcF0ubWFwKChbdmFsdWVdKSA9PiB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGRvd24gPSB2YWx1ZXMuaW5kZXhPZihtaW4pIDwgdmFsdWVzLmluZGV4T2YobWF4KTtcbiAgICAgICAgY29uc3QgZGlmZiA9IG1heCAtIG1pbjtcblxuICAgICAgICBwb3NpdGlvbnNbcHJvcF0gPSBgJHsoZG93biA/IC1kaWZmIDogMCkgLSAoZG93biA/IG1pbiA6IG1heCl9cHhgO1xuICAgICAgICBkaW1FbFtwcm9wID09PSAnYmd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJ10gKz0gZGlmZjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGltID0gRGltZW5zaW9ucy5jb3ZlcihkaW1JbWFnZSwgZGltRWwpO1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYmdQcm9wcykge1xuICAgICAgICBjb25zdCBhdHRyID0gcHJvcCA9PT0gJ2JneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gZGltW2F0dHJdIC0gZGltRWxbYXR0cl07XG4gICAgICAgIHBvc2l0aW9uc1twcm9wXSA9IGBtYXgoJHtnZXRCYWNrZ3JvdW5kUG9zKGVsLCBwcm9wKX0sLSR7b3ZlcmZsb3d9cHgpICsgJHtwb3NpdGlvbnNbcHJvcF19YDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm4gPSBzZXRCYWNrZ3JvdW5kUG9zRm4oYmdQcm9wcywgcG9zaXRpb25zLCBwcm9wcyk7XG4gICAgICByZXR1cm4gKGNzcywgcGVyY2VudCkgPT4ge1xuICAgICAgICBmbihjc3MsIHBlcmNlbnQpO1xuICAgICAgICBjc3MuYmFja2dyb3VuZFNpemUgPSBgJHtkaW0ud2lkdGh9cHggJHtkaW0uaGVpZ2h0fXB4YDtcbiAgICAgICAgY3NzLmJhY2tncm91bmRSZXBlYXQgPSAnbm8tcmVwZWF0JztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvcyhlbCwgcHJvcCkge1xuICAgICAgcmV0dXJuIGdldENzc1ZhbHVlKGVsLCBgYmFja2dyb3VuZC1wb3NpdGlvbi0ke3Byb3Auc3Vic3RyKC0xKX1gLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QmFja2dyb3VuZFBvc0ZuKGJnUHJvcHMsIHBvc2l0aW9ucywgcHJvcHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoY3NzLCBwZXJjZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBiZ1Byb3BzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShwcm9wc1twcm9wXSwgcGVyY2VudCk7XG4gICAgICAgICAgY3NzW2BiYWNrZ3JvdW5kLXBvc2l0aW9uLSR7cHJvcC5zdWJzdHIoLTEpfWBdID0gYGNhbGMoJHtwb3NpdGlvbnNbcHJvcF19ICsgJHt2YWx1ZX1weClgO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kSW1hZ2VEaW1lbnNpb25zKGVsKSB7XG4gICAgICBjb25zdCBzcmMgPSBjc3MoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKS5yZXBsYWNlKC9ebm9uZXx1cmxcXChbXCInXT8oLis/KVtcIiddP1xcKSQvLCAnJDEnKTtcblxuICAgICAgaWYgKGRpbWVuc2lvbnNbc3JjXSkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uc1tzcmNdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XG5cbiAgICAgICAgaWYgKCFpbWFnZS5uYXR1cmFsV2lkdGgpIHtcbiAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkaW1lbnNpb25zW3NyY10gPSB0b0RpbWVuc2lvbnMoaW1hZ2UpO1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQoJ2xvYWQnLCBmYWxzZSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnNbc3JjXSA9IHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EaW1lbnNpb25zKGltYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogaW1hZ2UubmF0dXJhbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltYWdlLm5hdHVyYWxIZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdG9wcyhzdG9wcywgZm4gPSB0b0Zsb2F0KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdG9wcztcbiAgICAgIGxldCBudWxsSW5kZXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgW3ZhbHVlLCBwZXJjZW50XSA9IGlzU3RyaW5nKHN0b3BzW2ldKSA/IHN0b3BzW2ldLnRyaW0oKS5zcGxpdCgnICcpIDogW3N0b3BzW2ldXTtcbiAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgIHBlcmNlbnQgPSBwZXJjZW50ID8gdG9GbG9hdChwZXJjZW50KSAvIDEwMCA6IG51bGw7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBpZiAocGVyY2VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbdmFsdWUsIDBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChwZXJjZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgIT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFt2YWx1ZSwgcGVyY2VudF0pO1xuICAgICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goW3ZhbHVlLCBwZXJjZW50XSk7XG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBudWxsSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIGlmIChudWxsSW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBsZWZ0UGVyY2VudCA9IHJlc3VsdFtpIC0gbnVsbEluZGV4IC0gMV1bMV07XG4gICAgICAgICAgY29uc3QgcCA9IChwZXJjZW50IC0gbGVmdFBlcmNlbnQpIC8gKG51bGxJbmRleCArIDEpO1xuICAgICAgICAgIGZvciAobGV0IGogPSBudWxsSW5kZXg7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdFtpIC0gal1bMV0gPSBsZWZ0UGVyY2VudCArIHAgKiAobnVsbEluZGV4IC0gaiArIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG51bGxJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdG9wKHN0b3BzLCBwZXJjZW50KSB7XG4gICAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleChzdG9wcy5zbGljZSgxKSwgKFssIHRhcmdldFBlcmNlbnRdKSA9PiBwZXJjZW50IDw9IHRhcmdldFBlcmNlbnQpICsgMTtcbiAgICAgIHJldHVybiBbXG4gICAgICBzdG9wc1tpbmRleCAtIDFdWzBdLFxuICAgICAgc3RvcHNbaW5kZXhdWzBdLFxuICAgICAgKHBlcmNlbnQgLSBzdG9wc1tpbmRleCAtIDFdWzFdKSAvIChzdG9wc1tpbmRleF1bMV0gLSBzdG9wc1tpbmRleCAtIDFdWzFdKV07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCkge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmQsIHBdID0gZ2V0U3RvcChzdG9wcywgcGVyY2VudCk7XG4gICAgICByZXR1cm4gaXNOdW1iZXIoc3RhcnQpID8gc3RhcnQgKyBNYXRoLmFicyhzdGFydCAtIGVuZCkgKiBwICogKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6ICtlbmQ7XG4gICAgfVxuXG4gICAgY29uc3QgdW5pdFJlID0gL14tP1xcZCsoXFxTKyk/LztcbiAgICBmdW5jdGlvbiBnZXRVbml0KHN0b3BzLCBkZWZhdWx0VW5pdCkge1xuICAgICAgZm9yIChjb25zdCBzdG9wIG9mIHN0b3BzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3RvcC5tYXRjaCA9PSBudWxsID8gdm9pZCAwIDogc3RvcC5tYXRjaCh1bml0UmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0VW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDc3NWYWx1ZShlbCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBlbC5zdHlsZVtwcm9wXTtcbiAgICAgIGNvbnN0IHZhbCA9IGNzcyhjc3MoZWwsIHByb3AsIHZhbHVlKSwgcHJvcCk7XG4gICAgICBlbC5zdHlsZVtwcm9wXSA9IHByZXY7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxPYmplY3Qoa2V5cywgdmFsdWUpIHtcbiAgICAgIHJldHVybiBrZXlzLnJlZHVjZSgoZGF0YSwgcHJvcCkgPT4ge1xuICAgICAgICBkYXRhW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIHZhciBwYXJhbGxheCA9IHtcbiAgICAgIG1peGluczogW1BhcmFsbGF4LCBSZXNpemUsIFNjcm9sbF0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICB2aWV3cG9ydDogTnVtYmVyLCAvLyBEZXByZWNhdGVkXG4gICAgICAgIGVhc2luZzogTnVtYmVyLFxuICAgICAgICBzdGFydDogU3RyaW5nLFxuICAgICAgICBlbmQ6IFN0cmluZ1xuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6IGZhbHNlLFxuICAgICAgICB2aWV3cG9ydDogMSxcbiAgICAgICAgZWFzaW5nOiAxLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiAwXG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0YXJnZXQoeyB0YXJnZXQgfSwgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGdldE9mZnNldEVsZW1lbnQodGFyZ2V0ICYmIHF1ZXJ5KHRhcmdldCwgJGVsKSB8fCAkZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0KHsgc3RhcnQgfSkge1xuICAgICAgICAgIHJldHVybiB0b1B4KHN0YXJ0LCAnaGVpZ2h0JywgdGhpcy50YXJnZXQsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZCh7IGVuZCwgdmlld3BvcnQgfSkge1xuICAgICAgICAgIHJldHVybiB0b1B4KFxuICAgICAgICAgIGVuZCB8fCAodmlld3BvcnQgPSAoMSAtIHZpZXdwb3J0KSAqIDEwMCkgJiYgYCR7dmlld3BvcnR9dmgrJHt2aWV3cG9ydH0lYCxcbiAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICB0aGlzLnRhcmdldCxcbiAgICAgICAgICB0cnVlKTtcblxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCB0aGlzLnRhcmdldF07XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCh7IHBlcmNlbnQgfSwgdHlwZXMpIHtcbiAgICAgICAgICBpZiAoIXR5cGVzLmhhcygnc2Nyb2xsJykpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByZXYgPSBwZXJjZW50O1xuICAgICAgICAgIHBlcmNlbnQgPSBlYXNlKHNjcm9sbGVkT3Zlcih0aGlzLnRhcmdldCwgdGhpcy5zdGFydCwgdGhpcy5lbmQpLCB0aGlzLmVhc2luZyk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGVyY2VudCxcbiAgICAgICAgICAgIHN0eWxlOiBwcmV2ID09PSBwZXJjZW50ID8gZmFsc2UgOiB0aGlzLmdldENzcyhwZXJjZW50KVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoeyBzdHlsZSB9KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHlsZSAmJiBjc3ModGhpcy4kZWwsIHN0eWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsnc2Nyb2xsJywgJ3Jlc2l6ZSddXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTQ/cGVybWFsaW5rX2NvbW1lbnRfaWQ9MzQ3NzQyNSNnaXN0Y29tbWVudC0zNDc3NDI1XG4gICAgICpcbiAgICAgKiBsaW5lYXI6IDBcbiAgICAgKiBlYXNlSW5TaW5lOiAwLjVcbiAgICAgKiBlYXNlT3V0U2luZTogLTAuNVxuICAgICAqIGVhc2VJblF1YWQ6IDFcbiAgICAgKiBlYXNlT3V0UXVhZDogLTFcbiAgICAgKiBlYXNlSW5DdWJpYzogMlxuICAgICAqIGVhc2VPdXRDdWJpYzogLTJcbiAgICAgKiBlYXNlSW5RdWFydDogM1xuICAgICAqIGVhc2VPdXRRdWFydDogLTNcbiAgICAgKiBlYXNlSW5RdWludDogNFxuICAgICAqIGVhc2VPdXRRdWludDogLTRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKHBlcmNlbnQsIGVhc2luZykge1xuICAgICAgcmV0dXJuIGVhc2luZyA+PSAwID8gTWF0aC5wb3cocGVyY2VudCwgZWFzaW5nICsgMSkgOiAxIC0gTWF0aC5wb3coMSAtIHBlcmNlbnQsIDEgLSBlYXNpbmcpO1xuICAgIH1cblxuICAgIC8vIFNWRyBlbGVtZW50cyBkbyBub3QgaW5oZXJpdCBmcm9tIEhUTUxFbGVtZW50XG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0RWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIGVsID8gJ29mZnNldFRvcCcgaW4gZWwgPyBlbCA6IGdldE9mZnNldEVsZW1lbnQocGFyZW50KGVsKSkgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIFNsaWRlclJlYWN0aXZlID0ge1xuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgodGhpcy5pbmRleCk7XG5cbiAgICAgICAgICBpZiAoIX50aGlzLnByZXZJbmRleCB8fCB0aGlzLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zaG93KGluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlKDEsIHRoaXMucHJldkluZGV4LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBTbGlkZXJQcmVsb2FkID0ge1xuICAgICAgbWl4aW5zOiBbTGF6eWxvYWRdLFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubGF6eWxvYWQodGhpcy5zbGlkZXMsIHRoaXMuZ2V0QWRqYWNlbnRTbGlkZXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uZXIgKHByZXYsIG5leHQsIGRpciwgeyBjZW50ZXIsIGVhc2luZywgbGlzdCB9KSB7XG4gICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuXG4gICAgICBjb25zdCBmcm9tID0gcHJldiA/XG4gICAgICBnZXRMZWZ0KHByZXYsIGxpc3QsIGNlbnRlcikgOlxuICAgICAgZ2V0TGVmdChuZXh0LCBsaXN0LCBjZW50ZXIpICsgZGltZW5zaW9ucyQxKG5leHQpLndpZHRoICogZGlyO1xuICAgICAgY29uc3QgdG8gPSBuZXh0ID9cbiAgICAgIGdldExlZnQobmV4dCwgbGlzdCwgY2VudGVyKSA6XG4gICAgICBmcm9tICsgZGltZW5zaW9ucyQxKHByZXYpLndpZHRoICogZGlyICogKGlzUnRsID8gLTEgOiAxKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlyLFxuXG4gICAgICAgIHNob3coZHVyYXRpb24sIHBlcmNlbnQgPSAwLCBsaW5lYXIpIHtcbiAgICAgICAgICBjb25zdCB0aW1pbmcgPSBsaW5lYXIgPyAnbGluZWFyJyA6IGVhc2luZztcbiAgICAgICAgICBkdXJhdGlvbiAtPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogY2xhbXAocGVyY2VudCwgLTEsIDEpKTtcblxuICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHBlcmNlbnQpO1xuXG4gICAgICAgICAgcGVyY2VudCA9IHByZXYgPyBwZXJjZW50IDogY2xhbXAocGVyY2VudCwgMCwgMSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSh0aGlzLmdldEl0ZW1JbigpLCAnaXRlbWluJywgeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgcHJldiAmJlxuICAgICAgICAgIHRyaWdnZXJVcGRhdGUodGhpcy5nZXRJdGVtSW4odHJ1ZSksICdpdGVtb3V0Jywge1xuICAgICAgICAgICAgcGVyY2VudDogMSAtIHBlcmNlbnQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZyxcbiAgICAgICAgICAgIGRpclxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgICBsaXN0LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLXRvICogKGlzUnRsID8gLTEgOiAxKSwgJ3B4JykgfSxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmcpLlxuICAgICAgICAgIHRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgbm9vcCk7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwobGlzdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgY3NzKGxpc3QsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCA9IHRoaXMucGVyY2VudCgpKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwobGlzdCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhkdXJhdGlvbiwgcGVyY2VudCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuZ2V0RGlzdGFuY2UoKSAqIGRpciAqIChpc1J0bCA/IC0xIDogMSk7XG5cbiAgICAgICAgICBjc3MoXG4gICAgICAgICAgbGlzdCxcbiAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICB0cmFuc2xhdGUoXG4gICAgICAgICAgY2xhbXAoXG4gICAgICAgICAgLXRvICsgKGRpc3RhbmNlIC0gZGlzdGFuY2UgKiBwZXJjZW50KSxcbiAgICAgICAgICAtZ2V0V2lkdGgobGlzdCksXG4gICAgICAgICAgZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoKSAqIChcbiAgICAgICAgICBpc1J0bCA/IC0xIDogMSksXG4gICAgICAgICAgJ3B4JykpO1xuXG5cblxuICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZXMoKTtcbiAgICAgICAgICBjb25zdCBpdGVtSW4gPSB0aGlzLmdldEl0ZW1JbigpO1xuICAgICAgICAgIGNvbnN0IGl0ZW1PdXQgPSB0aGlzLmdldEl0ZW1Jbih0cnVlKTtcblxuICAgICAgICAgIHBlcmNlbnQgPSBwcmV2ID8gY2xhbXAocGVyY2VudCwgLTEsIDEpIDogMDtcblxuICAgICAgICAgIGZvciAoY29uc3Qgc2xpZGUgb2YgY2hpbGRyZW4obGlzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQWN0aXZlID0gaW5jbHVkZXMoYWN0aXZlcywgc2xpZGUpO1xuICAgICAgICAgICAgY29uc3QgaXNJbiA9IHNsaWRlID09PSBpdGVtSW47XG4gICAgICAgICAgICBjb25zdCBpc091dCA9IHNsaWRlID09PSBpdGVtT3V0O1xuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlSW4gPVxuICAgICAgICAgICAgaXNJbiB8fFxuICAgICAgICAgICAgIWlzT3V0ICYmIChcbiAgICAgICAgICAgIGlzQWN0aXZlIHx8XG4gICAgICAgICAgICBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpID09PSAtMSBeXG4gICAgICAgICAgICBnZXRFbExlZnQoc2xpZGUsIGxpc3QpID4gZ2V0RWxMZWZ0KHByZXYgfHwgbmV4dCkpO1xuXG4gICAgICAgICAgICB0cmlnZ2VyVXBkYXRlKHNsaWRlLCBgaXRlbXRyYW5zbGF0ZSR7dHJhbnNsYXRlSW4gPyAnaW4nIDogJ291dCd9YCwge1xuICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgIHBlcmNlbnQ6IGlzT3V0ID8gMSAtIHBlcmNlbnQgOiBpc0luID8gcGVyY2VudCA6IGlzQWN0aXZlID8gMSA6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhcbiAgICAgICAgICAoY3NzKGxpc3QsICd0cmFuc2Zvcm0nKS5zcGxpdCgnLCcpWzRdICogKGlzUnRsID8gLTEgOiAxKSArIGZyb20pIC8gKHRvIC0gZnJvbSkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGlzdGFuY2UoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvIC0gZnJvbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SXRlbUluKG91dCA9IGZhbHNlKSB7XG4gICAgICAgICAgbGV0IGFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZXMoKTtcbiAgICAgICAgICBsZXQgbmV4dEFjdGl2ZXMgPSBpblZpZXcobGlzdCwgZ2V0TGVmdChuZXh0IHx8IHByZXYsIGxpc3QsIGNlbnRlcikpO1xuXG4gICAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IGFjdGl2ZXM7XG4gICAgICAgICAgICBhY3RpdmVzID0gbmV4dEFjdGl2ZXM7XG4gICAgICAgICAgICBuZXh0QWN0aXZlcyA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRBY3RpdmVzW2ZpbmRJbmRleChuZXh0QWN0aXZlcywgKGVsKSA9PiAhaW5jbHVkZXMoYWN0aXZlcywgZWwpKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QWN0aXZlcygpIHtcbiAgICAgICAgICByZXR1cm4gaW5WaWV3KGxpc3QsIGdldExlZnQocHJldiB8fCBuZXh0LCBsaXN0LCBjZW50ZXIpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMZWZ0KGVsLCBsaXN0LCBjZW50ZXIpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBnZXRFbExlZnQoZWwsIGxpc3QpO1xuXG4gICAgICByZXR1cm4gY2VudGVyID8gbGVmdCAtIGNlbnRlckVsKGVsLCBsaXN0KSA6IE1hdGgubWluKGxlZnQsIGdldE1heChsaXN0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWF4KGxpc3QpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBnZXRXaWR0aChsaXN0KSAtIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2lkdGgobGlzdCkge1xuICAgICAgcmV0dXJuIHN1bUJ5KGNoaWxkcmVuKGxpc3QpLCAoZWwpID0+IGRpbWVuc2lvbnMkMShlbCkud2lkdGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlckVsKGVsLCBsaXN0KSB7XG4gICAgICByZXR1cm4gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoIC8gMiAtIGRpbWVuc2lvbnMkMShlbCkud2lkdGggLyAyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVsTGVmdChlbCwgbGlzdCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZWwgJiZcbiAgICAgICAgKHBvc2l0aW9uKGVsKS5sZWZ0ICsgKGlzUnRsID8gZGltZW5zaW9ucyQxKGVsKS53aWR0aCAtIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCA6IDApKSAqIChcbiAgICAgICAgaXNSdGwgPyAtMSA6IDEpIHx8XG4gICAgICAgIDApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5WaWV3KGxpc3QsIGxpc3RMZWZ0KSB7XG4gICAgICBsaXN0TGVmdCAtPSAxO1xuICAgICAgY29uc3QgbGlzdFdpZHRoID0gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoO1xuICAgICAgY29uc3QgbGlzdFJpZ2h0ID0gbGlzdExlZnQgKyBsaXN0V2lkdGggKyAyO1xuXG4gICAgICByZXR1cm4gY2hpbGRyZW4obGlzdCkuZmlsdGVyKChzbGlkZSkgPT4ge1xuICAgICAgICBjb25zdCBzbGlkZUxlZnQgPSBnZXRFbExlZnQoc2xpZGUsIGxpc3QpO1xuICAgICAgICBjb25zdCBzbGlkZVJpZ2h0ID0gc2xpZGVMZWZ0ICsgTWF0aC5taW4oZGltZW5zaW9ucyQxKHNsaWRlKS53aWR0aCwgbGlzdFdpZHRoKTtcblxuICAgICAgICByZXR1cm4gc2xpZGVMZWZ0ID49IGxpc3RMZWZ0ICYmIHNsaWRlUmlnaHQgPD0gbGlzdFJpZ2h0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZShlbCwgdHlwZSwgZGF0YSkge1xuICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBTbGlkZXIsIFNsaWRlclJlYWN0aXZlLCBTbGlkZXJQcmVsb2FkXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2VudGVyOiBCb29sZWFuLFxuICAgICAgICBzZXRzOiBCb29sZWFuXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNlbnRlcjogZmFsc2UsXG4gICAgICAgIHNldHM6IGZhbHNlLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXNsaWRlci1pdGVtJyxcbiAgICAgICAgc2VsTGlzdDogJy51ay1zbGlkZXItaXRlbXMnLFxuICAgICAgICBzZWxOYXY6ICcudWstc2xpZGVyLW5hdicsXG4gICAgICAgIGNsc0NvbnRhaW5lcjogJ3VrLXNsaWRlci1jb250YWluZXInLFxuICAgICAgICBUcmFuc2l0aW9uZXJcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGF2Z1dpZHRoKCkge1xuICAgICAgICAgIHJldHVybiBnZXRXaWR0aCh0aGlzLmxpc3QpIC8gdGhpcy5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXRlKHsgZmluaXRlIH0pIHtcbiAgICAgICAgICByZXR1cm4gZmluaXRlIHx8IGlzRmluaXRlKHRoaXMubGlzdCwgdGhpcy5jZW50ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1heEluZGV4KCkge1xuICAgICAgICAgIGlmICghdGhpcy5maW5pdGUgfHwgdGhpcy5jZW50ZXIgJiYgIXRoaXMuc2V0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0KHRoaXMuc2V0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGxmdCA9IDA7XG4gICAgICAgICAgY29uc3QgbWF4ID0gZ2V0TWF4KHRoaXMubGlzdCk7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5zbGlkZXMsIChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxmdCA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxmdCArPSBkaW1lbnNpb25zJDEoZWwpLndpZHRoO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIH5pbmRleCA/IGluZGV4IDogdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldHMoeyBzZXRzOiBlbmFibGVkIH0pIHtcbiAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgICAgY29uc3Qgc2V0cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gZGltZW5zaW9ucyQxKHRoaXMubGlzdCkud2lkdGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZVdpZHRoID0gZGltZW5zaW9ucyQxKHRoaXMuc2xpZGVzW2ldKS53aWR0aDtcblxuICAgICAgICAgICAgaWYgKGxlZnQgKyBzbGlkZVdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGxlZnQgPCB3aWR0aCAvIDIgJiZcbiAgICAgICAgICAgICAgbGVmdCArIHNsaWRlV2lkdGggKyBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbK2kgKyAxXSkud2lkdGggLyAyID4gd2lkdGggLyAyKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0cy5wdXNoKCtpKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gd2lkdGggLyAyIC0gc2xpZGVXaWR0aCAvIDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICBzZXRzLnB1c2goTWF0aC5taW4oK2ksIHRoaXMubWF4SW5kZXgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVmdCArPSBzbGlkZVdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldHM7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zaXRpb25PcHRpb25zKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZW50ZXI6IHRoaXMuY2VudGVyLFxuICAgICAgICAgICAgbGlzdDogdGhpcy5saXN0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNDb250YWluZXIsICEkKGAuJHt0aGlzLmNsc0NvbnRhaW5lcn1gLCB0aGlzLiRlbCkpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5uYXZJdGVtcykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0b051bWJlcihkYXRhKGVsLCB0aGlzLmF0dHJJdGVtKSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGVsLmhpZGRlbiA9XG4gICAgICAgICAgICAgICF0aGlzLm1heEluZGV4IHx8XG4gICAgICAgICAgICAgIGluZGV4ID4gdGhpcy5tYXhJbmRleCB8fFxuICAgICAgICAgICAgICB0aGlzLnNldHMgJiYgIWluY2x1ZGVzKHRoaXMuc2V0cywgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCAmJiAhdGhpcy5kcmFnZ2luZyAmJiAhdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVvcmRlcigpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlKDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlQ2xhc3NlcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWl0ZW1zaG93KGUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuZHJhZ2dpbmcgJiZcbiAgICAgICAgICB0aGlzLnNldHMgJiZcbiAgICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA8IDIgJiZcbiAgICAgICAgICAhaW5jbHVkZXModGhpcy5zZXRzLCB0aGlzLmluZGV4KSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKFxuICAgICAgICAgIHRoaXMuaW5kZXggLVxuICAgICAgICAgIHRoaXMucHJldkluZGV4ICsgKFxuICAgICAgICAgIHRoaXMuZGlyID4gMCAmJiB0aGlzLmluZGV4IDwgdGhpcy5wcmV2SW5kZXggfHxcbiAgICAgICAgICB0aGlzLmRpciA8IDAgJiYgdGhpcy5pbmRleCA+IHRoaXMucHJldkluZGV4ID9cbiAgICAgICAgICAodGhpcy5tYXhJbmRleCArIDEpICogdGhpcy5kaXIgOlxuICAgICAgICAgIDApKTtcblxuXG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nICYmIGRpZmYgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSgxLCAwLCB0aGlzLmRpciA+IDAgPyAnbmV4dCcgOiAncHJldmlvdXMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGluZGV4ID1cbiAgICAgICAgICB0aGlzLmRpciA8IDAgfHwgIXRoaXMuc2xpZGVzW3RoaXMucHJldkluZGV4XSA/IHRoaXMuaW5kZXggOiB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID1cbiAgICAgICAgICBzcGVlZFVwKHRoaXMuYXZnV2lkdGggLyB0aGlzLnZlbG9jaXR5KSAqIChcbiAgICAgICAgICBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbaW5kZXhdKS53aWR0aCAvIHRoaXMuYXZnV2lkdGgpO1xuXG4gICAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXNob3coKSB7XG4gICAgICAgICAgaWYgKH50aGlzLnByZXZJbmRleCkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy5fZ2V0VHJhbnNpdGlvbmVyKCkuZ2V0SXRlbUluKCksIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXNob3duKCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlQ2xhc3NlcygpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHJlb3JkZXIoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmluaXRlKSB7XG4gICAgICAgICAgICBjc3ModGhpcy5zbGlkZXMsICdvcmRlcicsICcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGlyID4gMCAmJiB0aGlzLnNsaWRlc1t0aGlzLnByZXZJbmRleF0gPyB0aGlzLnByZXZJbmRleCA6IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgICB0aGlzLnNsaWRlcy5mb3JFYWNoKChzbGlkZSwgaSkgPT4gY3NzKFxuICAgICAgICAgIHNsaWRlLFxuICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgdGhpcy5kaXIgPiAwICYmIGkgPCBpbmRleCA/IDEgOiB0aGlzLmRpciA8IDAgJiYgaSA+PSB0aGlzLmluZGV4ID8gLTEgOiAnJykpO1xuXG5cblxuICAgICAgICAgIGlmICghdGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5zbGlkZXNbaW5kZXhdO1xuICAgICAgICAgIGxldCB3aWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpLndpZHRoIC8gMiAtIGRpbWVuc2lvbnMkMShuZXh0KS53aWR0aCAvIDI7XG4gICAgICAgICAgbGV0IGogPSAwO1xuXG4gICAgICAgICAgd2hpbGUgKHdpZHRoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0SW5kZXgoLS1qICsgaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5zbGlkZXNbc2xpZGVJbmRleF07XG5cbiAgICAgICAgICAgIGNzcyhzbGlkZSwgJ29yZGVyJywgc2xpZGVJbmRleCA+IGluZGV4ID8gLTIgOiAtMSk7XG4gICAgICAgICAgICB3aWR0aCAtPSBkaW1lbnNpb25zJDEoc2xpZGUpLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVBY3RpdmVDbGFzc2VzKCkge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIodGhpcy5pbmRleCkuZ2V0QWN0aXZlcygpO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUNsYXNzZXMgPSBbXG4gICAgICAgICAgdGhpcy5jbHNBY3RpdmUsXG4gICAgICAgICAgKCF0aGlzLnNldHMgfHwgaW5jbHVkZXModGhpcy5zZXRzLCB0b0Zsb2F0KHRoaXMuaW5kZXgpKSkgJiYgdGhpcy5jbHNBY3RpdmF0ZWQgfHxcbiAgICAgICAgICAnJ107XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIHRoaXMuc2xpZGVzKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzbGlkZSwgYWN0aXZlQ2xhc3NlcywgaW5jbHVkZXMoYWN0aXZlcywgc2xpZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VmFsaWRJbmRleChpbmRleCA9IHRoaXMuaW5kZXgsIHByZXZJbmRleCA9IHRoaXMucHJldkluZGV4KSB7XG4gICAgICAgICAgaW5kZXggPSB0aGlzLmdldEluZGV4KGluZGV4LCBwcmV2SW5kZXgpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnNldHMpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcHJldjtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLnNldHMsIGluZGV4KSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5nZXRJbmRleChpbmRleCArIHRoaXMuZGlyLCBwcmV2SW5kZXgpO1xuICAgICAgICAgIH0gd2hpbGUgKGluZGV4ICE9PSBwcmV2KTtcblxuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBZGphY2VudFNsaWRlcygpIHtcbiAgICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSBkaW1lbnNpb25zJDEodGhpcy5saXN0KTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gLXdpZHRoO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2lkdGggKiAyO1xuICAgICAgICAgIGNvbnN0IHNsaWRlV2lkdGggPSBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbdGhpcy5pbmRleF0pLndpZHRoO1xuICAgICAgICAgIGNvbnN0IHNsaWRlTGVmdCA9IHRoaXMuY2VudGVyID8gd2lkdGggLyAyIC0gc2xpZGVXaWR0aCAvIDIgOiAwO1xuICAgICAgICAgIGNvbnN0IHNsaWRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGkgb2YgWy0xLCAxXSkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZWZ0ID0gc2xpZGVMZWZ0ICsgKGkgPiAwID8gc2xpZGVXaWR0aCA6IDApO1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBjb25zdCBzbGlkZSA9IHRoaXMuc2xpZGVzW3RoaXMuZ2V0SW5kZXgodGhpcy5pbmRleCArIGkgKyBqKysgKiBpKV07XG4gICAgICAgICAgICAgIGN1cnJlbnRMZWZ0ICs9IGRpbWVuc2lvbnMkMShzbGlkZSkud2lkdGggKiBpO1xuICAgICAgICAgICAgICBzbGlkZXMuYWRkKHNsaWRlKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMubGVuZ3RoID4gaiAmJiBjdXJyZW50TGVmdCA+IGxlZnQgJiYgY3VycmVudExlZnQgPCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNsaWRlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUobGlzdCwgY2VudGVyKSB7XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gbGlzdDtcblxuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgd2lkdGg6IGxpc3RXaWR0aCB9ID0gZGltZW5zaW9ucyQxKGxpc3QpO1xuICAgICAgaWYgKCFjZW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChnZXRXaWR0aChsaXN0KSkgPCBNYXRoLnRydW5jKGxpc3RXaWR0aCArIGdldE1heEVsV2lkdGgobGlzdCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzbGlkZXMgPSBjaGlsZHJlbihsaXN0KTtcbiAgICAgIGNvbnN0IGxpc3RIYWxmID0gTWF0aC50cnVuYyhsaXN0V2lkdGggLyAyKTtcbiAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gc2xpZGVzKSB7XG4gICAgICAgIGNvbnN0IHNsaWRlID0gc2xpZGVzW2luZGV4XTtcbiAgICAgICAgY29uc3Qgc2xpZGVXaWR0aCA9IGRpbWVuc2lvbnMkMShzbGlkZSkud2lkdGg7XG4gICAgICAgIGNvbnN0IHNsaWRlc0luVmlldyA9IG5ldyBTZXQoW3NsaWRlXSk7XG5cbiAgICAgICAgbGV0IGRpZmYgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgWy0xLCAxXSkge1xuICAgICAgICAgIGxldCBsZWZ0ID0gc2xpZGVXaWR0aCAvIDI7XG5cbiAgICAgICAgICBsZXQgaiA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAobGVmdCA8IGxpc3RIYWxmKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0U2xpZGUgPSBzbGlkZXNbZ2V0SW5kZXgoK2luZGV4ICsgaSArIGorKyAqIGksIHNsaWRlcyldO1xuXG4gICAgICAgICAgICBpZiAoc2xpZGVzSW5WaWV3LmhhcyhuZXh0U2xpZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0ICs9IGRpbWVuc2lvbnMkMShuZXh0U2xpZGUpLndpZHRoO1xuICAgICAgICAgICAgc2xpZGVzSW5WaWV3LmFkZChuZXh0U2xpZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaWZmID0gTWF0aC5tYXgoXG4gICAgICAgICAgZGlmZixcbiAgICAgICAgICBzbGlkZVdpZHRoIC8gMiArXG4gICAgICAgICAgZGltZW5zaW9ucyQxKHNsaWRlc1tnZXRJbmRleCgraW5kZXggKyBpLCBzbGlkZXMpXSkud2lkdGggLyAyIC0gKFxuICAgICAgICAgIGxlZnQgLSBsaXN0SGFsZikpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgIGRpZmYgPiBzdW1CeShcbiAgICAgICAgc2xpZGVzLmZpbHRlcigoc2xpZGUpID0+ICFzbGlkZXNJblZpZXcuaGFzKHNsaWRlKSksXG4gICAgICAgIChzbGlkZSkgPT4gZGltZW5zaW9ucyQxKHNsaWRlKS53aWR0aCkpXG5cbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXhFbFdpZHRoKGxpc3QpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCAuLi5jaGlsZHJlbihsaXN0KS5tYXAoKGVsKSA9PiBkaW1lbnNpb25zJDEoZWwpLndpZHRoKSk7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlclBhcmFsbGF4ID0ge1xuICAgICAgbWl4aW5zOiBbUGFyYWxsYXhdLFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNlbEl0ZW06ICchbGknXG4gICAgICB9LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLml0ZW0gPSBxdWVyeSh0aGlzLnNlbEl0ZW0sIHRoaXMuJGVsKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5pdGVtID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbWluIGl0ZW1vdXQnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKHsgdHlwZSwgZGV0YWlsOiB7IHBlcmNlbnQsIGR1cmF0aW9uLCB0aW1pbmcsIGRpciB9IH0pIHtcbiAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9wc0Zyb20gPSB0aGlzLmdldENzcyhnZXRDdXJyZW50UGVyY2VudCh0eXBlLCBkaXIsIHBlcmNlbnQpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG8gPSB0aGlzLmdldENzcyhpc0luKHR5cGUpID8gMC41IDogZGlyID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIGZhc3Rkb20ud3JpdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBjc3ModGhpcy4kZWwsIHByb3BzRnJvbSk7XG4gICAgICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQodGhpcy4kZWwsIHByb3BzVG8sIGR1cmF0aW9uLCB0aW1pbmcpLmNhdGNoKG5vb3ApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RyYW5zaXRpb25jYW5jZWxlZCB0cmFuc2l0aW9uZW5kJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW10cmFuc2xhdGVpbiBpdGVtdHJhbnNsYXRlb3V0JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcih7IHR5cGUsIGRldGFpbDogeyBwZXJjZW50LCBkaXIgfSB9KSB7XG4gICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuZ2V0Q3NzKGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkpO1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiBjc3ModGhpcy4kZWwsIHByb3BzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1dXG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNJbih0eXBlKSB7XG4gICAgICByZXR1cm4gZW5kc1dpdGgodHlwZSwgJ2luJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFBlcmNlbnQodHlwZSwgZGlyLCBwZXJjZW50KSB7XG4gICAgICBwZXJjZW50IC89IDI7XG5cbiAgICAgIHJldHVybiBpc0luKHR5cGUpIF4gZGlyIDwgMCA/IHBlcmNlbnQgOiAxIC0gcGVyY2VudDtcbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0aW9ucyA9IHtcbiAgICAgIC4uLkFuaW1hdGlvbnMkMixcbiAgICAgIGZhZGU6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICByZXR1cm4gW3sgb3BhY2l0eTogMCwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB6SW5kZXg6IDAgfSwgeyB6SW5kZXg6IC0xIH1dO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzY2FsZToge1xuICAgICAgICBzaG93KCkge1xuICAgICAgICAgIHJldHVybiBbeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06IHNjYWxlM2QoMSArIDAuNSksIHpJbmRleDogMCB9LCB7IHpJbmRleDogLTEgfV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBjc3MoY3VycmVudCwgJ29wYWNpdHknKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgeyBvcGFjaXR5OiAxIC0gcGVyY2VudCwgdHJhbnNmb3JtOiBzY2FsZTNkKDEgKyAwLjUgKiBwZXJjZW50KSwgekluZGV4OiAwIH0sXG4gICAgICAgICAgeyB6SW5kZXg6IC0xIH1dO1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHB1bGw6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/XG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzApLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IDAgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCwgbmV4dCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyAxIC0gdHJhbnNsYXRlZChuZXh0KSA6IHRyYW5zbGF0ZWQoY3VycmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQsIGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgzMCAqIHBlcmNlbnQpLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTAwICogKDEgLSBwZXJjZW50KSksIHpJbmRleDogMCB9XSA6XG5cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtcGVyY2VudCAqIDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBwdXNoOiB7XG4gICAgICAgIHNob3coZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgP1xuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAtMSB9XSA6XG5cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMzApLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IDAgfV07XG5cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQsIG5leHQsIGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPiAwID8gMSAtIHRyYW5zbGF0ZWQobmV4dCkgOiB0cmFuc2xhdGVkKGN1cnJlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/XG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUocGVyY2VudCAqIDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTMwICogKDEgLSBwZXJjZW50KSksIHpJbmRleDogLTEgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTMwICogcGVyY2VudCksIHpJbmRleDogLTEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwMCAqICgxIC0gcGVyY2VudCkpLCB6SW5kZXg6IDAgfV07XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2xpZGVzaG93ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFNsaWRlc2hvdywgU2xpZGVyUmVhY3RpdmUsIFNsaWRlclByZWxvYWRdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICByYXRpbzogU3RyaW5nLFxuICAgICAgICBtaW5IZWlnaHQ6IE51bWJlcixcbiAgICAgICAgbWF4SGVpZ2h0OiBOdW1iZXJcbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmF0aW86ICcxNjo5JyxcbiAgICAgICAgbWluSGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgbWF4SGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgc2VsTGlzdDogJy51ay1zbGlkZXNob3ctaXRlbXMnLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXNsaWRlc2hvdy1pdGVtJyxcbiAgICAgICAgc2VsTmF2OiAnLnVrLXNsaWRlc2hvdy1uYXYnLFxuICAgICAgICBBbmltYXRpb25zXG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnJhdGlvLnNwbGl0KCc6JykubWFwKE51bWJlcik7XG5cbiAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmxpc3Qub2Zmc2V0V2lkdGggLyB3aWR0aCB8fCAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLm1pbkhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IGhlaWdodDogaGVpZ2h0IC0gYm94TW9kZWxBZGp1c3QodGhpcy5saXN0LCAnaGVpZ2h0JywgJ2NvbnRlbnQtYm94JykgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZSh7IGhlaWdodCB9KSB7XG4gICAgICAgICAgaGVpZ2h0ID4gMCAmJiBjc3ModGhpcy5saXN0LCAnbWluSGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ11cbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0QWRqYWNlbnRTbGlkZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIFsxLCAtMV0ubWFwKChpKSA9PiB0aGlzLnNsaWRlc1t0aGlzLmdldEluZGV4KHRoaXMuaW5kZXggKyBpKV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzb3J0YWJsZSA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBBbmltYXRlXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZ3JvdXA6IFN0cmluZyxcbiAgICAgICAgdGhyZXNob2xkOiBOdW1iZXIsXG4gICAgICAgIGNsc0l0ZW06IFN0cmluZyxcbiAgICAgICAgY2xzUGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICAgICAgY2xzRHJhZzogU3RyaW5nLFxuICAgICAgICBjbHNEcmFnU3RhdGU6IFN0cmluZyxcbiAgICAgICAgY2xzQmFzZTogU3RyaW5nLFxuICAgICAgICBjbHNOb0RyYWc6IFN0cmluZyxcbiAgICAgICAgY2xzRW1wdHk6IFN0cmluZyxcbiAgICAgICAgY2xzQ3VzdG9tOiBTdHJpbmcsXG4gICAgICAgIGhhbmRsZTogU3RyaW5nXG4gICAgICB9LFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGdyb3VwOiBmYWxzZSxcbiAgICAgICAgdGhyZXNob2xkOiA1LFxuICAgICAgICBjbHNJdGVtOiAndWstc29ydGFibGUtaXRlbScsXG4gICAgICAgIGNsc1BsYWNlaG9sZGVyOiAndWstc29ydGFibGUtcGxhY2Vob2xkZXInLFxuICAgICAgICBjbHNEcmFnOiAndWstc29ydGFibGUtZHJhZycsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogJ3VrLWRyYWcnLFxuICAgICAgICBjbHNCYXNlOiAndWstc29ydGFibGUnLFxuICAgICAgICBjbHNOb0RyYWc6ICd1ay1zb3J0YWJsZS1ub2RyYWcnLFxuICAgICAgICBjbHNFbXB0eTogJ3VrLXNvcnRhYmxlLWVtcHR5JyxcbiAgICAgICAgY2xzQ3VzdG9tOiAnJyxcbiAgICAgICAgaGFuZGxlOiBmYWxzZSxcbiAgICAgICAgcG9zOiB7fVxuICAgICAgfSxcblxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgWydpbml0JywgJ3N0YXJ0JywgJ21vdmUnLCAnZW5kJ10pIHtcbiAgICAgICAgICBjb25zdCBmbiA9IHRoaXNba2V5XTtcbiAgICAgICAgICB0aGlzW2tleV0gPSAoZSkgPT4ge1xuICAgICAgICAgICAgYXNzaWduKHRoaXMucG9zLCBnZXRFdmVudFBvcyhlKSk7XG4gICAgICAgICAgICBmbihlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgbmFtZTogcG9pbnRlckRvd24kMSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIGhhbmRsZXI6ICdpbml0J1xuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAodGhpcy4kZWwudEJvZGllcyB8fCBbdGhpcy4kZWxdKVswXTtcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtcygpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4odGhpcy50YXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRW1wdHk6IHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLml0ZW1zKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZW1wdHkpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmNsc0VtcHR5LCBlbXB0eSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXM6IHtcbiAgICAgICAgICBnZXQoeyBoYW5kbGUgfSwgZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUgPyAkJChoYW5kbGUsIGVsKSA6IHRoaXMuaXRlbXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGhhbmRsZXMsIHByZXYpIHtcbiAgICAgICAgICAgIGNzcyhwcmV2LCB7IHRvdWNoQWN0aW9uOiAnJywgdXNlclNlbGVjdDogJycgfSk7XG4gICAgICAgICAgICBjc3MoaGFuZGxlcywgeyB0b3VjaEFjdGlvbjogaGFzVG91Y2ggPyAnbm9uZScgOiAnJywgdXNlclNlbGVjdDogJ25vbmUnIH0pOyAvLyB0b3VjaEFjdGlvbiBzZXQgdG8gJ25vbmUnIGNhdXNlcyBhIHBlcmZvcm1hbmNlIGRyb3AgaW4gQ2hyb21lIDgwXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgd3JpdGUoZGF0YSkge1xuICAgICAgICAgIGlmICghdGhpcy5kcmFnIHx8ICFwYXJlbnQodGhpcy5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBwb3M6IHsgeCwgeSB9LFxuICAgICAgICAgICAgb3JpZ2luOiB7IG9mZnNldFRvcCwgb2Zmc2V0TGVmdCB9LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJcbiAgICAgICAgICB9ID0gdGhpcztcblxuICAgICAgICAgIGNzcyh0aGlzLmRyYWcsIHtcbiAgICAgICAgICAgIHRvcDogeSAtIG9mZnNldFRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHggLSBvZmZzZXRMZWZ0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuZ2V0U29ydGFibGUoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSk7XG5cbiAgICAgICAgICBpZiAoIXNvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gc29ydGFibGU7XG5cbiAgICAgICAgICBpZiAoaXRlbXMuc29tZShUcmFuc2l0aW9uLmluUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZmluZFRhcmdldChpdGVtcywgeyB4LCB5IH0pO1xuXG4gICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAmJiAoIXRhcmdldCB8fCB0YXJnZXQgPT09IHBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5nZXRTb3J0YWJsZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0VGFyZ2V0ID0gZmluZEluc2VydFRhcmdldChcbiAgICAgICAgICBzb3J0YWJsZS50YXJnZXQsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBzb3J0YWJsZSA9PT0gcHJldmlvdXMgJiYgZGF0YS5tb3ZlZCAhPT0gdGFyZ2V0KTtcblxuXG4gICAgICAgICAgaWYgKGluc2VydFRhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5zZXJ0VGFyZ2V0ICYmIHBsYWNlaG9sZGVyID09PSBpbnNlcnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc29ydGFibGUgIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgICBwcmV2aW91cy5yZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgZGF0YS5tb3ZlZCA9IHRhcmdldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEubW92ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc29ydGFibGUuaW5zZXJ0KHBsYWNlaG9sZGVyLCBpbnNlcnRUYXJnZXQpO1xuXG4gICAgICAgICAgdGhpcy50b3VjaGVkLmFkZChzb3J0YWJsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ21vdmUnXVxuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBpbml0KGUpIHtcbiAgICAgICAgICBjb25zdCB7IHRhcmdldCwgYnV0dG9uLCBkZWZhdWx0UHJldmVudGVkIH0gPSBlO1xuICAgICAgICAgIGNvbnN0IFtwbGFjZWhvbGRlcl0gPSB0aGlzLml0ZW1zLmZpbHRlcigoZWwpID0+IHdpdGhpbih0YXJnZXQsIGVsKSk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXBsYWNlaG9sZGVyIHx8XG4gICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCB8fFxuICAgICAgICAgIGJ1dHRvbiA+IDAgfHxcbiAgICAgICAgICBpc0lucHV0KHRhcmdldCkgfHxcbiAgICAgICAgICB3aXRoaW4odGFyZ2V0LCBgLiR7dGhpcy5jbHNOb0RyYWd9YCkgfHxcbiAgICAgICAgICB0aGlzLmhhbmRsZSAmJiAhd2l0aGluKHRhcmdldCwgdGhpcy5oYW5kbGUpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB0aGlzLnRvdWNoZWQgPSBuZXcgU2V0KFt0aGlzXSk7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgIHRoaXMub3JpZ2luID0geyB0YXJnZXQsIGluZGV4OiBpbmRleChwbGFjZWhvbGRlciksIC4uLnRoaXMucG9zIH07XG5cbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlck1vdmUkMSwgdGhpcy5tb3ZlKTtcbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlclVwJDEsIHRoaXMuZW5kKTtcblxuICAgICAgICAgIGlmICghdGhpcy50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0KGUpIHtcbiAgICAgICAgICB0aGlzLmRyYWcgPSBhcHBlbmREcmFnKHRoaXMuJGNvbnRhaW5lciwgdGhpcy5wbGFjZWhvbGRlcik7XG4gICAgICAgICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IHRoaXMucGxhY2Vob2xkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgYXNzaWduKHRoaXMub3JpZ2luLCB7IG9mZnNldExlZnQ6IHRoaXMucG9zLnggLSBsZWZ0LCBvZmZzZXRUb3A6IHRoaXMucG9zLnkgLSB0b3AgfSk7XG5cbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLmRyYWcsIHRoaXMuY2xzRHJhZywgdGhpcy5jbHNDdXN0b20pO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMucGxhY2Vob2xkZXIsIHRoaXMuY2xzUGxhY2Vob2xkZXIpO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuaXRlbXMsIHRoaXMuY2xzSXRlbSk7XG4gICAgICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmNsc0RyYWdTdGF0ZSk7XG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnc3RhcnQnLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuXG4gICAgICAgICAgdHJhY2tTY3JvbGwodGhpcy5wb3MpO1xuXG4gICAgICAgICAgdGhpcy5tb3ZlKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmUoZSkge1xuICAgICAgICAgIGlmICh0aGlzLmRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ21vdmUnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIE1hdGguYWJzKHRoaXMucG9zLnggLSB0aGlzLm9yaWdpbi54KSA+IHRoaXMudGhyZXNob2xkIHx8XG4gICAgICAgICAgTWF0aC5hYnModGhpcy5wb3MueSAtIHRoaXMub3JpZ2luLnkpID4gdGhpcy50aHJlc2hvbGQpXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGFydChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlck1vdmUkMSwgdGhpcy5tb3ZlKTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJVcCQxLCB0aGlzLmVuZCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZHJhZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVudHJhY2tTY3JvbGwoKTtcblxuICAgICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5nZXRTb3J0YWJsZSh0aGlzLnBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIGlmICh0aGlzID09PSBzb3J0YWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luLmluZGV4ICE9PSBpbmRleCh0aGlzLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnbW92ZWQnLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHNvcnRhYmxlLiRlbCwgJ2FkZGVkJywgW3NvcnRhYmxlLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAncmVtb3ZlZCcsIFt0aGlzLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ3N0b3AnLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuXG4gICAgICAgICAgcmVtb3ZlJDEodGhpcy5kcmFnKTtcbiAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsO1xuXG4gICAgICAgICAgZm9yIChjb25zdCB7IGNsc1BsYWNlaG9sZGVyLCBjbHNJdGVtIH0gb2YgdGhpcy50b3VjaGVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNvcnRhYmxlIG9mIHRoaXMudG91Y2hlZCkge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzb3J0YWJsZS5pdGVtcywgY2xzUGxhY2Vob2xkZXIsIGNsc0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRvdWNoZWQgPSBudWxsO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy5jbHNEcmFnU3RhdGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluc2VydChlbGVtZW50LCB0YXJnZXQpIHtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLml0ZW1zLCB0aGlzLmNsc0l0ZW0pO1xuXG4gICAgICAgICAgY29uc3QgaW5zZXJ0ID0gKCkgPT4gdGFyZ2V0ID8gYmVmb3JlKHRhcmdldCwgZWxlbWVudCkgOiBhcHBlbmQodGhpcy50YXJnZXQsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgdGhpcy5hbmltYXRlKGluc2VydCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlKGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoIXdpdGhpbihlbGVtZW50LCB0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFuaW1hdGUoKCkgPT4gcmVtb3ZlJDEoZWxlbWVudCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNvcnRhYmxlKGVsZW1lbnQpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuJGdldENvbXBvbmVudChlbGVtZW50LCAnc29ydGFibGUnKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc29ydGFibGUgJiYgKFxuICAgICAgICAgICAgc29ydGFibGUgPT09IHRoaXMgfHwgdGhpcy5ncm91cCAhPT0gZmFsc2UgJiYgc29ydGFibGUuZ3JvdXAgPT09IHRoaXMuZ3JvdXApKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm4gc29ydGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoZWxlbWVudCA9IHBhcmVudChlbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IHRyYWNrVGltZXI7XG4gICAgZnVuY3Rpb24gdHJhY2tTY3JvbGwocG9zKSB7XG4gICAgICBsZXQgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICB0cmFja1RpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBsZXQgeyB4LCB5IH0gPSBwb3M7XG4gICAgICAgIHkgKz0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3A7XG5cbiAgICAgICAgY29uc3QgZGlzdCA9IChEYXRlLm5vdygpIC0gbGFzdCkgKiAwLjM7XG4gICAgICAgIGxhc3QgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHNjcm9sbFBhcmVudHMoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCBwb3MueSksIC9hdXRvfHNjcm9sbC8pLlxuICAgICAgICByZXZlcnNlKCkuXG4gICAgICAgIHNvbWUoKHNjcm9sbEVsKSA9PiB7XG4gICAgICAgICAgbGV0IHsgc2Nyb2xsVG9wOiBzY3JvbGwsIHNjcm9sbEhlaWdodCB9ID0gc2Nyb2xsRWw7XG5cbiAgICAgICAgICBjb25zdCB7IHRvcCwgYm90dG9tLCBoZWlnaHQgfSA9IG9mZnNldFZpZXdwb3J0KHNjcm9sbEVsKTtcblxuICAgICAgICAgIGlmICh0b3AgPCB5ICYmIHRvcCArIDM1ID4geSkge1xuICAgICAgICAgICAgc2Nyb2xsIC09IGRpc3Q7XG4gICAgICAgICAgfSBlbHNlIGlmIChib3R0b20gPiB5ICYmIGJvdHRvbSAtIDM1IDwgeSkge1xuICAgICAgICAgICAgc2Nyb2xsICs9IGRpc3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsID4gMCAmJiBzY3JvbGwgPCBzY3JvbGxIZWlnaHQgLSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCA9IHNjcm9sbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCAxNSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cmFja1Njcm9sbCgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodHJhY2tUaW1lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kRHJhZyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICAgIGxldCBjbG9uZTtcbiAgICAgIGlmIChbJ2xpJywgJ3RyJ10uc29tZSgodGFnKSA9PiBpc1RhZyhlbGVtZW50LCB0YWcpKSkge1xuICAgICAgICBjbG9uZSA9ICQoJzxkaXY+Jyk7XG4gICAgICAgIGFwcGVuZChjbG9uZSwgZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSkuY2hpbGRyZW4pO1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBlbGVtZW50LmdldEF0dHJpYnV0ZU5hbWVzKCkpIHtcbiAgICAgICAgICBhdHRyKGNsb25lLCBhdHRyaWJ1dGUsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZSA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBhcHBlbmQoY29udGFpbmVyLCBjbG9uZSk7XG5cbiAgICAgIGNzcyhjbG9uZSwgJ21hcmdpbicsICcwJywgJ2ltcG9ydGFudCcpO1xuICAgICAgY3NzKGNsb25lLCB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgcGFkZGluZzogY3NzKGVsZW1lbnQsICdwYWRkaW5nJylcbiAgICAgIH0pO1xuXG4gICAgICBoZWlnaHQoY2xvbmUuZmlyc3RFbGVtZW50Q2hpbGQsIGhlaWdodChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSk7XG5cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kVGFyZ2V0KGl0ZW1zLCBwb2ludCkge1xuICAgICAgcmV0dXJuIGl0ZW1zW2ZpbmRJbmRleChpdGVtcywgKGl0ZW0pID0+IHBvaW50SW5SZWN0KHBvaW50LCBpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJbnNlcnRUYXJnZXQobGlzdCwgdGFyZ2V0LCBwbGFjZWhvbGRlciwgeCwgeSwgc2FtZUxpc3QpIHtcbiAgICAgIGlmICghY2hpbGRyZW4obGlzdCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICghc2FtZUxpc3QpIHtcbiAgICAgICAgaWYgKCFpc0hvcml6b250YWwobGlzdCwgcGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHkgPCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMiA/IHRhcmdldCA6IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwbGFjZWhvbGRlclJlY3QgPSBwbGFjZWhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNhbWVSb3cgPSBsaW5lc0ludGVyc2VjdChcbiAgICAgIFtyZWN0LnRvcCwgcmVjdC5ib3R0b21dLFxuICAgICAgW3BsYWNlaG9sZGVyUmVjdC50b3AsIHBsYWNlaG9sZGVyUmVjdC5ib3R0b21dKTtcblxuXG4gICAgICBjb25zdCBwb2ludGVyUG9zID0gc2FtZVJvdyA/IHggOiB5O1xuICAgICAgY29uc3QgbGVuZ3RoUHJvcCA9IHNhbWVSb3cgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICBjb25zdCBzdGFydFByb3AgPSBzYW1lUm93ID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICBjb25zdCBlbmRQcm9wID0gc2FtZVJvdyA/ICdyaWdodCcgOiAnYm90dG9tJztcblxuICAgICAgY29uc3QgZGlmZiA9XG4gICAgICBwbGFjZWhvbGRlclJlY3RbbGVuZ3RoUHJvcF0gPCByZWN0W2xlbmd0aFByb3BdID9cbiAgICAgIHJlY3RbbGVuZ3RoUHJvcF0gLSBwbGFjZWhvbGRlclJlY3RbbGVuZ3RoUHJvcF0gOlxuICAgICAgMDtcblxuICAgICAgaWYgKHBsYWNlaG9sZGVyUmVjdFtzdGFydFByb3BdIDwgcmVjdFtzdGFydFByb3BdKSB7XG4gICAgICAgIGlmIChkaWZmICYmIHBvaW50ZXJQb3MgPCByZWN0W3N0YXJ0UHJvcF0gKyBkaWZmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmICYmIHBvaW50ZXJQb3MgPiByZWN0W2VuZFByb3BdIC0gZGlmZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIb3Jpem9udGFsKGxpc3QsIHBsYWNlaG9sZGVyKSB7XG4gICAgICBjb25zdCBzaW5nbGUgPSBjaGlsZHJlbihsaXN0KS5sZW5ndGggPT09IDE7XG5cbiAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgYXBwZW5kKGxpc3QsIHBsYWNlaG9sZGVyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXRlbXMgPSBjaGlsZHJlbihsaXN0KTtcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGl0ZW1zLnNvbWUoKGVsLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3RBID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBpdGVtcy5zbGljZShpICsgMSkuc29tZSgoZWwpID0+IHtcbiAgICAgICAgICBjb25zdCByZWN0QiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHJldHVybiAhbGluZXNJbnRlcnNlY3QoW3JlY3RBLmxlZnQsIHJlY3RBLnJpZ2h0XSwgW3JlY3RCLmxlZnQsIHJlY3RCLnJpZ2h0XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgcmVtb3ZlJDEocGxhY2Vob2xkZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNIb3Jpem9udGFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVzSW50ZXJzZWN0KGxpbmVBLCBsaW5lQikge1xuICAgICAgcmV0dXJuIGxpbmVBWzFdID4gbGluZUJbMF0gJiYgbGluZUJbMV0gPiBsaW5lQVswXTtcbiAgICB9XG5cbiAgICB2YXIgdG9vbHRpcCA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lciwgVG9nZ2xhYmxlLCBQb3NpdGlvbl0sXG5cbiAgICAgIGFyZ3M6ICd0aXRsZScsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRlbGF5OiBOdW1iZXIsXG4gICAgICAgIHRpdGxlOiBTdHJpbmdcbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcG9zOiAndG9wJyxcbiAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgYW5pbWF0aW9uOiBbJ3VrLWFuaW1hdGlvbi1zY2FsZS11cCddLFxuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICBjbHM6ICd1ay1hY3RpdmUnXG4gICAgICB9LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmlkID0gYHVrLXRvb2x0aXAtJHt0aGlzLl91aWR9YDtcbiAgICAgICAgdGhpcy5faGFzVGl0bGUgPSBoYXNBdHRyKHRoaXMuJGVsLCAndGl0bGUnKTtcbiAgICAgICAgYXR0cih0aGlzLiRlbCwge1xuICAgICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IHRoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIG1ha2VGb2N1c2FibGUodGhpcy4kZWwpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcblxuICAgICAgICBpZiAoIWF0dHIodGhpcy4kZWwsICd0aXRsZScpKSB7XG4gICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ3RpdGxlJywgdGhpcy5faGFzVGl0bGUgPyB0aGlzLnRpdGxlIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQodGhpcy50b29sdGlwIHx8IG51bGwpIHx8ICF0aGlzLnRpdGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdW5iaW5kID0gb25jZShcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICBga2V5ZG93biAke3BvaW50ZXJEb3duJDF9YCxcbiAgICAgICAgICB0aGlzLmhpZGUsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgKGUpID0+IGUudHlwZSA9PT0gcG9pbnRlckRvd24kMSAmJiAhd2l0aGluKGUudGFyZ2V0LCB0aGlzLiRlbCkgfHxcbiAgICAgICAgICBlLnR5cGUgPT09ICdrZXlkb3duJyAmJiBlLmtleUNvZGUgPT09IDI3KTtcblxuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVyKTtcbiAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fc2hvdywgdGhpcy5kZWxheSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXN5bmMgaGlkZSgpIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcyh0aGlzLiRlbCwgJ2lucHV0OmZvY3VzJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZXIpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVG9nZ2xlZCh0aGlzLnRvb2x0aXAgfHwgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy50b29sdGlwLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgIHJlbW92ZSQxKHRoaXMudG9vbHRpcCk7XG4gICAgICAgICAgdGhpcy50b29sdGlwID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl91bmJpbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvdygpIHtcbiAgICAgICAgICB0aGlzLnRvb2x0aXAgPSBhcHBlbmQoXG4gICAgICAgICAgdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgYDxkaXYgaWQ9XCIke3RoaXMuaWR9XCIgY2xhc3M9XCJ1ay0ke3RoaXMuJG9wdGlvbnMubmFtZX1cIiByb2xlPVwidG9vbHRpcFwiPiA8ZGl2IGNsYXNzPVwidWstJHt0aGlzLiRvcHRpb25zLm5hbWV9LWlubmVyXCI+JHt0aGlzLnRpdGxlfTwvZGl2PiA8L2Rpdj5gKTtcblxuXG4gICAgICAgICAgb24odGhpcy50b29sdGlwLCAndG9nZ2xlZCcsIChlLCB0b2dnbGVkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uQXQodGhpcy50b29sdGlwLCB0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IFtkaXIsIGFsaWduXSA9IGdldEFsaWdubWVudCh0aGlzLnRvb2x0aXAsIHRoaXMuJGVsLCB0aGlzLnBvcyk7XG5cbiAgICAgICAgICAgIHRoaXMub3JpZ2luID1cbiAgICAgICAgICAgIHRoaXMuYXhpcyA9PT0gJ3knID9cbiAgICAgICAgICAgIGAke2ZsaXBQb3NpdGlvbihkaXIpfS0ke2FsaWdufWAgOlxuICAgICAgICAgICAgYCR7YWxpZ259LSR7ZmxpcFBvc2l0aW9uKGRpcil9YDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRvb2x0aXAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgZm9jdXM6ICdzaG93JyxcbiAgICAgICAgYmx1cjogJ2hpZGUnLFxuXG4gICAgICAgIFtgJHtwb2ludGVyRW50ZXJ9ICR7cG9pbnRlckxlYXZlfWBdKGUpIHtcbiAgICAgICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgIHRoaXNbZS50eXBlID09PSBwb2ludGVyRW50ZXIgPyAnc2hvdycgOiAnaGlkZSddKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENsaWNraW5nIGEgYnV0dG9uIGRvZXMgbm90IGdpdmUgaXQgZm9jdXMgb24gYWxsIGJyb3dzZXJzIGFuZCBwbGF0Zm9ybXNcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2J1dHRvbiNjbGlja2luZ19hbmRfZm9jdXNcbiAgICAgICAgW3BvaW50ZXJEb3duJDFdKGUpIHtcbiAgICAgICAgICBpZiAoaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VGb2N1c2FibGUoZWwpIHtcbiAgICAgIGlmICghaXNGb2N1c2FibGUoZWwpKSB7XG4gICAgICAgIGF0dHIoZWwsICd0YWJpbmRleCcsICcwJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QWxpZ25tZW50KGVsLCB0YXJnZXQsIFtkaXIsIGFsaWduXSkge1xuICAgICAgY29uc3QgZWxPZmZzZXQgPSBvZmZzZXQoZWwpO1xuICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KHRhcmdldCk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gW1xuICAgICAgWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBbJ3RvcCcsICdib3R0b20nXV07XG5cblxuICAgICAgZm9yIChjb25zdCBwcm9wcyBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChlbE9mZnNldFtwcm9wc1swXV0gPj0gdGFyZ2V0T2Zmc2V0W3Byb3BzWzFdXSkge1xuICAgICAgICAgIGRpciA9IHByb3BzWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbE9mZnNldFtwcm9wc1sxXV0gPD0gdGFyZ2V0T2Zmc2V0W3Byb3BzWzBdXSkge1xuICAgICAgICAgIGRpciA9IHByb3BzWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gaW5jbHVkZXMocHJvcGVydGllc1swXSwgZGlyKSA/IHByb3BlcnRpZXNbMV0gOiBwcm9wZXJ0aWVzWzBdO1xuICAgICAgaWYgKGVsT2Zmc2V0W3Byb3BzWzBdXSA9PT0gdGFyZ2V0T2Zmc2V0W3Byb3BzWzBdXSkge1xuICAgICAgICBhbGlnbiA9IHByb3BzWzBdO1xuICAgICAgfSBlbHNlIGlmIChlbE9mZnNldFtwcm9wc1sxXV0gPT09IHRhcmdldE9mZnNldFtwcm9wc1sxXV0pIHtcbiAgICAgICAgYWxpZ24gPSBwcm9wc1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZGlyLCBhbGlnbl07XG4gICAgfVxuXG4gICAgdmFyIHVwbG9hZCA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGFsbG93OiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWdvdmVyOiBTdHJpbmcsXG4gICAgICAgIGNvbmN1cnJlbnQ6IE51bWJlcixcbiAgICAgICAgbWF4U2l6ZTogTnVtYmVyLFxuICAgICAgICBtZXRob2Q6IFN0cmluZyxcbiAgICAgICAgbWltZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkTWltZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkTmFtZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkU2l6ZTogU3RyaW5nLFxuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICAgICAgbmFtZTogU3RyaW5nLFxuICAgICAgICBwYXJhbXM6IE9iamVjdCxcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB1cmw6IFN0cmluZ1xuICAgICAgfSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBhbGxvdzogZmFsc2UsXG4gICAgICAgIGNsc0RyYWdvdmVyOiAndWstZHJhZ292ZXInLFxuICAgICAgICBjb25jdXJyZW50OiAxLFxuICAgICAgICBtYXhTaXplOiAwLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgbWltZTogZmFsc2UsXG4gICAgICAgIG1zZ0ludmFsaWRNaW1lOiAnSW52YWxpZCBGaWxlIFR5cGU6ICVzJyxcbiAgICAgICAgbXNnSW52YWxpZE5hbWU6ICdJbnZhbGlkIEZpbGUgTmFtZTogJXMnLFxuICAgICAgICBtc2dJbnZhbGlkU2l6ZTogJ0ludmFsaWQgRmlsZSBTaXplOiAlcyBLaWxvYnl0ZXMgTWF4JyxcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICBuYW1lOiAnZmlsZXNbXScsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHR5cGU6ICcnLFxuICAgICAgICB1cmw6ICcnLFxuICAgICAgICBhYm9ydDogbm9vcCxcbiAgICAgICAgYmVmb3JlQWxsOiBub29wLFxuICAgICAgICBiZWZvcmVTZW5kOiBub29wLFxuICAgICAgICBjb21wbGV0ZTogbm9vcCxcbiAgICAgICAgY29tcGxldGVBbGw6IG5vb3AsXG4gICAgICAgIGVycm9yOiBub29wLFxuICAgICAgICBmYWlsOiBub29wLFxuICAgICAgICBsb2FkOiBub29wLFxuICAgICAgICBsb2FkRW5kOiBub29wLFxuICAgICAgICBsb2FkU3RhcnQ6IG5vb3AsXG4gICAgICAgIHByb2dyZXNzOiBub29wXG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgY2hhbmdlKGUpIHtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMoZS50YXJnZXQsICdpbnB1dFt0eXBlPVwiZmlsZVwiXScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKGUudGFyZ2V0LmZpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZChlLnRhcmdldC5maWxlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS50YXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBkcm9wKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuXG4gICAgICAgICAgY29uc3QgdHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgICAgIGlmICghKHRyYW5zZmVyICE9IG51bGwgJiYgdHJhbnNmZXIuZmlsZXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJhZ292ZXIpO1xuXG4gICAgICAgICAgdGhpcy51cGxvYWQodHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdlbnRlcihlKSB7XG4gICAgICAgICAgc3RvcChlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnb3ZlcihlKSB7XG4gICAgICAgICAgc3RvcChlKTtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcmFnb3Zlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhZ2xlYXZlKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0RyYWdvdmVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyB1cGxvYWQoZmlsZXMpIHtcbiAgICAgICAgICBmaWxlcyA9IHRvQXJyYXkoZmlsZXMpO1xuXG4gICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAndXBsb2FkJywgW2ZpbGVzXSk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5tYXhTaXplICogMTAwMCA8IGZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwodGhpcy5tc2dJbnZhbGlkU2l6ZS5yZXBsYWNlKCclcycsIHRoaXMubWF4U2l6ZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93ICYmICFtYXRjaCh0aGlzLmFsbG93LCBmaWxlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmFpbCh0aGlzLm1zZ0ludmFsaWROYW1lLnJlcGxhY2UoJyVzJywgdGhpcy5hbGxvdykpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbWUgJiYgIW1hdGNoKHRoaXMubWltZSwgZmlsZS50eXBlKSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwodGhpcy5tc2dJbnZhbGlkTWltZS5yZXBsYWNlKCclcycsIHRoaXMubWltZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICBmaWxlcyA9IGZpbGVzLnNsaWNlKDAsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYmVmb3JlQWxsKHRoaXMsIGZpbGVzKTtcblxuICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGNodW5rKGZpbGVzLCB0aGlzLmNvbmN1cnJlbnQpO1xuICAgICAgICAgIGNvbnN0IHVwbG9hZCA9IGFzeW5jIChmaWxlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiBkYXRhLmFwcGVuZCh0aGlzLm5hbWUsIGZpbGUpKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoa2V5LCB0aGlzLnBhcmFtc1trZXldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeGhyID0gYXdhaXQgYWpheCh0aGlzLnVybCwge1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kOiAoZW52KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7IHhociB9ID0gZW52O1xuICAgICAgICAgICAgICAgICAgeGhyLnVwbG9hZCAmJiBvbih4aHIudXBsb2FkLCAncHJvZ3Jlc3MnLCB0aGlzLnByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ2xvYWRTdGFydCcsICdsb2FkJywgJ2xvYWRFbmQnLCAnYWJvcnQnXSkge1xuICAgICAgICAgICAgICAgICAgICBvbih4aHIsIHR5cGUudG9Mb3dlckNhc2UoKSwgdGhpc1t0eXBlXSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNlbmQoZW52KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoeGhyKTtcblxuICAgICAgICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZChjaHVua3Muc2hpZnQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFsbCh4aHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGF3YWl0IHVwbG9hZChjaHVua3Muc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF0Y2gocGF0dGVybiwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubWF0Y2goXG4gICAgICBuZXcgUmVnRXhwKFxuICAgICAgYF4ke3BhdHRlcm4uXG4gIHJlcGxhY2UoL1xcLy9nLCAnXFxcXC8nKS5cbiAgcmVwbGFjZSgvXFwqXFwqL2csICcoXFxcXC9bXlxcXFwvXSspKicpLlxuICByZXBsYWNlKC9cXCovZywgJ1teXFxcXC9dKycpLlxuICByZXBsYWNlKC8oKD8hXFxcXCkpXFw/L2csICckMS4nKX0kYCxcbiAgICAgICdpJykpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaHVuayhmaWxlcywgc2l6ZSkge1xuICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSArPSBzaXplKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGZpbGVzLnNsaWNlKGksIGkgKyBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2h1bmtzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3AoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBDb3VudGRvd246IGNvdW50ZG93bixcbiAgICAgICAgRmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIExpZ2h0Ym94OiBsaWdodGJveCxcbiAgICAgICAgTGlnaHRib3hQYW5lbDogTGlnaHRib3hQYW5lbCxcbiAgICAgICAgTm90aWZpY2F0aW9uOiBub3RpZmljYXRpb24sXG4gICAgICAgIFBhcmFsbGF4OiBwYXJhbGxheCxcbiAgICAgICAgU2xpZGVyOiBzbGlkZXIsXG4gICAgICAgIFNsaWRlclBhcmFsbGF4OiBzbGlkZXJQYXJhbGxheCxcbiAgICAgICAgU2xpZGVzaG93OiBzbGlkZXNob3csXG4gICAgICAgIFNsaWRlc2hvd1BhcmFsbGF4OiBzbGlkZXJQYXJhbGxheCxcbiAgICAgICAgU29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICBUb29sdGlwOiB0b29sdGlwLFxuICAgICAgICBVcGxvYWQ6IHVwbG9hZFxuICAgIH0pO1xuXG4gICAgZWFjaChjb21wb25lbnRzLCAoY29tcG9uZW50LCBuYW1lKSA9PiBVSWtpdC5jb21wb25lbnQobmFtZSwgY29tcG9uZW50KSk7XG5cbiAgICByZXR1cm4gVUlraXQ7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/dist/js/uikit.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/public/js/app": 0,
/******/ 			"public/css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkvidena"] = self["webpackChunkvidena"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["public/css/app"], () => (__webpack_require__("./src/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["public/css/app"], () => (__webpack_require__("./src/less/app.less")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;